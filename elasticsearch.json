[
	{
		"documentation": "",
		"name": "org.elasticsearch.benchmark.bytes.BytesArrayReadLongBenchmark",
		"extends": "",
		"Methods": [
			{
				"signature": "public void initResults() throws IOException",
				"documentation": ""
			},
			{
				"signature": "public long readLong() throws IOException",
				"documentation": ""
			}
		],
		"interfaces": []
	},
	{
		"documentation": "",
		"name": "org.elasticsearch.benchmark.bytes.BytesArrayReadVLongBenchmark",
		"extends": "",
		"Methods": [
			{
				"signature": "public void initResults() throws IOException",
				"documentation": ""
			},
			{
				"signature": "public long readVLong() throws IOException",
				"documentation": ""
			}
		],
		"interfaces": []
	},
	{
		"documentation": "",
		"name": "org.elasticsearch.benchmark.bytes.PagedBytesReferenceReadLongBenchmark",
		"extends": "",
		"Methods": [
			{
				"signature": "public void initResults() throws IOException",
				"documentation": ""
			},
			{
				"signature": "public long readLong() throws IOException",
				"documentation": ""
			}
		],
		"interfaces": []
	},
	{
		"documentation": "",
		"name": "org.elasticsearch.benchmark.bytes.PagedBytesReferenceReadVIntBenchmark",
		"extends": "",
		"Methods": [
			{
				"signature": "public void initResults() throws IOException",
				"documentation": ""
			},
			{
				"signature": "public int readVInt() throws IOException",
				"documentation": ""
			}
		],
		"interfaces": []
	},
	{
		"documentation": "",
		"name": "org.elasticsearch.benchmark.bytes.PagedBytesReferenceReadVLongBenchmark",
		"extends": "",
		"Methods": [
			{
				"signature": "public void initResults() throws IOException",
				"documentation": ""
			},
			{
				"signature": "public long readVLong() throws IOException",
				"documentation": ""
			}
		],
		"interfaces": []
	},
	{
		"documentation": "",
		"name": "org.elasticsearch.benchmark.fs.AvailableIndexFoldersBenchmark",
		"extends": "",
		"Methods": [
			{
				"signature": "public void setup() throws IOException",
				"documentation": ""
			},
			{
				"signature": "public Set\u003cString\u003e availableIndexFolderNaive() throws IOException",
				"documentation": ""
			},
			{
				"signature": "public Set\u003cString\u003e availableIndexFolderOptimized() throws IOException",
				"documentation": ""
			}
		],
		"interfaces": []
	},
	{
		"documentation": "",
		"name": "org.elasticsearch.benchmark.indices.breaker.MemoryStatsBenchmark",
		"extends": "",
		"Methods": [
			{
				"signature": "public void baseline()",
				"documentation": ""
			},
			{
				"signature": "public long getMemoryStats_01()",
				"documentation": ""
			},
			{
				"signature": "public long getMemoryStats_02()",
				"documentation": ""
			},
			{
				"signature": "public long getMemoryStats_04()",
				"documentation": ""
			},
			{
				"signature": "public long getMemoryStats_08()",
				"documentation": ""
			},
			{
				"signature": "public long getMemoryStats_16()",
				"documentation": ""
			},
			{
				"signature": "public long getMemoryStats_32()",
				"documentation": ""
			},
			{
				"signature": "public long getMemoryStats_64()",
				"documentation": ""
			}
		],
		"interfaces": []
	},
	{
		"documentation": "",
		"name": "org.elasticsearch.benchmark.indices.common.RoundingBenchmark",
		"extends": "",
		"Methods": [
			{
				"signature": "public void buildDates()",
				"documentation": ""
			},
			{
				"signature": "public void round(Blackhole bh)",
				"documentation": ""
			},
			{
				"signature": "public void nextRoundingValue(Blackhole bh)",
				"documentation": ""
			}
		],
		"interfaces": []
	},
	{
		"documentation": "",
		"name": "org.elasticsearch.benchmark.routing.allocation.AllocationBenchmark",
		"extends": "",
		"Methods": [
			{
				"signature": "public void setUp() throws Exception",
				"documentation": ""
			},
			{
				"signature": "private int toInt(String v)",
				"documentation": ""
			},
			{
				"signature": "public ClusterState measureAllocation()",
				"documentation": ""
			}
		],
		"interfaces": []
	},
	{
		"documentation": "",
		"name": "org.elasticsearch.benchmark.routing.allocation.Allocators",
		"extends": "",
		"Methods": [
			{
				"signature": "private Allocators()",
				"documentation": ""
			},
			{
				"signature": "public static AllocationService createAllocationService(Settings settings)",
				"documentation": ""
			},
			{
				"signature": "public static AllocationService createAllocationService(Settings settings, ClusterSettings clusterSettings)",
				"documentation": ""
			},
			{
				"signature": "public static AllocationDeciders defaultAllocationDeciders(Settings settings, ClusterSettings clusterSettings)",
				"documentation": ""
			},
			{
				"signature": "public static DiscoveryNode newNode(String nodeId, Map\u003cString, String\u003e attributes)",
				"documentation": ""
			}
		],
		"interfaces": []
	},
	{
		"documentation": "",
		"name": "org.elasticsearch.benchmark.routing.allocation.Allocators.NoopGatewayAllocator",
		"extends": "org.elasticsearch.gateway.GatewayAllocator",
		"Methods": [
			{
				"signature": "public void applyStartedShards(List\u003cShardRouting\u003e startedShards, RoutingAllocation allocation)",
				"documentation": ""
			},
			{
				"signature": "public void applyFailedShards(List\u003cFailedShard\u003e failedShards, RoutingAllocation allocation)",
				"documentation": ""
			},
			{
				"signature": "public void allocateUnassigned(            ShardRouting shardRouting,            RoutingAllocation allocation,            UnassignedAllocationHandler unassignedAllocationHandler        )",
				"documentation": ""
			}
		],
		"interfaces": []
	},
	{
		"documentation": "/**\n * A race between Lucene Expressions, Painless, and a hand optimized script\n * implementing a {@link ScriptScoreQuery}.\n */",
		"name": "org.elasticsearch.benchmark.script.ScriptScoreBenchmark",
		"extends": "",
		"Methods": [
			{
				"signature": "public void setupScript()",
				"documentation": ""
			},
			{
				"signature": "public void setupIndex() throws IOException",
				"documentation": ""
			},
			{
				"signature": "public TopDocs benchmark() throws IOException",
				"documentation": ""
			},
			{
				"signature": "private Query scriptScoreQuery(ScoreScript.Factory factory)",
				"documentation": ""
			},
			{
				"signature": "private ScoreScript.Factory bareMetalScript()",
				"documentation": ""
			},
			{
				"signature": "public ScoreScript newInstance(DocReader docReader) throws IOException",
				"documentation": ""
			},
			{
				"signature": "public double execute(ExplanationHolder explanation)",
				"documentation": ""
			},
			{
				"signature": "public void setDocument(int docid)",
				"documentation": ""
			},
			{
				"signature": "public boolean needs_score()",
				"documentation": ""
			}
		],
		"interfaces": []
	},
	{
		"documentation": "",
		"name": "org.elasticsearch.benchmark.search.QueryParserHelperBenchmark",
		"extends": "",
		"Methods": [
			{
				"signature": "public void setup() throws IOException",
				"documentation": ""
			},
			{
				"signature": "private SourceToParse buildDoc(int docId)",
				"documentation": ""
			},
			{
				"signature": "public void tearDown()",
				"documentation": ""
			},
			{
				"signature": "public void expand()",
				"documentation": ""
			},
			{
				"signature": "protected SearchExecutionContext buildSearchExecutionContext()",
				"documentation": ""
			},
			{
				"signature": "protected final MapperService createMapperService(String mappings)",
				"documentation": ""
			},
			{
				"signature": "public \u003cT\u003e T compile(Script script, ScriptContext\u003cT\u003e scriptContext)",
				"documentation": ""
			}
		],
		"interfaces": []
	},
	{
		"documentation": "/**\n * Benchmarks the overhead of constructing {@link Aggregator}s in many\n * parallel threads. Machines with different numbers of cores will see\n * wildly different results running this from running this with more\n * cores seeing more benefits from preallocation.\n */",
		"name": "org.elasticsearch.benchmark.search.aggregations.AggConstructionContentionBenchmark",
		"extends": "",
		"Methods": [
			{
				"signature": "public void setup()",
				"documentation": ""
			},
			{
				"signature": "public void sum() throws IOException",
				"documentation": ""
			},
			{
				"signature": "public void termsSum() throws IOException",
				"documentation": ""
			},
			{
				"signature": "public void termsSixtySums() throws IOException",
				"documentation": ""
			},
			{
				"signature": "private void buildFactories(AggregatorFactories.Builder factories) throws IOException",
				"documentation": ""
			}
		],
		"interfaces": []
	},
	{
		"documentation": "",
		"name": "org.elasticsearch.benchmark.search.aggregations.DummyAggregationContext",
		"extends": "org.elasticsearch.search.aggregations.support.AggregationContext",
		"Methods": [
			{
				"signature": "DummyAggregationContext(long bytesToPreallocate)",
				"documentation": ""
			},
			{
				"signature": "public Query query()",
				"documentation": ""
			},
			{
				"signature": "public Aggregator profileIfEnabled(Aggregator agg) throws IOException",
				"documentation": ""
			},
			{
				"signature": "public boolean profiling()",
				"documentation": ""
			},
			{
				"signature": "public long nowInMillis()",
				"documentation": ""
			},
			{
				"signature": "public Analyzer getNamedAnalyzer(String analyzer)",
				"documentation": ""
			},
			{
				"signature": "public Analyzer buildCustomAnalyzer(            IndexSettings indexSettings,            boolean normalizer,            NameOrDefinition tokenizer,            List\u003cNameOrDefinition\u003e charFilters,            List\u003cNameOrDefinition\u003e tokenFilters        )",
				"documentation": ""
			},
			{
				"signature": "protected IndexFieldData\u003c?\u003e buildFieldData(MappedFieldType ft)",
				"documentation": ""
			},
			{
				"signature": "public MappedFieldType getFieldType(String path)",
				"documentation": ""
			},
			{
				"signature": "public Set\u003cString\u003e getMatchingFieldNames(String pattern)",
				"documentation": ""
			},
			{
				"signature": "public boolean isFieldMapped(String field)",
				"documentation": ""
			},
			{
				"signature": "public \u003cFactoryType\u003e FactoryType compile(Script script, ScriptContext\u003cFactoryType\u003e context)",
				"documentation": ""
			},
			{
				"signature": "public SearchLookup lookup()",
				"documentation": ""
			},
			{
				"signature": "public ValuesSourceRegistry getValuesSourceRegistry()",
				"documentation": ""
			},
			{
				"signature": "public BigArrays bigArrays()",
				"documentation": ""
			},
			{
				"signature": "public IndexSearcher searcher()",
				"documentation": ""
			},
			{
				"signature": "public Query buildQuery(QueryBuilder builder) throws IOException",
				"documentation": ""
			},
			{
				"signature": "public Query filterQuery(Query query)",
				"documentation": ""
			},
			{
				"signature": "public IndexSettings getIndexSettings()",
				"documentation": ""
			},
			{
				"signature": "public Optional\u003cSortAndFormats\u003e buildSort(List\u003cSortBuilder\u003c?\u003e\u003e sortBuilders) throws IOException",
				"documentation": ""
			},
			{
				"signature": "public NestedLookup nestedLookup()",
				"documentation": ""
			},
			{
				"signature": "public NestedScope nestedScope()",
				"documentation": ""
			},
			{
				"signature": "public SubSearchContext subSearchContext()",
				"documentation": ""
			},
			{
				"signature": "public void addReleasable(Aggregator aggregator)",
				"documentation": ""
			},
			{
				"signature": "public MultiBucketConsumer multiBucketConsumer()",
				"documentation": ""
			},
			{
				"signature": "public BitsetFilterCache bitsetFilterCache()",
				"documentation": ""
			},
			{
				"signature": "public BucketedSort buildBucketedSort(SortBuilder\u003c?\u003e sort, int size, ExtraData values) throws IOException",
				"documentation": ""
			},
			{
				"signature": "public int shardRandomSeed()",
				"documentation": ""
			},
			{
				"signature": "public long getRelativeTimeInMillis()",
				"documentation": ""
			},
			{
				"signature": "public boolean isCancelled()",
				"documentation": ""
			},
			{
				"signature": "public CircuitBreaker breaker()",
				"documentation": ""
			},
			{
				"signature": "public Analyzer getIndexAnalyzer(Function\u003cString, NamedAnalyzer\u003e unindexedFieldAnalyzer)",
				"documentation": ""
			},
			{
				"signature": "public boolean isCacheable()",
				"documentation": ""
			},
			{
				"signature": "public boolean enableRewriteToFilterByFilter()",
				"documentation": ""
			},
			{
				"signature": "public boolean isInSortOrderExecutionRequired()",
				"documentation": ""
			},
			{
				"signature": "public Set\u003cString\u003e sourcePath(String fullName)",
				"documentation": ""
			},
			{
				"signature": "public void close()",
				"documentation": ""
			}
		],
		"interfaces": []
	},
	{
		"documentation": "",
		"name": "org.elasticsearch.benchmark.search.aggregations.TermsReduceBenchmark",
		"extends": "",
		"Methods": [
			{
				"signature": "public AggregationReduceContext forPartialReduction()",
				"documentation": ""
			},
			{
				"signature": "public AggregationReduceContext forFinalReduction()",
				"documentation": ""
			},
			{
				"signature": "public SearchPhaseController.ReducedQueryPhase reduceAggs(TermsList candidateList) throws Exception",
				"documentation": ""
			}
		],
		"interfaces": []
	},
	{
		"documentation": "",
		"name": "org.elasticsearch.benchmark.search.aggregations.TermsReduceBenchmark.TermsList",
		"extends": "java.util.AbstractList",
		"Methods": [
			{
				"signature": "public void setup()",
				"documentation": ""
			},
			{
				"signature": "private StringTerms newTerms(Random rand, BytesRef[] dict, boolean withNested)",
				"documentation": ""
			},
			{
				"signature": "public InternalAggregations get(int index)",
				"documentation": ""
			},
			{
				"signature": "public int size()",
				"documentation": ""
			}
		],
		"interfaces": []
	},
	{
		"documentation": "",
		"name": "org.elasticsearch.benchmark.search.aggregations.bucket.terms.LongKeyedBucketOrdsBenchmark",
		"extends": "",
		"Methods": [
			{
				"signature": "public void forceLoadClasses(Blackhole bh)",
				"documentation": "/**\n     * Force loading all of the implementations just for extra paranoia's sake.\n     * We really don't want the JVM to be able to eliminate one of them just\n     * because we don't use it in the particular benchmark. That is totally a\n     * thing it'd do. It is sneaky.\n     */"
			},
			{
				"signature": "public void singleBucketIntoSingleImmutableMonmorphicInvocation(Blackhole bh)",
				"documentation": "/**\n     * Emulates a way that we do \u003cstrong\u003enot\u003c/strong\u003e use {@link LongKeyedBucketOrds}\n     * because it is not needed.\n     */"
			},
			{
				"signature": "public void singleBucketIntoSingleImmutableMegamorphicInvocation(Blackhole bh)",
				"documentation": "/**\n     * Emulates the way that most aggregations use {@link LongKeyedBucketOrds}.\n     */"
			},
			{
				"signature": "public void singleBucketIntoSingleMutableMonmorphicInvocation(Blackhole bh)",
				"documentation": "/**\n     * Emulates the way that {@link AutoDateHistogramAggregationBuilder} uses {@link LongKeyedBucketOrds}.\n     */"
			},
			{
				"signature": "public void singleBucketIntoSingleMutableMegamorphicInvocation(Blackhole bh)",
				"documentation": "/**\n     * Emulates a way that we do \u003cstrong\u003enot\u003c/strong\u003e use {@link LongKeyedBucketOrds}\n     * because it is significantly slower than the\n     * {@link #singleBucketIntoSingleMutableMonmorphicInvocation monomorphic invocation}.\n     */"
			},
			{
				"signature": "public void singleBucketIntoMulti(Blackhole bh)",
				"documentation": "/**\n     * Emulates an aggregation that collects from a single bucket \"by accident\".\n     * This can happen if an aggregation is under, say, a {@code terms}\n     * aggregation and there is only a single value for that term in the index\n     * but we can't tell that up front.\n     */"
			},
			{
				"signature": "public void singleBucketIntoMultiSmall(Blackhole bh)",
				"documentation": "/**\n     * Emulates an aggregation that collects from a single bucket \"by accident\"\n     * and gets a \"small\" bucket ords. This can happen to a {@code terms} inside\n     * of another {@code terms} when the \"inner\" terms only even has a single\n     * bucket.\n     */"
			},
			{
				"signature": "private void singleBucketIntoMultiSmall(LongKeyedBucketOrds ords)",
				"documentation": ""
			},
			{
				"signature": "public void multiBucketManySmall(Blackhole bh)",
				"documentation": "/**\n     * Emulates an aggregation that collects from many buckets with a known\n     * bounds on the values.\n     */"
			},
			{
				"signature": "public void multiBucketMany(Blackhole bh)",
				"documentation": "/**\n     * Emulates an aggregation that collects from many buckets.\n     */"
			},
			{
				"signature": "private void multiBucket(Blackhole bh, LongKeyedBucketOrds ords)",
				"documentation": ""
			}
		],
		"interfaces": []
	},
	{
		"documentation": "",
		"name": "org.elasticsearch.benchmark.search.aggregations.bucket.terms.StringTermsSerializationBenchmark",
		"extends": "",
		"Methods": [
			{
				"signature": "public void initResults()",
				"documentation": ""
			},
			{
				"signature": "private StringTerms newTerms(boolean withNested)",
				"documentation": ""
			},
			{
				"signature": "public DelayableWriteable\u003cInternalAggregations\u003e serialize()",
				"documentation": ""
			}
		],
		"interfaces": []
	},
	{
		"documentation": "",
		"name": "org.elasticsearch.benchmark.search.fetch.subphase.FetchSourcePhaseBenchmark",
		"extends": "",
		"Methods": [
			{
				"signature": "public void setup() throws IOException",
				"documentation": ""
			},
			{
				"signature": "private BytesReference read300BytesExample() throws IOException",
				"documentation": ""
			},
			{
				"signature": "private BytesReference buildBigExample(String extraText) throws IOException",
				"documentation": ""
			},
			{
				"signature": "public BytesReference filterObjects() throws IOException",
				"documentation": ""
			},
			{
				"signature": "public BytesReference filterXContentOnParser() throws IOException",
				"documentation": ""
			},
			{
				"signature": "public BytesReference filterXContentOnBuilder() throws IOException",
				"documentation": ""
			}
		],
		"interfaces": []
	},
	{
		"documentation": "",
		"name": "org.elasticsearch.benchmark.time.DateFormatterFromBenchmark",
		"extends": "",
		"Methods": [
			{
				"signature": "public TemporalAccessor benchmarkFrom()",
				"documentation": ""
			}
		],
		"interfaces": []
	},
	{
		"documentation": "",
		"name": "org.elasticsearch.benchmark.xcontent.FilterContentBenchmark",
		"extends": "",
		"Methods": [
			{
				"signature": "public void setup() throws IOException",
				"documentation": ""
			},
			{
				"signature": "private Set\u003cString\u003e buildFilters()",
				"documentation": ""
			},
			{
				"signature": "public BytesReference filterWithParserConfigCreated() throws IOException",
				"documentation": ""
			},
			{
				"signature": "public BytesReference filterWithParserConfigCreatedMatchDotsInFieldNames() throws IOException",
				"documentation": ""
			},
			{
				"signature": "public BytesReference filterWithNewParserConfig() throws IOException",
				"documentation": ""
			},
			{
				"signature": "public BytesReference filterWithMap() throws IOException",
				"documentation": ""
			},
			{
				"signature": "public BytesReference filterWithBuilder() throws IOException",
				"documentation": ""
			},
			{
				"signature": "private XContentParserConfiguration buildParseConfig(boolean matchDotsInFieldNames)",
				"documentation": ""
			},
			{
				"signature": "private BytesReference filter(XContentParserConfiguration contentParserConfiguration) throws IOException",
				"documentation": ""
			},
			{
				"signature": "private BytesReference readSource(String fileName) throws IOException",
				"documentation": ""
			}
		],
		"interfaces": []
	},
	{
		"documentation": "/**\n * This is a copy of Checkstyle's {@link com.puppycrawl.tools.checkstyle.checks.coding.HiddenFieldCheck}. See\n * the original class for full documentation.\n */",
		"name": "org.elasticsearch.gradle.internal.checkstyle.HiddenFieldCheck",
		"extends": "com.puppycrawl.tools.checkstyle.api.AbstractCheck",
		"Methods": [
			{
				"signature": "public int[] getDefaultTokens()",
				"documentation": "/** Control the minimal amount of lines in method to allow shadowed variables .*/"
			},
			{
				"signature": "public int[] getAcceptableTokens()",
				"documentation": ""
			},
			{
				"signature": "public int[] getRequiredTokens()",
				"documentation": ""
			},
			{
				"signature": "public void beginTree(DetailAST rootAST)",
				"documentation": ""
			},
			{
				"signature": "public void visitToken(DetailAST ast)",
				"documentation": ""
			},
			{
				"signature": "private void processLambda(DetailAST ast)",
				"documentation": "/**\n     * Process a lambda token.\n     * Checks whether a lambda parameter shadows a field.\n     * Note, that when parameter of lambda expression is untyped,\n     * ANTLR parses the parameter as an identifier.\n     *\n     * @param ast the lambda token.\n     */"
			},
			{
				"signature": "private void visitOtherTokens(DetailAST ast, int type)",
				"documentation": "/**\n     * Called to process tokens other than {@link TokenTypes#VARIABLE_DEF}\n     * and {@link TokenTypes#PARAMETER_DEF}.\n     *\n     * @param ast token to process\n     * @param type type of the token\n     */"
			},
			{
				"signature": "public void leaveToken(DetailAST ast)",
				"documentation": ""
			},
			{
				"signature": "private void processVariable(DetailAST ast)",
				"documentation": "/**\n     * Process a variable token.\n     * Check whether a local variable or parameter shadows a field.\n     * Store a field for later comparison with local variables and parameters.\n     *\n     * @param ast the variable token.\n     */"
			},
			{
				"signature": "private boolean isIgnoredParam(DetailAST ast, String name)",
				"documentation": "/**\n     * Checks whether method or constructor parameter is ignored.\n     *\n     * @param ast the parameter token.\n     * @param name the parameter name.\n     * @return true if parameter is ignored.\n     */"
			},
			{
				"signature": "private boolean isIgnoredVariable(DetailAST ast, String name)",
				"documentation": ""
			},
			{
				"signature": "private boolean isInstanceField(DetailAST ast, String name)",
				"documentation": "/**\n     * Check for instance field.\n     *\n     * @param ast token\n     * @param name identifier of token\n     * @return true if instance field\n     */"
			},
			{
				"signature": "private boolean isMatchingRegexp(String name)",
				"documentation": "/**\n     * Check name by regExp.\n     *\n     * @param name string value to check\n     * @return true is regexp is matching\n     */"
			},
			{
				"signature": "private static boolean isInStatic(DetailAST ast)",
				"documentation": "/**\n     * Determines whether an AST node is in a static method or static\n     * initializer.\n     *\n     * @param ast the node to check.\n     * @return true if ast is in a static method or a static block;\n     */"
			},
			{
				"signature": "private boolean isIgnoredSetterParam(DetailAST ast, String name)",
				"documentation": "/**\n     * Decides whether to ignore an AST node that is the parameter of a\n     * setter method, where the property setter method for field 'xyz' has\n     * name 'setXyz', one parameter named 'xyz', and return type void\n     * (default behavior) or return type is name of the class in which\n     * such method is declared (allowed only if\n     * {@link #setSetterCanReturnItsClass(boolean)} is called with\n     * value \u003cem\u003etrue\u003c/em\u003e).\n     *\n     * @param ast the AST to check.\n     * @param name the name of ast.\n     * @return true if ast should be ignored because check property\n     *     ignoreSetter is true and ast is the parameter of a setter method.\n     */"
			},
			{
				"signature": "private boolean isSetterMethod(DetailAST aMethodAST, String aName)",
				"documentation": "/**\n     * Determine if a specific method identified by methodAST and a single\n     * variable name aName is a setter. This recognition partially depends\n     * on setterCanReturnItsClass property.\n     *\n     * @param aMethodAST AST corresponding to a method call\n     * @param aName name of single parameter of this method.\n     * @return true of false indicating of method is a setter or not.\n     */"
			},
			{
				"signature": "private static String capitalize(final String name, boolean javaBeanCompliant)",
				"documentation": "/**\n     * Capitalizes a given property name the way we expect to see it in\n     * a setter name.\n     *\n     * @param name a property name\n     * @return capitalized property name\n     */"
			},
			{
				"signature": "private boolean isIgnoredConstructorParam(DetailAST ast)",
				"documentation": "/**\n     * Decides whether to ignore an AST node that is the parameter of a\n     * constructor.\n     *\n     * @param ast the AST to check.\n     * @return true if ast should be ignored because check property\n     *     ignoreConstructorParameter is true and ast is a constructor parameter.\n     */"
			},
			{
				"signature": "private boolean isIgnoredParamOfAbstractMethod(DetailAST ast)",
				"documentation": "/**\n     * Decides whether to ignore an AST node that is the parameter of an\n     * abstract method.\n     *\n     * @param ast the AST to check.\n     * @return true if ast should be ignored because check property\n     *     ignoreAbstractMethods is true and ast is a parameter of abstract methods.\n     */"
			},
			{
				"signature": "private boolean isVariableInIgnoredMethod(DetailAST ast, String name)",
				"documentation": "/**\n     * Decides whether to ignore an AST node that is witin a method that ought to be ignored.\n     * This is either because:\n     *\n     * \u003cul\u003e\n     *   \u003cli\u003eThe method name matches the {@link #ignoreMethodNames} regex, if set.\u003c/li\u003e\n     *   \u003cli\u003eThe method's line length is less that or equal to the {@link #minLineCount}\u003c/li\u003e\n     * \u003c/ul\u003e\n     *\n     * @param ast the AST to check\n     * @return true is the ast node should be ignored\n     */"
			},
			{
				"signature": "private boolean isVariableInConstructorBody(DetailAST ast, String name)",
				"documentation": ""
			},
			{
				"signature": "private boolean isVariableInIgnoredConstructor(DetailAST ast, String name)",
				"documentation": ""
			},
			{
				"signature": "public void setIgnoreFormat(Pattern pattern)",
				"documentation": "/**\n     * Setter to define the RegExp for names of variables and parameters to ignore.\n     *\n     * @param pattern a pattern.\n     */"
			},
			{
				"signature": "public void setIgnoreSetter(boolean ignoreSetter)",
				"documentation": "/**\n     * Setter to allow to ignore the parameter of a property setter method.\n     *\n     * @param ignoreSetter decide whether to ignore the parameter of\n     *     a property setter method.\n     */"
			},
			{
				"signature": "public void setSetterCanReturnItsClass(boolean aSetterCanReturnItsClass)",
				"documentation": "/**\n     * Setter to allow to expand the definition of a setter method to include methods\n     * that return the class' instance.\n     *\n     * @param aSetterCanReturnItsClass if true then setter can return\n     *        either void or class in which it is declared. If false then\n     *        in order to be recognized as setter method (otherwise\n     *        already recognized as a setter) must return void.  Later is\n     *        the default behavior.\n     */"
			},
			{
				"signature": "public void setIgnoreConstructorParameter(boolean ignoreConstructorParameter)",
				"documentation": "/**\n     * Setter to control whether to ignore constructor parameters.\n     *\n     * @param ignoreConstructorParameter decide whether to ignore\n     *     constructor parameters.\n     */"
			},
			{
				"signature": "public void setIgnoreAbstractMethods(boolean ignoreAbstractMethods)",
				"documentation": "/**\n     * Setter to control whether to ignore parameters of abstract methods.\n     *\n     * @param ignoreAbstractMethods decide whether to ignore\n     *     parameters of abstract methods.\n     */"
			},
			{
				"signature": "public void setIgnoreMethodNames(String ignoreMethodNames)",
				"documentation": ""
			},
			{
				"signature": "public void setIgnoreConstructorBody(boolean ignoreConstructorBody)",
				"documentation": ""
			},
			{
				"signature": "public void setIgnoreConstructorMethods(String ignoreConstructorMethods)",
				"documentation": ""
			},
			{
				"signature": "public void setMinLineCount(int minLineCount)",
				"documentation": ""
			},
			{
				"signature": "private static int getMethodsNumberOfLine(DetailAST methodDef)",
				"documentation": ""
			}
		],
		"interfaces": []
	},
	{
		"documentation": "/**\n     * Holds the names of static and instance fields of a type.\n     */",
		"name": "org.elasticsearch.gradle.internal.checkstyle.HiddenFieldCheck.FieldFrame",
		"extends": "",
		"Methods": [
			{
				"signature": "FieldFrame(FieldFrame parent, boolean staticType, String frameName)",
				"documentation": ""
			},
			{
				"signature": "public void addInstanceField(String field)",
				"documentation": "/**\n         * Adds an instance field to this FieldFrame.\n         *\n         * @param field  the name of the instance field.\n         */"
			},
			{
				"signature": "public void addStaticField(String field)",
				"documentation": "/**\n         * Adds a static field to this FieldFrame.\n         *\n         * @param field  the name of the instance field.\n         */"
			},
			{
				"signature": "public boolean containsInstanceField(String field)",
				"documentation": "/**\n         * Determines whether this FieldFrame contains an instance field.\n         *\n         * @param field the field to check.\n         * @return true if this FieldFrame contains instance field field.\n         */"
			},
			{
				"signature": "public boolean containsStaticField(String field)",
				"documentation": "/**\n         * Determines whether this FieldFrame contains a static field.\n         *\n         * @param field the field to check.\n         * @return true if this FieldFrame contains static field field.\n         */"
			},
			{
				"signature": "public FieldFrame getParent()",
				"documentation": "/**\n         * Getter for parent frame.\n         *\n         * @return parent frame.\n         */"
			},
			{
				"signature": "private boolean isEmbeddedIn(String classOrEnumName)",
				"documentation": "/**\n         * Check if current frame is embedded in class or enum with\n         * specific name.\n         *\n         * @param classOrEnumName name of class or enum that we are looking\n         *     for in the chain of field frames.\n         *\n         * @return true if current frame is embedded in class or enum\n         *     with name classOrNameName\n         */"
			}
		],
		"interfaces": []
	},
	{
		"documentation": "/**\n * This is a copy of Checkstyle's {@link com.puppycrawl.tools.checkstyle.checks.javadoc.MissingJavadocTypeCheck},\n * modified to accept a regex to exclude classes by name. See the original class for full documentation.\n */",
		"name": "org.elasticsearch.gradle.internal.checkstyle.MissingJavadocTypeCheck",
		"extends": "com.puppycrawl.tools.checkstyle.api.AbstractCheck",
		"Methods": [
			{
				"signature": "public void setScope(Scope scope)",
				"documentation": "/**\n     * Setter to specify the visibility scope where Javadoc comments are checked.\n     *\n     * @param scope a scope.\n     */"
			},
			{
				"signature": "public void setExcludeScope(Scope excludeScope)",
				"documentation": "/**\n     * Setter to specify the visibility scope where Javadoc comments are not checked.\n     *\n     * @param excludeScope a scope.\n     */"
			},
			{
				"signature": "public void setSkipAnnotations(String... userAnnotations)",
				"documentation": "/**\n     * Setter to specify the list of annotations that allow missed documentation.\n     * Only short names are allowed, e.g. {@code Generated}.\n     *\n     * @param userAnnotations user's value.\n     */"
			},
			{
				"signature": "public final void setIgnorePattern(Pattern pattern)",
				"documentation": "/**\n     * Setter to specify pattern for types to ignore.\n     *\n     * @param pattern a pattern.\n     */"
			},
			{
				"signature": "public int[] getDefaultTokens()",
				"documentation": ""
			},
			{
				"signature": "public int[] getAcceptableTokens()",
				"documentation": ""
			},
			{
				"signature": "public int[] getRequiredTokens()",
				"documentation": ""
			},
			{
				"signature": "public void visitToken(DetailAST ast)",
				"documentation": ""
			},
			{
				"signature": "private boolean shouldCheck(final DetailAST ast)",
				"documentation": "/**\n     * Whether we should check this node.\n     *\n     * @param ast a given node.\n     * @return whether we should check a given node.\n     */"
			}
		],
		"interfaces": []
	},
	{
		"documentation": "/**\n * Checks the snippets included in the docs aren't too wide to fit on\n * the page.\n * \u003cp\u003e\n * Regions contained in the special \u003ccode\u003enoformat\u003c/code\u003e tag are exempt from the length\n * check. This region is also exempt from automatic formatting.\n */",
		"name": "org.elasticsearch.gradle.internal.checkstyle.SnippetLengthCheck",
		"extends": "com.puppycrawl.tools.checkstyle.api.AbstractFileSetCheck",
		"Methods": [
			{
				"signature": "public void setMax(int max)",
				"documentation": "/**\n     * The maximum width that a snippet may have.\n     */"
			},
			{
				"signature": "protected void processFiltered(File file, FileText fileText) throws CheckstyleException",
				"documentation": ""
			},
			{
				"signature": "static void checkFile(BiConsumer\u003cInteger, String\u003e log, int max, String... lineArray)",
				"documentation": ""
			},
			{
				"signature": "private static void checkSnippet(BiConsumer\u003cInteger, String\u003e log, int max, LineItr lines, String leadingSpaces, String name)",
				"documentation": ""
			}
		],
		"interfaces": []
	},
	{
		"documentation": "",
		"name": "org.elasticsearch.gradle.internal.checkstyle.SnippetLengthCheck.LineItr",
		"extends": "",
		"Methods": [
			{
				"signature": "LineItr(Iterator\u003cString\u003e delegate)",
				"documentation": ""
			},
			{
				"signature": "public boolean hasNext()",
				"documentation": ""
			},
			{
				"signature": "public String next()",
				"documentation": ""
			}
		],
		"interfaces": [
			"java.util.Iterator"
		]
	},
	{
		"documentation": "/**\n * Checks for calls to {@link String#formatted(Object...)} that include format specifiers that\n * are not locale-safe. This method always uses the default {@link Locale}, and so for our\n * purposes it is safer to use {@link String#format(Locale, String, Object...)}.\n * \u003cp\u003e\n * Note that this rule can currently only detect violations when calling \u003ccode\u003eformatted()\u003c/code\u003e\n * on a string literal or text block. In theory, it could be extended to detect violations in\n * local variables or statics.\n */",
		"name": "org.elasticsearch.gradle.internal.checkstyle.StringFormattingCheck",
		"extends": "com.puppycrawl.tools.checkstyle.api.AbstractCheck",
		"Methods": [
			{
				"signature": "public int[] getDefaultTokens()",
				"documentation": "/**\n * Checks for calls to {@link String#formatted(Object...)} that include format specifiers that\n * are not locale-safe. This method always uses the default {@link Locale}, and so for our\n * purposes it is safer to use {@link String#format(Locale, String, Object...)}.\n * \u003cp\u003e\n * Note that this rule can currently only detect violations when calling \u003ccode\u003eformatted()\u003c/code\u003e\n * on a string literal or text block. In theory, it could be extended to detect violations in\n * local variables or statics.\n */"
			},
			{
				"signature": "public int[] getAcceptableTokens()",
				"documentation": ""
			},
			{
				"signature": "public int[] getRequiredTokens()",
				"documentation": ""
			},
			{
				"signature": "public void visitToken(DetailAST ast)",
				"documentation": ""
			},
			{
				"signature": "private void checkFormattedMethod(DetailAST ast)",
				"documentation": ""
			}
		],
		"interfaces": []
	},
	{
		"documentation": "",
		"name": "org.elasticsearch.gradle.internal.conventions.BuildToolsConventionsPlugin",
		"extends": "",
		"Methods": [
			{
				"signature": "public void apply(Project project)",
				"documentation": ""
			}
		],
		"interfaces": [
			"org.gradle.api.Plugin"
		]
	},
	{
		"documentation": "",
		"name": "org.elasticsearch.gradle.internal.conventions.EclipseConventionPlugin",
		"extends": "",
		"Methods": [
			{
				"signature": "public void apply(Project project)",
				"documentation": ""
			},
			{
				"signature": "public String transform(String s)",
				"documentation": ""
			},
			{
				"signature": "public void execute(Delete delete)",
				"documentation": ""
			},
			{
				"signature": "private File root(Project project)",
				"documentation": ""
			}
		],
		"interfaces": [
			"org.gradle.api.Plugin"
		]
	},
	{
		"documentation": "",
		"name": "org.elasticsearch.gradle.internal.conventions.GUtils",
		"extends": "",
		"Methods": [
			{
				"signature": "public static String capitalize(String s)",
				"documentation": ""
			}
		],
		"interfaces": []
	},
	{
		"documentation": "",
		"name": "org.elasticsearch.gradle.internal.conventions.GitInfoPlugin",
		"extends": "",
		"Methods": [
			{
				"signature": "GitInfoPlugin(ProviderFactory factory, ObjectFactory objectFactory)",
				"documentation": ""
			},
			{
				"signature": "public void apply(Project project)",
				"documentation": ""
			},
			{
				"signature": "public Property\u003cGitInfo\u003e getGitInfo()",
				"documentation": ""
			},
			{
				"signature": "public Provider\u003cString\u003e getRevision()",
				"documentation": ""
			}
		],
		"interfaces": [
			"org.gradle.api.Plugin"
		]
	},
	{
		"documentation": "",
		"name": "org.elasticsearch.gradle.internal.conventions.LicensingPlugin",
		"extends": "",
		"Methods": [
			{
				"signature": "public LicensingPlugin(ProviderFactory providerFactory)",
				"documentation": ""
			},
			{
				"signature": "public void apply(Project project)",
				"documentation": ""
			},
			{
				"signature": "private boolean isSnapshotVersion(Project project)",
				"documentation": ""
			}
		],
		"interfaces": [
			"org.gradle.api.Plugin"
		]
	},
	{
		"documentation": "",
		"name": "org.elasticsearch.gradle.internal.conventions.PublishPlugin",
		"extends": "",
		"Methods": [
			{
				"signature": "public PublishPlugin(ProjectLayout projectLayout, BuildLayout buildLayout, ProviderFactory providerFactory)",
				"documentation": ""
			},
			{
				"signature": "public void apply(Project project)",
				"documentation": ""
			},
			{
				"signature": "private void configurePublications(Project project)",
				"documentation": ""
			},
			{
				"signature": "private static String getArchivesBaseName(ExtensionContainer extensions)",
				"documentation": ""
			},
			{
				"signature": "private void configurePomGeneration(Project project)",
				"documentation": "/**\n     * Configuration generation of maven poms.\n     */"
			},
			{
				"signature": "private void addNameAndDescriptiontoPom(Project project, NamedDomainObjectSet\u003cMavenPublication\u003e mavenPublications)",
				"documentation": ""
			},
			{
				"signature": "private static void configureWithShadowPlugin(Project project, MavenPublication publication)",
				"documentation": ""
			},
			{
				"signature": "private static void addScmInfo(XmlProvider xml, GitInfo gitInfo)",
				"documentation": ""
			},
			{
				"signature": "private static void configureJavadocJar(Project project)",
				"documentation": "/**\n     * Adds a javadocJar task to generate a jar containing javadocs.\n     */"
			},
			{
				"signature": "static void configureSourcesJar(Project project)",
				"documentation": ""
			}
		],
		"interfaces": [
			"org.gradle.api.Plugin"
		]
	},
	{
		"documentation": "",
		"name": "org.elasticsearch.gradle.internal.conventions.VersionPropertiesBuildService",
		"extends": "",
		"Methods": [
			{
				"signature": "public VersionPropertiesBuildService(ProviderFactory providerFactory)",
				"documentation": ""
			},
			{
				"signature": "private JavaVersion resolveMinimumRuntimeJavaVersion(File infoPath)",
				"documentation": ""
			},
			{
				"signature": "private JavaVersion resolveMinimumCompilerJavaVersion(File infoPath)",
				"documentation": ""
			},
			{
				"signature": "private JavaVersion resolveJavaVersion(File infoPath, String path)",
				"documentation": ""
			},
			{
				"signature": "public Properties getProperties()",
				"documentation": ""
			},
			{
				"signature": "public void close() throws Exception",
				"documentation": ""
			}
		],
		"interfaces": [
			"org.gradle.api.services.BuildService",
			"AutoCloseable"
		]
	},
	{
		"documentation": "",
		"name": "org.elasticsearch.gradle.internal.conventions.VersionPropertiesLoader",
		"extends": "",
		"Methods": [
			{
				"signature": "static Properties loadBuildSrcVersion(File input, ProviderFactory providerFactory) throws IOException",
				"documentation": ""
			},
			{
				"signature": "protected static void loadBuildSrcVersion(Properties loadedProps, ProviderFactory providers)",
				"documentation": ""
			}
		],
		"interfaces": []
	},
	{
		"documentation": "",
		"name": "org.elasticsearch.gradle.internal.conventions.VersionPropertiesPlugin",
		"extends": "",
		"Methods": [
			{
				"signature": "public void apply(Project project)",
				"documentation": ""
			}
		],
		"interfaces": [
			"org.gradle.api.Plugin"
		]
	},
	{
		"documentation": "",
		"name": "org.elasticsearch.gradle.internal.conventions.info.GitInfo",
		"extends": "",
		"Methods": [
			{
				"signature": "private GitInfo(String revision, String origin)",
				"documentation": ""
			},
			{
				"signature": "public String getRevision()",
				"documentation": ""
			},
			{
				"signature": "public String getOrigin()",
				"documentation": ""
			},
			{
				"signature": "public static GitInfo gitInfo(File rootDir)",
				"documentation": ""
			},
			{
				"signature": "private static String findOriginUrl(final Path configFile) throws IOException",
				"documentation": ""
			},
			{
				"signature": "private static String readFirstLine(final Path path) throws IOException",
				"documentation": ""
			},
			{
				"signature": "public String urlFromOrigin()",
				"documentation": "/** Find the reponame. */"
			}
		],
		"interfaces": []
	},
	{
		"documentation": "",
		"name": "org.elasticsearch.gradle.internal.conventions.info.ParallelDetector",
		"extends": "",
		"Methods": [
			{
				"signature": "public static int findDefaultParallel(Project project)",
				"documentation": ""
			},
			{
				"signature": "private static boolean isMac(ProviderFactory providers)",
				"documentation": ""
			}
		],
		"interfaces": []
	},
	{
		"documentation": "/**\n * This plugin configures formatting for Java source using Spotless\n * for Gradle. Since the act of formatting existing source can interfere\n * with developers' workflows, we don't automatically format all code\n * (yet). Instead, we maintain a list of projects that are excluded from\n * formatting, until we reach a point where we can comfortably format them\n * in one go without too much disruption.\n *\n * \u003cp\u003eAny new sub-projects must not be added to the exclusions list!\n *\n * \u003cp\u003eTo perform a reformat, run:\n *\n * \u003cpre\u003e    ./gradlew spotlessApply\u003c/pre\u003e\n *\n * \u003cp\u003eTo check the current format, run:\n *\n * \u003cpre\u003e    ./gradlew spotlessJavaCheck\u003c/pre\u003e\n *\n * \u003cp\u003eThis is also carried out by the `precommit` task.\n *\n * \u003cp\u003eSee also the \u003ca href=\"https://github.com/diffplug/spotless/tree/master/plugin-gradle\"\n * \u003eSpotless project page\u003c/a\u003e.\n */",
		"name": "org.elasticsearch.gradle.internal.conventions.precommit.FormattingPrecommitPlugin",
		"extends": "",
		"Methods": [
			{
				"signature": "public void apply(Project project)",
				"documentation": "/**\n * This plugin configures formatting for Java source using Spotless\n * for Gradle. Since the act of formatting existing source can interfere\n * with developers' workflows, we don't automatically format all code\n * (yet). Instead, we maintain a list of projects that are excluded from\n * formatting, until we reach a point where we can comfortably format them\n * in one go without too much disruption.\n *\n * \u003cp\u003eAny new sub-projects must not be added to the exclusions list!\n *\n * \u003cp\u003eTo perform a reformat, run:\n *\n * \u003cpre\u003e    ./gradlew spotlessApply\u003c/pre\u003e\n *\n * \u003cp\u003eTo check the current format, run:\n *\n * \u003cpre\u003e    ./gradlew spotlessJavaCheck\u003c/pre\u003e\n *\n * \u003cp\u003eThis is also carried out by the `precommit` task.\n *\n * \u003cp\u003eSee also the \u003ca href=\"https://github.com/diffplug/spotless/tree/master/plugin-gradle\"\n * \u003eSpotless project page\u003c/a\u003e.\n */"
			}
		],
		"interfaces": [
			"org.gradle.api.Plugin"
		]
	},
	{
		"documentation": "",
		"name": "org.elasticsearch.gradle.internal.conventions.precommit.LicenseHeadersPrecommitPlugin",
		"extends": "PrecommitPlugin",
		"Methods": [
			{
				"signature": "public LicenseHeadersPrecommitPlugin(ProviderFactory providerFactory)",
				"documentation": ""
			},
			{
				"signature": "public TaskProvider\u003c? extends Task\u003e createTask(Project project)",
				"documentation": ""
			}
		],
		"interfaces": []
	},
	{
		"documentation": "/**\n * Checks files for license headers..\n */",
		"name": "org.elasticsearch.gradle.internal.conventions.precommit.LicenseHeadersTask",
		"extends": "org.gradle.api.DefaultTask",
		"Methods": [
			{
				"signature": "public LicenseHeadersTask(ObjectFactory objectFactory, ProjectLayout projectLayout)",
				"documentation": "/**\n     * Files that should be excluded from the license header check. Use with extreme care, only in situations where the license on the\n     * source file is compatible with the codebase but we do not want to add the license to the list of approved headers (to avoid the\n     * possibility of inadvertently using the license on our own source files).\n     */"
			},
			{
				"signature": "public List\u003cFileCollection\u003e getJavaFiles()",
				"documentation": "/**\n     * The list of java files to check. protected so the afterEvaluate closure in the\n     * constructor can write to it.\n     */"
			},
			{
				"signature": "public RegularFileProperty getReportFile()",
				"documentation": ""
			},
			{
				"signature": "public List\u003cString\u003e getApprovedLicenses()",
				"documentation": ""
			},
			{
				"signature": "public void setApprovedLicenses(List\u003cString\u003e approvedLicenses)",
				"documentation": ""
			},
			{
				"signature": "public List\u003cString\u003e getExcludes()",
				"documentation": ""
			},
			{
				"signature": "public void setExcludes(List\u003cString\u003e excludes)",
				"documentation": ""
			},
			{
				"signature": "public ListProperty\u003cLicense\u003e getAdditionalLicenses()",
				"documentation": "/**\n     * Additional license families that may be found. The key is the license category name (5 characters),\n     * followed by the family name and the value list of patterns to search for.\n     */"
			},
			{
				"signature": "public void additionalLicense(final String categoryName, String familyName, String pattern)",
				"documentation": "/**\n     * Add a new license type.\n     * \u003cp\u003e\n     * The license may be added to the {@link #approvedLicenses} using the {@code familyName}.\n     *\n     * @param categoryName A 5-character string identifier for the license\n     * @param familyName   An expanded string name for the license\n     * @param pattern      A pattern to search for, which if found, indicates a file contains the license\n     */"
			},
			{
				"signature": "public void runRat()",
				"documentation": ""
			},
			{
				"signature": "private IHeaderMatcher subStringMatcher(String licenseFamilyCategory, String licenseFamilyName, String substringPattern)",
				"documentation": ""
			},
			{
				"signature": "private ClaimStatistic generateReport(ReportConfiguration config, File xmlReportFile)",
				"documentation": ""
			},
			{
				"signature": "private ClaimStatistic toXmlReportFile(ReportConfiguration config, Writer writer) throws RatException, IOException",
				"documentation": ""
			},
			{
				"signature": "private static List\u003cString\u003e unapprovedFiles(File xmlReportFile)",
				"documentation": ""
			},
			{
				"signature": "private static List\u003cElement\u003e elementList(NodeList resourcesNodes)",
				"documentation": ""
			}
		],
		"interfaces": []
	},
	{
		"documentation": "",
		"name": "org.elasticsearch.gradle.internal.conventions.precommit.LicenseHeadersTask.License",
		"extends": "",
		"Methods": [
			{
				"signature": "public License(String licenseFamilyCategory, String licenseFamilyName, String substringPattern)",
				"documentation": ""
			}
		],
		"interfaces": [
			"java.io.Serializable"
		]
	},
	{
		"documentation": "/**\n * Adds pom validation to every pom generation task.\n */",
		"name": "org.elasticsearch.gradle.internal.conventions.precommit.PomValidationPrecommitPlugin",
		"extends": "PrecommitPlugin",
		"Methods": [
			{
				"signature": "public TaskProvider\u003c? extends Task\u003e createTask(Project project)",
				"documentation": "/**\n * Adds pom validation to every pom generation task.\n */"
			}
		],
		"interfaces": []
	},
	{
		"documentation": "",
		"name": "org.elasticsearch.gradle.internal.conventions.precommit.PomValidationTask",
		"extends": "org.elasticsearch.gradle.internal.conventions.precommit.PrecommitTask",
		"Methods": [
			{
				"signature": "public PomValidationTask(ObjectFactory objects)",
				"documentation": ""
			},
			{
				"signature": "public RegularFileProperty getPomFile()",
				"documentation": ""
			},
			{
				"signature": "public void checkPom() throws Exception",
				"documentation": ""
			},
			{
				"signature": "private void logError(String element, String message)",
				"documentation": ""
			},
			{
				"signature": "private \u003cT\u003e void validateNonEmpty(String element, T value, Predicate\u003cT\u003e isEmpty)",
				"documentation": ""
			},
			{
				"signature": "private \u003cT\u003e void validateNonNull(String element, T value, Runnable validator)",
				"documentation": ""
			},
			{
				"signature": "private void validateString(String element, String value)",
				"documentation": ""
			},
			{
				"signature": "private \u003cT\u003e void validateCollection(String element, Collection\u003cT\u003e value, Consumer\u003cT\u003e validator)",
				"documentation": ""
			}
		],
		"interfaces": []
	},
	{
		"documentation": "/**\n * Base plugin for adding a precommit task.\n */",
		"name": "org.elasticsearch.gradle.internal.conventions.precommit.PrecommitPlugin",
		"extends": "",
		"Methods": [
			{
				"signature": "public final void apply(Project project)",
				"documentation": "/**\n * Base plugin for adding a precommit task.\n */"
			}
		],
		"interfaces": [
			"org.gradle.api.Plugin"
		]
	},
	{
		"documentation": "",
		"name": "org.elasticsearch.gradle.internal.conventions.precommit.PrecommitTask",
		"extends": "org.gradle.api.DefaultTask",
		"Methods": [
			{
				"signature": "public File getSuccessMarker()",
				"documentation": ""
			},
			{
				"signature": "public void writeMarker() throws IOException",
				"documentation": ""
			},
			{
				"signature": "protected ProjectLayout getProjectLayout()",
				"documentation": ""
			}
		],
		"interfaces": []
	},
	{
		"documentation": "",
		"name": "org.elasticsearch.gradle.internal.conventions.precommit.PrecommitTaskPlugin",
		"extends": "",
		"Methods": [
			{
				"signature": "public void apply(Project project)",
				"documentation": ""
			}
		],
		"interfaces": [
			"org.gradle.api.Plugin"
		]
	},
	{
		"documentation": "",
		"name": "org.elasticsearch.gradle.internal.conventions.util.Util",
		"extends": "",
		"Methods": [
			{
				"signature": "public static boolean getBooleanProperty(String property, boolean defaultValue)",
				"documentation": ""
			},
			{
				"signature": "public static FileTree getJavaMainSourceResources(Project project, Action\u003c? super PatternFilterable\u003e filter)",
				"documentation": "/**\n     * @param project The project to look for resources.\n     * @param filter  Optional filter function to filter the returned resources\n     * @return Returns the {@link FileTree} for main resources from Java projects. Returns null if no files exist.\n     */"
			},
			{
				"signature": "public static FileTree getJavaTestSourceResources(Project project, Action\u003c? super PatternFilterable\u003e filter)",
				"documentation": "/**\n     * @param project The project to look for resources.\n     * @param filter  Optional filter function to filter the returned resources\n     * @return Returns the {@link FileTree} for test resources from Java projects. Returns null if no files exist.\n     */"
			},
			{
				"signature": "public static FileTree getJavaTestAndMainSourceResources(Project project, Action\u003c? super PatternFilterable\u003e filter)",
				"documentation": "/**\n     * @param project The project to look for resources.\n     * @param filter  Optional filter function to filter the returned resources\n     * @return Returns the combined {@link FileTree} for test and main resources from Java projects. Returns null if no files exist.\n     */"
			},
			{
				"signature": "public static Optional\u003cSourceSet\u003e getJavaTestSourceSet(Project project)",
				"documentation": "/**\n     * @param project The project to look for test Java resources.\n     * @return An Optional that contains the Java test SourceSet if it exists.\n     */"
			},
			{
				"signature": "public static Optional\u003cSourceSet\u003e getJavaMainSourceSet(Project project)",
				"documentation": "/**\n     * @param project The project to look for main Java resources.\n     * @return An Optional that contains the Java main SourceSet if it exists.\n     */"
			},
			{
				"signature": "private static boolean isJavaExtensionAvailable(Project project)",
				"documentation": ""
			},
			{
				"signature": "public static Object toStringable(Supplier\u003cString\u003e getter)",
				"documentation": ""
			},
			{
				"signature": "public String toString()",
				"documentation": ""
			},
			{
				"signature": "public static SourceSetContainer getJavaSourceSets(Project project)",
				"documentation": ""
			}
		],
		"interfaces": []
	},
	{
		"documentation": "/**\n * A standalone process that will reap external services after a build dies.\n *\n * \u003ch2\u003eInput\u003c/h2\u003e\n * Since how to reap a given service is platform and service dependent, this tool\n * operates on system commands to execute. It takes a single argument, a directory\n * that will contain files with reaping commands. Each line in each file will be\n * executed with {@link Runtime#exec(String)}.\n *\n * The main method will wait indefinitely on the parent process (Gradle) by\n * reading from stdin. When Gradle shuts down, whether normally or abruptly, the\n * pipe will be broken and read will return.\n *\n * The reaper will then iterate over the files in the configured directory,\n * and execute the given commands. If any commands fail, a failure message is\n * written to stderr. Otherwise, the input file will be deleted. If no inputs\n * produced errors, the entire input directory is deleted upon completion of reaping.\n */",
		"name": "org.elasticsearch.gradle.reaper.Reaper",
		"extends": "",
		"Methods": [
			{
				"signature": "private Reaper(Path inputDir)",
				"documentation": "/**\n * A standalone process that will reap external services after a build dies.\n *\n * \u003ch2\u003eInput\u003c/h2\u003e\n * Since how to reap a given service is platform and service dependent, this tool\n * operates on system commands to execute. It takes a single argument, a directory\n * that will contain files with reaping commands. Each line in each file will be\n * executed with {@link Runtime#exec(String)}.\n *\n * The main method will wait indefinitely on the parent process (Gradle) by\n * reading from stdin. When Gradle shuts down, whether normally or abruptly, the\n * pipe will be broken and read will return.\n *\n * The reaper will then iterate over the files in the configured directory,\n * and execute the given commands. If any commands fail, a failure message is\n * written to stderr. Otherwise, the input file will be deleted. If no inputs\n * produced errors, the entire input directory is deleted upon completion of reaping.\n */"
			},
			{
				"signature": "public static void main(String[] args) throws Exception",
				"documentation": ""
			},
			{
				"signature": "private void reap()",
				"documentation": ""
			},
			{
				"signature": "private void logFailure(String message, Exception e)",
				"documentation": ""
			},
			{
				"signature": "private void delete(Path toDelete)",
				"documentation": ""
			},
			{
				"signature": "public void close()",
				"documentation": ""
			}
		],
		"interfaces": [
			"java.io.Closeable"
		]
	},
	{
		"documentation": "",
		"name": "org.elasticsearch.gradle.ReaperPluginIT",
		"extends": "org.elasticsearch.gradle.internal.test.GradleIntegrationTestCase",
		"Methods": [
			{
				"signature": "public String projectName()",
				"documentation": ""
			},
			{
				"signature": "public void testCanLaunchReaper()",
				"documentation": ""
			}
		],
		"interfaces": []
	},
	{
		"documentation": "",
		"name": "org.elasticsearch.gradle.AbstractLazyPropertyCollection",
		"extends": "",
		"Methods": [
			{
				"signature": "public AbstractLazyPropertyCollection(String name)",
				"documentation": ""
			},
			{
				"signature": "public AbstractLazyPropertyCollection(String name, Object owner)",
				"documentation": ""
			},
			{
				"signature": "void assertNotNull(Object value, String description)",
				"documentation": ""
			}
		],
		"interfaces": []
	},
	{
		"documentation": "",
		"name": "org.elasticsearch.gradle.Architecture",
		"extends": "",
		"Methods": [
			{
				"signature": "Architecture(String classifier)",
				"documentation": ""
			},
			{
				"signature": "public static Architecture current()",
				"documentation": ""
			}
		],
		"interfaces": []
	},
	{
		"documentation": "",
		"name": "org.elasticsearch.gradle.DistributionDependency.StringBasedDistributionDependency",
		"extends": "",
		"Methods": [
			{
				"signature": "public StringBasedDistributionDependency(String notation)",
				"documentation": ""
			},
			{
				"signature": "public Object getDefaultNotation()",
				"documentation": ""
			},
			{
				"signature": "public Object getExtractedNotation()",
				"documentation": ""
			}
		],
		"interfaces": [
			"DistributionDependency"
		]
	},
	{
		"documentation": "/**\n * A plugin to manage getting and extracting distributions of Elasticsearch.\n * \u003cp\u003e\n * The plugin provides hooks to register custom distribution resolutions.\n * This plugin resolves distributions from the Elastic downloads service if\n * no registered resolution strategy can resolve to a distribution.\n */",
		"name": "org.elasticsearch.gradle.DistributionDownloadPlugin",
		"extends": "",
		"Methods": [
			{
				"signature": "public DistributionDownloadPlugin(ObjectFactory objectFactory)",
				"documentation": "/**\n * A plugin to manage getting and extracting distributions of Elasticsearch.\n * \u003cp\u003e\n * The plugin provides hooks to register custom distribution resolutions.\n * This plugin resolves distributions from the Elastic downloads service if\n * no registered resolution strategy can resolve to a distribution.\n */"
			},
			{
				"signature": "public void setDockerAvailability(Provider\u003cBoolean\u003e dockerAvailability)",
				"documentation": ""
			},
			{
				"signature": "public void apply(Project project)",
				"documentation": ""
			},
			{
				"signature": "private void setupDistributionContainer(Project project, Property\u003cBoolean\u003e dockerAvailable)",
				"documentation": ""
			},
			{
				"signature": "private void setupResolutionsContainer(Project project)",
				"documentation": ""
			},
			{
				"signature": "public static NamedDomainObjectContainer\u003cElasticsearchDistribution\u003e getContainer(Project project)",
				"documentation": ""
			},
			{
				"signature": "public static NamedDomainObjectContainer\u003cDistributionResolution\u003e getRegistrationsContainer(Project project)",
				"documentation": ""
			},
			{
				"signature": "private void finalizeDistributionDependencies(Project project, ElasticsearchDistribution distribution)",
				"documentation": ""
			},
			{
				"signature": "private DistributionDependency resolveDependencyNotation(Project p, ElasticsearchDistribution distribution)",
				"documentation": ""
			},
			{
				"signature": "private static void addIvyRepo(Project project, String name, String url, String group)",
				"documentation": ""
			},
			{
				"signature": "private static void setupDownloadServiceRepo(Project project)",
				"documentation": ""
			},
			{
				"signature": "private String dependencyNotation(ElasticsearchDistribution distribution)",
				"documentation": "/**\n     * Returns a dependency object representing the given distribution.\n     * \u003cp\u003e\n     * The returned object is suitable to be passed to {@link DependencyHandler}.\n     * The concrete type of the object will be a set of maven coordinates as a {@link String}.\n     * Maven coordinates point to either the integ-test-zip coordinates on maven central, or a set of artificial\n     * coordinates that resolve to the Elastic download service through an ivy repository.\n     */"
			}
		],
		"interfaces": [
			"org.gradle.api.Plugin"
		]
	},
	{
		"documentation": "",
		"name": "org.elasticsearch.gradle.DistributionResolution",
		"extends": "",
		"Methods": [
			{
				"signature": "public DistributionResolution(String name)",
				"documentation": ""
			},
			{
				"signature": "public String getName()",
				"documentation": ""
			},
			{
				"signature": "public Resolver getResolver()",
				"documentation": ""
			},
			{
				"signature": "public void setResolver(Resolver resolver)",
				"documentation": ""
			},
			{
				"signature": "public void setPriority(int priority)",
				"documentation": ""
			},
			{
				"signature": "public int getPriority()",
				"documentation": ""
			}
		],
		"interfaces": []
	},
	{
		"documentation": "",
		"name": "org.elasticsearch.gradle.ElasticsearchDistribution",
		"extends": "",
		"Methods": [
			{
				"signature": "ElasticsearchDistribution(        String name,        ObjectFactory objectFactory,        Property\u003cBoolean\u003e dockerAvailability,        Configuration fileConfiguration,        Configuration extractedConfiguration,        Action\u003cElasticsearchDistribution\u003e distributionFinalizer    )",
				"documentation": ""
			},
			{
				"signature": "public String getName()",
				"documentation": ""
			},
			{
				"signature": "public String getVersion()",
				"documentation": ""
			},
			{
				"signature": "public void setVersion(String version)",
				"documentation": ""
			},
			{
				"signature": "public Platform getPlatform()",
				"documentation": ""
			},
			{
				"signature": "public void setPlatform(Platform platform)",
				"documentation": ""
			},
			{
				"signature": "public ElasticsearchDistributionType getType()",
				"documentation": ""
			},
			{
				"signature": "public void setType(ElasticsearchDistributionType type)",
				"documentation": ""
			},
			{
				"signature": "public void setType(String type)",
				"documentation": "/**\n     * For simplicity only public distribution types are supported here\n     * */"
			},
			{
				"signature": "public boolean getBundledJdk()",
				"documentation": ""
			},
			{
				"signature": "public boolean isDocker()",
				"documentation": ""
			},
			{
				"signature": "public void setBundledJdk(Boolean bundledJdk)",
				"documentation": ""
			},
			{
				"signature": "public boolean getFailIfUnavailable()",
				"documentation": ""
			},
			{
				"signature": "public void setFailIfUnavailable(boolean failIfUnavailable)",
				"documentation": ""
			},
			{
				"signature": "public void setArchitecture(Architecture architecture)",
				"documentation": ""
			},
			{
				"signature": "public Architecture getArchitecture()",
				"documentation": ""
			},
			{
				"signature": "public String toString()",
				"documentation": ""
			},
			{
				"signature": "public ElasticsearchDistribution maybeFreeze()",
				"documentation": "/**\n     * if not executed before, this\n     * freezes the distribution configuration and\n     * runs distribution finalizer logic.\n     */"
			},
			{
				"signature": "public String getFilepath()",
				"documentation": ""
			},
			{
				"signature": "public Configuration getExtracted()",
				"documentation": ""
			},
			{
				"signature": "public TaskDependency getBuildDependencies()",
				"documentation": ""
			},
			{
				"signature": "private boolean skippingDockerDistributionBuild()",
				"documentation": ""
			},
			{
				"signature": "public Iterator\u003cFile\u003e iterator()",
				"documentation": ""
			},
			{
				"signature": "void finalizeValues()",
				"documentation": ""
			},
			{
				"signature": "public TaskDependency getArchiveDependencies()",
				"documentation": ""
			}
		],
		"interfaces": [
			"org.gradle.api.Buildable",
			"Iterable"
		]
	},
	{
		"documentation": "",
		"name": "org.elasticsearch.gradle.public",
		"extends": "",
		"Methods": [
			{
				"signature": "public String toString()",
				"documentation": ""
			}
		],
		"interfaces": []
	},
	{
		"documentation": "/**\n * An outputstream to a File that is lazily opened on the first write.\n */",
		"name": "org.elasticsearch.gradle.LazyFileOutputStream",
		"extends": "java.io.OutputStream",
		"Methods": [
			{
				"signature": "LazyFileOutputStream(File file)",
				"documentation": "/**\n * An outputstream to a File that is lazily opened on the first write.\n */"
			},
			{
				"signature": "private void bootstrap() throws IOException",
				"documentation": "/**\n * An outputstream to a File that is lazily opened on the first write.\n */"
			},
			{
				"signature": "public void write(int b) throws IOException",
				"documentation": ""
			},
			{
				"signature": "public void write(byte b[], int off, int len) throws IOException",
				"documentation": ""
			},
			{
				"signature": "public void write(int b) throws IOException",
				"documentation": ""
			},
			{
				"signature": "public void write(byte b[], int off, int len) throws IOException",
				"documentation": ""
			},
			{
				"signature": "public void close() throws IOException",
				"documentation": ""
			}
		],
		"interfaces": []
	},
	{
		"documentation": "",
		"name": "org.elasticsearch.gradle.LazyPropertyList",
		"extends": "AbstractLazyPropertyCollection",
		"Methods": [
			{
				"signature": "public LazyPropertyList(String name)",
				"documentation": ""
			},
			{
				"signature": "public LazyPropertyList(String name, Object owner)",
				"documentation": ""
			},
			{
				"signature": "public int size()",
				"documentation": ""
			},
			{
				"signature": "public boolean isEmpty()",
				"documentation": ""
			},
			{
				"signature": "public boolean contains(Object o)",
				"documentation": ""
			},
			{
				"signature": "public Iterator\u003cT\u003e iterator()",
				"documentation": ""
			},
			{
				"signature": "public Object[] toArray()",
				"documentation": ""
			},
			{
				"signature": "public \u003cT1\u003e T1[] toArray(T1[] a)",
				"documentation": ""
			},
			{
				"signature": "public boolean add(T t)",
				"documentation": ""
			},
			{
				"signature": "public boolean add(Supplier\u003cT\u003e supplier)",
				"documentation": ""
			},
			{
				"signature": "public boolean add(Supplier\u003cT\u003e supplier, PropertyNormalization normalization)",
				"documentation": ""
			},
			{
				"signature": "public boolean remove(Object o)",
				"documentation": ""
			},
			{
				"signature": "public boolean containsAll(Collection\u003c?\u003e c)",
				"documentation": ""
			},
			{
				"signature": "public boolean addAll(Collection\u003c? extends T\u003e c)",
				"documentation": ""
			},
			{
				"signature": "public boolean addAll(int index, Collection\u003c? extends T\u003e c)",
				"documentation": ""
			},
			{
				"signature": "public boolean removeAll(Collection\u003c?\u003e c)",
				"documentation": ""
			},
			{
				"signature": "public boolean retainAll(Collection\u003c?\u003e c)",
				"documentation": ""
			},
			{
				"signature": "public void clear()",
				"documentation": ""
			},
			{
				"signature": "public T get(int index)",
				"documentation": ""
			},
			{
				"signature": "public T set(int index, T element)",
				"documentation": ""
			},
			{
				"signature": "public void add(int index, T element)",
				"documentation": ""
			},
			{
				"signature": "public T remove(int index)",
				"documentation": ""
			},
			{
				"signature": "public int indexOf(Object o)",
				"documentation": ""
			},
			{
				"signature": "public int lastIndexOf(Object o)",
				"documentation": ""
			},
			{
				"signature": "public ListIterator\u003cT\u003e listIterator()",
				"documentation": ""
			},
			{
				"signature": "public ListIterator\u003cT\u003e listIterator(int index)",
				"documentation": ""
			},
			{
				"signature": "public List\u003cT\u003e subList(int fromIndex, int toIndex)",
				"documentation": ""
			},
			{
				"signature": "public List\u003c? extends PropertyListEntry\u003cT\u003e\u003e getNormalizedCollection()",
				"documentation": ""
			},
			{
				"signature": "public List\u003c? extends T\u003e getFlatNormalizedCollection()",
				"documentation": "/**\n     * Return a \"flattened\" collection. This should be used when the collection type is itself a complex type with properties\n     * annotated as Gradle inputs rather than a simple type like {@link String}.\n     *\n     * @return a flattened collection filtered according to normalization strategy\n     */"
			},
			{
				"signature": "private void validate(PropertyListEntry\u003cT\u003e entry)",
				"documentation": ""
			}
		],
		"interfaces": [
			"java.util.List"
		]
	},
	{
		"documentation": "",
		"name": "org.elasticsearch.gradle.PropertyListEntry",
		"extends": "",
		"Methods": [
			{
				"signature": "PropertyListEntry(Supplier\u003cT\u003e supplier, PropertyNormalization normalization)",
				"documentation": ""
			},
			{
				"signature": "public PropertyNormalization getNormalization()",
				"documentation": ""
			},
			{
				"signature": "public T getValue()",
				"documentation": ""
			}
		],
		"interfaces": []
	},
	{
		"documentation": "",
		"name": "org.elasticsearch.gradle.LazyPropertyMap",
		"extends": "AbstractLazyPropertyCollection",
		"Methods": [
			{
				"signature": "public LazyPropertyMap(String name)",
				"documentation": ""
			},
			{
				"signature": "public LazyPropertyMap(String name, Object owner)",
				"documentation": ""
			},
			{
				"signature": "public LazyPropertyMap(String name, Object owner, BiFunction\u003cK, V, ?\u003e normalizationMapper)",
				"documentation": ""
			},
			{
				"signature": "public int size()",
				"documentation": ""
			},
			{
				"signature": "public boolean isEmpty()",
				"documentation": ""
			},
			{
				"signature": "public boolean containsKey(Object key)",
				"documentation": ""
			},
			{
				"signature": "public boolean containsValue(Object value)",
				"documentation": ""
			},
			{
				"signature": "public V get(Object key)",
				"documentation": ""
			},
			{
				"signature": "public V put(K key, V value)",
				"documentation": ""
			},
			{
				"signature": "public V put(K key, V value, PropertyNormalization normalization)",
				"documentation": ""
			},
			{
				"signature": "public V put(K key, Supplier\u003cV\u003e supplier)",
				"documentation": ""
			},
			{
				"signature": "public V put(K key, Supplier\u003cV\u003e supplier, PropertyNormalization normalization)",
				"documentation": ""
			},
			{
				"signature": "public V remove(Object key)",
				"documentation": ""
			},
			{
				"signature": "public void putAll(Map\u003c? extends K, ? extends V\u003e m)",
				"documentation": ""
			},
			{
				"signature": "public void clear()",
				"documentation": ""
			},
			{
				"signature": "public Set\u003cK\u003e keySet()",
				"documentation": ""
			},
			{
				"signature": "public Collection\u003cV\u003e values()",
				"documentation": ""
			},
			{
				"signature": "public Set\u003cEntry\u003cK, V\u003e\u003e entrySet()",
				"documentation": ""
			},
			{
				"signature": "public List\u003c? extends Object\u003e getNormalizedCollection()",
				"documentation": ""
			},
			{
				"signature": "private void validate(Map.Entry\u003cK, PropertyMapEntry\u003cK, V\u003e\u003e entry)",
				"documentation": ""
			},
			{
				"signature": "private void validate(PropertyMapEntry\u003cK, V\u003e supplier)",
				"documentation": ""
			}
		],
		"interfaces": [
			"java.util.Map"
		]
	},
	{
		"documentation": "",
		"name": "org.elasticsearch.gradle.LazyPropertyMap.PropertyMapEntry",
		"extends": "",
		"Methods": [
			{
				"signature": "PropertyMapEntry(K key, Supplier\u003cV\u003e value, PropertyNormalization normalization)",
				"documentation": ""
			},
			{
				"signature": "public PropertyNormalization getNormalization()",
				"documentation": ""
			},
			{
				"signature": "public String getName()",
				"documentation": ""
			},
			{
				"signature": "public K getKey()",
				"documentation": ""
			},
			{
				"signature": "public V getValue()",
				"documentation": ""
			}
		],
		"interfaces": [
			"org.gradle.api.Named"
		]
	},
	{
		"documentation": "/**\n * A wrapper around gradle's Exec task to capture output and log on error.\n */",
		"name": "org.elasticsearch.gradle.LoggedExec",
		"extends": "org.gradle.api.tasks.Exec",
		"Methods": [
			{
				"signature": "public LoggedExec(FileSystemOperations fileSystemOperations)",
				"documentation": "/**\n * A wrapper around gradle's Exec task to capture output and log on error.\n */"
			},
			{
				"signature": "public void execute(Task task)",
				"documentation": "/**\n * A wrapper around gradle's Exec task to capture output and log on error.\n */"
			},
			{
				"signature": "public void setSpoolOutput(boolean spoolOutput)",
				"documentation": ""
			},
			{
				"signature": "public static ExecResult exec(ExecOperations execOperations, Action\u003cExecSpec\u003e action)",
				"documentation": ""
			},
			{
				"signature": "public static ExecResult javaexec(ExecOperations project, Action\u003cJavaExecSpec\u003e action)",
				"documentation": ""
			},
			{
				"signature": "private static \u003cT extends BaseExecSpec\u003e ExecResult genericExec(Function\u003cAction\u003cT\u003e, ExecResult\u003e function, Action\u003cT\u003e action)",
				"documentation": ""
			},
			{
				"signature": "public WorkResult delete(Object... objects)",
				"documentation": ""
			}
		],
		"interfaces": [
			"FileSystemOperationsAware"
		]
	},
	{
		"documentation": "",
		"name": "org.elasticsearch.gradle.OS",
		"extends": "",
		"Methods": [
			{
				"signature": "public static OS current()",
				"documentation": ""
			},
			{
				"signature": "public static \u003cT\u003e Conditional\u003cT\u003e conditional()",
				"documentation": ""
			},
			{
				"signature": "public static Conditional\u003cString\u003e conditionalString()",
				"documentation": ""
			}
		],
		"interfaces": []
	},
	{
		"documentation": "",
		"name": "org.elasticsearch.gradle.OS.Conditional",
		"extends": "",
		"Methods": [
			{
				"signature": "public Conditional\u003cT\u003e onWindows(Supplier\u003cT\u003e supplier)",
				"documentation": ""
			},
			{
				"signature": "public Conditional\u003cT\u003e onLinux(Supplier\u003cT\u003e supplier)",
				"documentation": ""
			},
			{
				"signature": "public Conditional\u003cT\u003e onMac(Supplier\u003cT\u003e supplier)",
				"documentation": ""
			},
			{
				"signature": "public Conditional\u003cT\u003e onUnix(Supplier\u003cT\u003e supplier)",
				"documentation": ""
			},
			{
				"signature": "public T supply()",
				"documentation": ""
			}
		],
		"interfaces": []
	},
	{
		"documentation": "",
		"name": "org.elasticsearch.gradle.PropertyNormalization",
		"extends": "",
		"Methods": [],
		"interfaces": []
	},
	{
		"documentation": "/**\n * A plugin to handle reaping external services spawned by a build if Gradle dies.\n */",
		"name": "org.elasticsearch.gradle.ReaperPlugin",
		"extends": "",
		"Methods": [
			{
				"signature": "ReaperPlugin(ProjectLayout projectLayout)",
				"documentation": "/**\n     * The unique identifier to register the reaper shared service within a gradle build\n     * */"
			},
			{
				"signature": "public void apply(Project project)",
				"documentation": ""
			},
			{
				"signature": "public static void registerReaperService(Project project, ProjectLayout projectLayout, boolean internal)",
				"documentation": ""
			}
		],
		"interfaces": [
			"org.gradle.api.Plugin"
		]
	},
	{
		"documentation": "",
		"name": "org.elasticsearch.gradle.ReaperService",
		"extends": "",
		"Methods": [
			{
				"signature": "public void registerPid(String serviceId, long pid)",
				"documentation": "/**\n     * Register a pid that will be killed by the reaper.\n     */"
			},
			{
				"signature": "public void registerCommand(String serviceId, String... command)",
				"documentation": "/**\n     * Register a system command that will be run by the reaper.\n     */"
			},
			{
				"signature": "private Path getCmdFile(String serviceId)",
				"documentation": ""
			},
			{
				"signature": "public void unregister(String serviceId)",
				"documentation": ""
			},
			{
				"signature": "void shutdown()",
				"documentation": ""
			},
			{
				"signature": "private Path logFilePath()",
				"documentation": ""
			},
			{
				"signature": "private Path locateReaperJar()",
				"documentation": ""
			},
			{
				"signature": "private void ensureReaperAlive()",
				"documentation": ""
			},
			{
				"signature": "public void close() throws Exception",
				"documentation": ""
			}
		],
		"interfaces": [
			"org.gradle.api.services.BuildService",
			"AutoCloseable"
		]
	},
	{
		"documentation": "/**\n * Encapsulates comparison and printing logic for an x.y.z version.\n */",
		"name": "org.elasticsearch.gradle.Version",
		"extends": "",
		"Methods": [
			{
				"signature": "public Version(int major, int minor, int revision)",
				"documentation": ""
			},
			{
				"signature": "public Version(int major, int minor, int revision, String qualifier)",
				"documentation": ""
			},
			{
				"signature": "public static Version fromString(final String s)",
				"documentation": ""
			},
			{
				"signature": "public static Version fromString(final String s, final Mode mode)",
				"documentation": ""
			},
			{
				"signature": "public String toString()",
				"documentation": ""
			},
			{
				"signature": "public boolean before(Version compareTo)",
				"documentation": ""
			},
			{
				"signature": "public boolean before(String compareTo)",
				"documentation": ""
			},
			{
				"signature": "public boolean onOrBefore(Version compareTo)",
				"documentation": ""
			},
			{
				"signature": "public boolean onOrBefore(String compareTo)",
				"documentation": ""
			},
			{
				"signature": "public boolean onOrAfter(Version compareTo)",
				"documentation": ""
			},
			{
				"signature": "public boolean onOrAfter(String compareTo)",
				"documentation": ""
			},
			{
				"signature": "public boolean after(Version compareTo)",
				"documentation": ""
			},
			{
				"signature": "public boolean after(String compareTo)",
				"documentation": ""
			},
			{
				"signature": "public boolean equals(Object o)",
				"documentation": ""
			},
			{
				"signature": "public int hashCode()",
				"documentation": ""
			},
			{
				"signature": "public int getMajor()",
				"documentation": ""
			},
			{
				"signature": "public int getMinor()",
				"documentation": ""
			},
			{
				"signature": "public int getRevision()",
				"documentation": ""
			},
			{
				"signature": "protected int getId()",
				"documentation": ""
			},
			{
				"signature": "public String getQualifier()",
				"documentation": ""
			},
			{
				"signature": "public int compareTo(Version other)",
				"documentation": ""
			}
		],
		"interfaces": [
			"Comparable",
			"java.io.Serializable"
		]
	},
	{
		"documentation": "/**\n     * Specifies how a version string should be parsed.\n     */",
		"name": "org.elasticsearch.gradle.public",
		"extends": "",
		"Methods": [],
		"interfaces": []
	},
	{
		"documentation": "/**\n * Accessor for shared dependency versions used by elasticsearch, namely the elasticsearch and lucene versions.\n */",
		"name": "org.elasticsearch.gradle.VersionProperties",
		"extends": "",
		"Methods": [
			{
				"signature": "public static String getElasticsearch()",
				"documentation": "/**\n * Accessor for shared dependency versions used by elasticsearch, namely the elasticsearch and lucene versions.\n */"
			},
			{
				"signature": "public static Version getElasticsearchVersion()",
				"documentation": ""
			},
			{
				"signature": "public static String getLucene()",
				"documentation": ""
			},
			{
				"signature": "public static String getBundledJdkVersion()",
				"documentation": ""
			},
			{
				"signature": "public static String getBundledJdkVendor()",
				"documentation": ""
			},
			{
				"signature": "public static Map\u003cString, String\u003e getVersions()",
				"documentation": ""
			},
			{
				"signature": "static",
				"documentation": ""
			},
			{
				"signature": "private static Properties getVersionProperties()",
				"documentation": ""
			},
			{
				"signature": "public static boolean isElasticsearchSnapshot()",
				"documentation": ""
			}
		],
		"interfaces": []
	},
	{
		"documentation": "",
		"name": "org.elasticsearch.gradle.dependencies.CompileOnlyResolvePlugin",
		"extends": "",
		"Methods": [
			{
				"signature": "public void apply(Project project)",
				"documentation": ""
			}
		],
		"interfaces": [
			"org.gradle.api.Plugin"
		]
	},
	{
		"documentation": "",
		"name": "org.elasticsearch.gradle.distribution.ArchiveElasticsearchDistributionType",
		"extends": "",
		"Methods": [
			{
				"signature": "ArchiveElasticsearchDistributionType()",
				"documentation": ""
			},
			{
				"signature": "public String getName()",
				"documentation": ""
			},
			{
				"signature": "public String getExtension(ElasticsearchDistribution.Platform platform)",
				"documentation": ""
			},
			{
				"signature": "public String getClassifier(ElasticsearchDistribution.Platform platform, Version version)",
				"documentation": ""
			},
			{
				"signature": "public boolean shouldExtract()",
				"documentation": ""
			}
		],
		"interfaces": [
			"org.elasticsearch.gradle.ElasticsearchDistributionType"
		]
	},
	{
		"documentation": "",
		"name": "org.elasticsearch.gradle.distribution.ElasticsearchDistributionTypes",
		"extends": "",
		"Methods": [],
		"interfaces": []
	},
	{
		"documentation": "",
		"name": "org.elasticsearch.gradle.distribution.IntegTestZipElasticsearchDistributionType",
		"extends": "",
		"Methods": [
			{
				"signature": "IntegTestZipElasticsearchDistributionType()",
				"documentation": ""
			},
			{
				"signature": "public String getName()",
				"documentation": ""
			},
			{
				"signature": "public boolean shouldExtract()",
				"documentation": ""
			}
		],
		"interfaces": [
			"org.elasticsearch.gradle.ElasticsearchDistributionType"
		]
	},
	{
		"documentation": "",
		"name": "org.elasticsearch.gradle.jarhell.JarHellPlugin",
		"extends": "",
		"Methods": [
			{
				"signature": "public void apply(Project project)",
				"documentation": ""
			},
			{
				"signature": "private TaskProvider\u003c? extends Task\u003e createTask(Project project)",
				"documentation": ""
			},
			{
				"signature": "private static SourceSet getJavaTestSourceSet(Project project)",
				"documentation": "/**\n     * @param project The project to look for test Java resources.\n     */"
			}
		],
		"interfaces": [
			"org.gradle.api.Plugin"
		]
	},
	{
		"documentation": "/**\n * Runs CheckJarHell on a classpath.\n */",
		"name": "org.elasticsearch.gradle.jarhell.JarHellTask",
		"extends": "org.gradle.api.DefaultTask",
		"Methods": [
			{
				"signature": "public JarHellTask(ExecOperations execOperations, ProjectLayout projectLayout)",
				"documentation": "/**\n * Runs CheckJarHell on a classpath.\n */"
			},
			{
				"signature": "public File getSuccessMarker()",
				"documentation": ""
			},
			{
				"signature": "public void runJarHellCheck() throws IOException",
				"documentation": ""
			},
			{
				"signature": "private void writeMarker() throws IOException",
				"documentation": ""
			},
			{
				"signature": "public FileCollection getClasspath()",
				"documentation": ""
			},
			{
				"signature": "public void setClasspath(FileCollection classpath)",
				"documentation": ""
			},
			{
				"signature": "public FileCollection getJarHellRuntimeClasspath()",
				"documentation": ""
			},
			{
				"signature": "public void setJarHellRuntimeClasspath(FileCollection jarHellRuntimeClasspath)",
				"documentation": ""
			}
		],
		"interfaces": []
	},
	{
		"documentation": "/**\n * Encapsulates build configuration for an Elasticsearch plugin.\n */",
		"name": "org.elasticsearch.gradle.plugin.PluginBuildPlugin",
		"extends": "",
		"Methods": [
			{
				"signature": "public void apply(final Project project)",
				"documentation": "/**\n * Encapsulates build configuration for an Elasticsearch plugin.\n */"
			},
			{
				"signature": "private static NamedDomainObjectContainer\u003cElasticsearchCluster\u003e testClusters(Project project, String extensionName)",
				"documentation": ""
			},
			{
				"signature": "private static void configurePublishing(Project project, PluginPropertiesExtension extension)",
				"documentation": ""
			},
			{
				"signature": "private static void configureDependencies(final Project project)",
				"documentation": ""
			},
			{
				"signature": "private static TaskProvider\u003cZip\u003e createBundleTasks(final Project project, PluginPropertiesExtension extension)",
				"documentation": "/**\n     * Adds bundle tasks which builds the dir and zip containing the plugin jars,\n     * metadata, properties, and packaging files\n     */"
			},
			{
				"signature": "public void execute(Task task)",
				"documentation": "/**\n     * Adds bundle tasks which builds the dir and zip containing the plugin jars,\n     * metadata, properties, and packaging files\n     */"
			},
			{
				"signature": "public void execute(Task task)",
				"documentation": "/**\n     * Adds bundle tasks which builds the dir and zip containing the plugin jars,\n     * metadata, properties, and packaging files\n     */"
			},
			{
				"signature": "private static CopySpec createBundleSpec(Project project, File pluginMetadata, TaskProvider\u003cCopy\u003e buildProperties)",
				"documentation": ""
			}
		],
		"interfaces": [
			"org.gradle.api.Plugin"
		]
	},
	{
		"documentation": "/**\n * A container for plugin properties that will be written to the plugin descriptor, for easy\n * manipulation in the gradle DSL.\n */",
		"name": "org.elasticsearch.gradle.plugin.PluginPropertiesExtension",
		"extends": "",
		"Methods": [
			{
				"signature": "public PluginPropertiesExtension(Project project)",
				"documentation": "/**\n     * A notice file that should be included in the built plugin zip. This will be\n     * extended with notices from the {@code licenses/} directory.\n     */"
			},
			{
				"signature": "public String getName()",
				"documentation": ""
			},
			{
				"signature": "public void setName(String name)",
				"documentation": ""
			},
			{
				"signature": "public String getVersion()",
				"documentation": ""
			},
			{
				"signature": "public void setVersion(String version)",
				"documentation": ""
			},
			{
				"signature": "public String getDescription()",
				"documentation": ""
			},
			{
				"signature": "public void setDescription(String description)",
				"documentation": ""
			},
			{
				"signature": "public String getClassname()",
				"documentation": ""
			},
			{
				"signature": "public void setClassname(String classname)",
				"documentation": ""
			},
			{
				"signature": "public List\u003cString\u003e getExtendedPlugins()",
				"documentation": ""
			},
			{
				"signature": "public boolean isHasNativeController()",
				"documentation": ""
			},
			{
				"signature": "public void setHasNativeController(boolean hasNativeController)",
				"documentation": ""
			},
			{
				"signature": "public PluginType getType()",
				"documentation": ""
			},
			{
				"signature": "public void setType(PluginType type)",
				"documentation": ""
			},
			{
				"signature": "public String getJavaOpts()",
				"documentation": ""
			},
			{
				"signature": "public void setJavaOpts(String javaOpts)",
				"documentation": ""
			},
			{
				"signature": "public boolean isLicensed()",
				"documentation": ""
			},
			{
				"signature": "public void setLicensed(boolean licensed)",
				"documentation": ""
			},
			{
				"signature": "public boolean isRequiresKeystore()",
				"documentation": ""
			},
			{
				"signature": "public void setRequiresKeystore(boolean requiresKeystore)",
				"documentation": ""
			},
			{
				"signature": "public File getLicenseFile()",
				"documentation": ""
			},
			{
				"signature": "public void setLicenseFile(File licenseFile)",
				"documentation": ""
			},
			{
				"signature": "public File getNoticeFile()",
				"documentation": ""
			},
			{
				"signature": "public void setNoticeFile(File noticeFile)",
				"documentation": ""
			},
			{
				"signature": "public Project getProject()",
				"documentation": ""
			},
			{
				"signature": "public void setExtendedPlugins(List\u003cString\u003e extendedPlugins)",
				"documentation": ""
			},
			{
				"signature": "public void setBundleSpec(CopySpec bundleSpec)",
				"documentation": ""
			},
			{
				"signature": "public CopySpec getBundleSpec()",
				"documentation": ""
			}
		],
		"interfaces": []
	},
	{
		"documentation": "/**\n * This mirrors org.elasticsearch.plugins.PluginType, which is not\n * available to the Gradle plugin that actually builds plugins. See that\n * class for further information.\n */",
		"name": "org.elasticsearch.gradle.plugin.PluginType",
		"extends": "",
		"Methods": [
			{
				"signature": "public String toString()",
				"documentation": "/**\n * This mirrors org.elasticsearch.plugins.PluginType, which is not\n * available to the Gradle plugin that actually builds plugins. See that\n * class for further information.\n */"
			}
		],
		"interfaces": []
	},
	{
		"documentation": "",
		"name": "org.elasticsearch.gradle.test.GradleTestPolicySetupPlugin",
		"extends": "",
		"Methods": [
			{
				"signature": "public void apply(Project project)",
				"documentation": ""
			}
		],
		"interfaces": [
			"org.gradle.api.Plugin"
		]
	},
	{
		"documentation": "",
		"name": "org.elasticsearch.gradle.test.JavaRestTestPlugin",
		"extends": "",
		"Methods": [
			{
				"signature": "public void apply(Project project)",
				"documentation": ""
			}
		],
		"interfaces": [
			"org.gradle.api.Plugin"
		]
	},
	{
		"documentation": "",
		"name": "org.elasticsearch.gradle.test.SystemPropertyCommandLineArgumentProvider",
		"extends": "",
		"Methods": [
			{
				"signature": "public void systemProperty(String key, Provider\u003cObject\u003e value)",
				"documentation": ""
			},
			{
				"signature": "public void systemProperty(String key, Supplier\u003cString\u003e value)",
				"documentation": ""
			},
			{
				"signature": "public void systemProperty(String key, Object value)",
				"documentation": ""
			},
			{
				"signature": "public Iterable\u003cString\u003e asArguments()",
				"documentation": ""
			},
			{
				"signature": "public Iterable\u003cString\u003e getPropertyNames()",
				"documentation": ""
			}
		],
		"interfaces": [
			"org.gradle.process.CommandLineArgumentProvider"
		]
	},
	{
		"documentation": "",
		"name": "org.elasticsearch.gradle.test.YamlRestTestPlugin",
		"extends": "",
		"Methods": [
			{
				"signature": "public void apply(Project project)",
				"documentation": ""
			},
			{
				"signature": "private static void setupDefaultDependencies(        DependencyHandler dependencyHandler,        Configuration restTestSpecs,        Configuration yamlRestTestImplementation    )",
				"documentation": ""
			},
			{
				"signature": "private TaskProvider\u003cStandaloneRestIntegTestTask\u003e setupTestTask(        Project project,        SourceSet testSourceSet,        NamedDomainObjectProvider\u003cElasticsearchCluster\u003e clusterProvider    )",
				"documentation": ""
			}
		],
		"interfaces": [
			"org.gradle.api.Plugin"
		]
	},
	{
		"documentation": "",
		"name": "org.elasticsearch.gradle.testclusters.DefaultTestClustersTask",
		"extends": "org.gradle.api.DefaultTask",
		"Methods": [
			{
				"signature": "public Collection\u003cElasticsearchCluster\u003e getClusters()",
				"documentation": ""
			}
		],
		"interfaces": [
			"TestClustersAware"
		]
	},
	{
		"documentation": "",
		"name": "org.elasticsearch.gradle.testclusters.ElasticsearchCluster",
		"extends": "",
		"Methods": [
			{
				"signature": "public ElasticsearchCluster(        String path,        String clusterName,        Project project,        Provider\u003cReaperService\u003e reaper,        FileSystemOperations fileSystemOperations,        ArchiveOperations archiveOperations,        ExecOperations execOperations,        FileOperations fileOperations,        File workingDirBase,        Provider\u003cFile\u003e runtimeJava,        Function\u003cVersion, Boolean\u003e isReleasedVersion    )",
				"documentation": ""
			},
			{
				"signature": "public void setNumberOfNodes(int numberOfNodes)",
				"documentation": ""
			},
			{
				"signature": "public void setReadinessEnabled(boolean enabled)",
				"documentation": ""
			},
			{
				"signature": "public ElasticsearchNode getFirstNode()",
				"documentation": ""
			},
			{
				"signature": "public ElasticsearchNode getLastNode()",
				"documentation": ""
			},
			{
				"signature": "public int getNumberOfNodes()",
				"documentation": ""
			},
			{
				"signature": "public String getName()",
				"documentation": ""
			},
			{
				"signature": "public String getPath()",
				"documentation": ""
			},
			{
				"signature": "public void setVersion(String version)",
				"documentation": ""
			},
			{
				"signature": "public void setVersions(List\u003cString\u003e version)",
				"documentation": ""
			},
			{
				"signature": "public void setTestDistribution(TestDistribution distribution)",
				"documentation": ""
			},
			{
				"signature": "public void plugin(Provider\u003cRegularFile\u003e plugin)",
				"documentation": ""
			},
			{
				"signature": "public void plugin(TaskProvider\u003cZip\u003e plugin)",
				"documentation": ""
			},
			{
				"signature": "public void plugin(String pluginProjectPath)",
				"documentation": ""
			},
			{
				"signature": "public void module(Provider\u003cRegularFile\u003e module)",
				"documentation": ""
			},
			{
				"signature": "public void module(TaskProvider\u003cSync\u003e module)",
				"documentation": ""
			},
			{
				"signature": "public void module(String moduleProjectPath)",
				"documentation": ""
			},
			{
				"signature": "public void keystore(String key, String value)",
				"documentation": ""
			},
			{
				"signature": "public void keystore(String key, Supplier\u003cCharSequence\u003e valueSupplier)",
				"documentation": ""
			},
			{
				"signature": "public void keystore(String key, File value)",
				"documentation": ""
			},
			{
				"signature": "public void keystore(String key, File value, PropertyNormalization normalization)",
				"documentation": ""
			},
			{
				"signature": "public void keystore(String key, FileSupplier valueSupplier)",
				"documentation": ""
			},
			{
				"signature": "public void keystorePassword(String password)",
				"documentation": ""
			},
			{
				"signature": "public void cliSetup(String binTool, CharSequence... args)",
				"documentation": ""
			},
			{
				"signature": "public void setting(String key, String value)",
				"documentation": ""
			},
			{
				"signature": "public void setting(String key, String value, PropertyNormalization normalization)",
				"documentation": ""
			},
			{
				"signature": "public void setting(String key, Supplier\u003cCharSequence\u003e valueSupplier)",
				"documentation": ""
			},
			{
				"signature": "public void setting(String key, Supplier\u003cCharSequence\u003e valueSupplier, PropertyNormalization normalization)",
				"documentation": ""
			},
			{
				"signature": "public void systemProperty(String key, String value)",
				"documentation": ""
			},
			{
				"signature": "public void systemProperty(String key, Supplier\u003cCharSequence\u003e valueSupplier)",
				"documentation": ""
			},
			{
				"signature": "public void systemProperty(String key, Supplier\u003cCharSequence\u003e valueSupplier, PropertyNormalization normalization)",
				"documentation": ""
			},
			{
				"signature": "public void environment(String key, String value)",
				"documentation": ""
			},
			{
				"signature": "public void environment(String key, Supplier\u003cCharSequence\u003e valueSupplier)",
				"documentation": ""
			},
			{
				"signature": "public void environment(String key, Supplier\u003cCharSequence\u003e valueSupplier, PropertyNormalization normalization)",
				"documentation": ""
			},
			{
				"signature": "public void jvmArgs(String... values)",
				"documentation": ""
			},
			{
				"signature": "public boolean isPreserveDataDir()",
				"documentation": ""
			},
			{
				"signature": "public void setPreserveDataDir(boolean preserveDataDir)",
				"documentation": ""
			},
			{
				"signature": "public void freeze()",
				"documentation": ""
			},
			{
				"signature": "private void checkFrozen()",
				"documentation": ""
			},
			{
				"signature": "public void start()",
				"documentation": ""
			},
			{
				"signature": "private void commonNodeConfig()",
				"documentation": ""
			},
			{
				"signature": "public void restart()",
				"documentation": ""
			},
			{
				"signature": "public void goToNextVersion()",
				"documentation": ""
			},
			{
				"signature": "public void nextNodeToNextVersion()",
				"documentation": ""
			},
			{
				"signature": "public void extraConfigFile(String destination, File from)",
				"documentation": ""
			},
			{
				"signature": "public void extraConfigFile(String destination, File from, PropertyNormalization normalization)",
				"documentation": ""
			},
			{
				"signature": "public void extraJarFiles(FileCollection from)",
				"documentation": ""
			},
			{
				"signature": "public void user(Map\u003cString, String\u003e userSpec)",
				"documentation": ""
			},
			{
				"signature": "public void rolesFile(File rolesYml)",
				"documentation": ""
			},
			{
				"signature": "public void requiresFeature(String feature, Version from)",
				"documentation": ""
			},
			{
				"signature": "public void requiresFeature(String feature, Version from, Version until)",
				"documentation": ""
			},
			{
				"signature": "private void writeUnicastHostsFiles()",
				"documentation": ""
			},
			{
				"signature": "public String getHttpSocketURI()",
				"documentation": ""
			},
			{
				"signature": "public String getTransportPortURI()",
				"documentation": ""
			},
			{
				"signature": "public String getReadinessPortURI()",
				"documentation": ""
			},
			{
				"signature": "public List\u003cString\u003e getAllHttpSocketURI()",
				"documentation": ""
			},
			{
				"signature": "public List\u003cString\u003e getAllTransportPortURI()",
				"documentation": ""
			},
			{
				"signature": "public List\u003cString\u003e getAllReadinessPortURI()",
				"documentation": ""
			},
			{
				"signature": "public void waitForAllConditions()",
				"documentation": ""
			},
			{
				"signature": "public void stop(boolean tailLogs)",
				"documentation": ""
			},
			{
				"signature": "public void setNameCustomization(Function\u003cString, String\u003e nameCustomization)",
				"documentation": ""
			},
			{
				"signature": "public boolean isProcessAlive()",
				"documentation": ""
			},
			{
				"signature": "public ElasticsearchNode singleNode()",
				"documentation": ""
			},
			{
				"signature": "private void addWaitForClusterHealth()",
				"documentation": ""
			},
			{
				"signature": "public NamedDomainObjectContainer\u003cElasticsearchNode\u003e getNodes()",
				"documentation": ""
			},
			{
				"signature": "public boolean equals(Object o)",
				"documentation": ""
			},
			{
				"signature": "public int hashCode()",
				"documentation": ""
			},
			{
				"signature": "public String toString()",
				"documentation": ""
			}
		],
		"interfaces": [
			"TestClusterConfiguration",
			"org.gradle.api.Named"
		]
	},
	{
		"documentation": "",
		"name": "org.elasticsearch.gradle.testclusters.ElasticsearchNode",
		"extends": "",
		"Methods": [
			{
				"signature": "ElasticsearchNode(        String clusterName,        String path,        String name,        Project project,        Provider\u003cReaperService\u003e reaperServiceProvider,        FileSystemOperations fileSystemOperations,        ArchiveOperations archiveOperations,        ExecOperations execOperations,        FileOperations fileOperations,        File workingDirBase,        Provider\u003cFile\u003e runtimeJava,        Function\u003cVersion, Boolean\u003e isReleasedVersion    )",
				"documentation": ""
			},
			{
				"signature": "public String getName()",
				"documentation": ""
			},
			{
				"signature": "public Version getVersion()",
				"documentation": ""
			},
			{
				"signature": "public void setVersion(String version)",
				"documentation": ""
			},
			{
				"signature": "public void setVersions(List\u003cString\u003e versions)",
				"documentation": ""
			},
			{
				"signature": "private void doSetVersion(String version)",
				"documentation": ""
			},
			{
				"signature": "public TestDistribution getTestDistribution()",
				"documentation": ""
			},
			{
				"signature": "List\u003cElasticsearchDistribution\u003e getDistributions()",
				"documentation": ""
			},
			{
				"signature": "public void setTestDistribution(TestDistribution testDistribution)",
				"documentation": ""
			},
			{
				"signature": "private void setDistributionType(ElasticsearchDistribution distribution, TestDistribution testDistribution)",
				"documentation": ""
			},
			{
				"signature": "Collection\u003cConfiguration\u003e getPluginAndModuleConfigurations()",
				"documentation": ""
			},
			{
				"signature": "private Provider\u003cRegularFile\u003e maybeCreatePluginOrModuleDependency(String path, String consumingConfiguration)",
				"documentation": ""
			},
			{
				"signature": "public void plugin(Provider\u003cRegularFile\u003e plugin)",
				"documentation": ""
			},
			{
				"signature": "public void plugin(String pluginProjectPath)",
				"documentation": ""
			},
			{
				"signature": "public void plugin(TaskProvider\u003cZip\u003e plugin)",
				"documentation": ""
			},
			{
				"signature": "public void module(Provider\u003cRegularFile\u003e module)",
				"documentation": ""
			},
			{
				"signature": "public void module(TaskProvider\u003cSync\u003e module)",
				"documentation": ""
			},
			{
				"signature": "private void registerExtractedConfig(Provider\u003cRegularFile\u003e pluginProvider)",
				"documentation": ""
			},
			{
				"signature": "private void configureArtifactTransforms()",
				"documentation": ""
			},
			{
				"signature": "public void module(String moduleProjectPath)",
				"documentation": ""
			},
			{
				"signature": "public void keystore(String key, String value)",
				"documentation": ""
			},
			{
				"signature": "public void keystore(String key, Supplier\u003cCharSequence\u003e valueSupplier)",
				"documentation": ""
			},
			{
				"signature": "public void keystore(String key, File value)",
				"documentation": ""
			},
			{
				"signature": "public void keystore(String key, File value, PropertyNormalization normalization)",
				"documentation": ""
			},
			{
				"signature": "public void keystore(String key, FileSupplier valueSupplier)",
				"documentation": ""
			},
			{
				"signature": "public void keystorePassword(String password)",
				"documentation": ""
			},
			{
				"signature": "public void cliSetup(String binTool, CharSequence... args)",
				"documentation": ""
			},
			{
				"signature": "public void setting(String key, String value)",
				"documentation": ""
			},
			{
				"signature": "public void setting(String key, String value, PropertyNormalization normalization)",
				"documentation": ""
			},
			{
				"signature": "public void setting(String key, Supplier\u003cCharSequence\u003e valueSupplier)",
				"documentation": ""
			},
			{
				"signature": "public void setting(String key, Supplier\u003cCharSequence\u003e valueSupplier, PropertyNormalization normalization)",
				"documentation": ""
			},
			{
				"signature": "public void systemProperty(String key, String value)",
				"documentation": ""
			},
			{
				"signature": "public void systemProperty(String key, Supplier\u003cCharSequence\u003e valueSupplier)",
				"documentation": ""
			},
			{
				"signature": "public void systemProperty(String key, Supplier\u003cCharSequence\u003e valueSupplier, PropertyNormalization normalization)",
				"documentation": ""
			},
			{
				"signature": "public void environment(String key, String value)",
				"documentation": ""
			},
			{
				"signature": "public void environment(String key, Supplier\u003cCharSequence\u003e valueSupplier)",
				"documentation": ""
			},
			{
				"signature": "public void environment(String key, Supplier\u003cCharSequence\u003e valueSupplier, PropertyNormalization normalization)",
				"documentation": ""
			},
			{
				"signature": "public void jvmArgs(String... values)",
				"documentation": ""
			},
			{
				"signature": "public Path getConfigDir()",
				"documentation": ""
			},
			{
				"signature": "public boolean isPreserveDataDir()",
				"documentation": ""
			},
			{
				"signature": "public void setPreserveDataDir(boolean preserveDataDir)",
				"documentation": ""
			},
			{
				"signature": "public void freeze()",
				"documentation": ""
			},
			{
				"signature": "private boolean canUseSharedDistribution()",
				"documentation": ""
			},
			{
				"signature": "private void logToProcessStdout(String message)",
				"documentation": ""
			},
			{
				"signature": "public void restart()",
				"documentation": ""
			},
			{
				"signature": "void goToNextVersion()",
				"documentation": ""
			},
			{
				"signature": "private boolean isSettingTrue(String name)",
				"documentation": ""
			},
			{
				"signature": "private void copyExtraConfigFiles()",
				"documentation": ""
			},
			{
				"signature": "private void copyExtraJars()",
				"documentation": "/**\n     * Copies extra jars to the `/lib` directory.\n     * //TODO: Remove this when system modules are available\n     */"
			},
			{
				"signature": "private void configureSecurity()",
				"documentation": ""
			},
			{
				"signature": "private void installModules()",
				"documentation": ""
			},
			{
				"signature": "public void extraConfigFile(String destination, File from)",
				"documentation": ""
			},
			{
				"signature": "public void extraConfigFile(String destination, File from, PropertyNormalization normalization)",
				"documentation": ""
			},
			{
				"signature": "public void extraJarFiles(FileCollection from)",
				"documentation": ""
			},
			{
				"signature": "public void user(Map\u003cString, String\u003e userSpec)",
				"documentation": ""
			},
			{
				"signature": "private File getBuildPluginFile(String name)",
				"documentation": ""
			},
			{
				"signature": "public void rolesFile(File rolesYml)",
				"documentation": ""
			},
			{
				"signature": "public void requiresFeature(String feature, Version from)",
				"documentation": ""
			},
			{
				"signature": "public void requiresFeature(String feature, Version from, Version until)",
				"documentation": ""
			},
			{
				"signature": "private void runElasticsearchBinScriptWithInput(String input, String tool, CharSequence... args)",
				"documentation": ""
			},
			{
				"signature": "private void runKeystoreCommandWithPassword(String keystorePassword, String input, CharSequence... args)",
				"documentation": ""
			},
			{
				"signature": "private void runElasticsearchBinScript(String tool, CharSequence... args)",
				"documentation": ""
			},
			{
				"signature": "private Map\u003cString, String\u003e getESEnvironment()",
				"documentation": ""
			},
			{
				"signature": "private void startElasticsearchProcess()",
				"documentation": ""
			},
			{
				"signature": "public Path getDistroDir()",
				"documentation": ""
			},
			{
				"signature": "public String getHttpSocketURI()",
				"documentation": ""
			},
			{
				"signature": "public String getTransportPortURI()",
				"documentation": ""
			},
			{
				"signature": "public String getReadinessPortURI()",
				"documentation": ""
			},
			{
				"signature": "public List\u003cString\u003e getAllHttpSocketURI()",
				"documentation": ""
			},
			{
				"signature": "public List\u003cString\u003e getAllTransportPortURI()",
				"documentation": ""
			},
			{
				"signature": "public List\u003cString\u003e getAllReadinessPortURI()",
				"documentation": ""
			},
			{
				"signature": "public File getServerLog()",
				"documentation": ""
			},
			{
				"signature": "public File getAuditLog()",
				"documentation": ""
			},
			{
				"signature": "public void setNameCustomization(Function\u003cString, String\u003e nameCustomizer)",
				"documentation": ""
			},
			{
				"signature": "private void stopHandle(ProcessHandle processHandle, boolean forcibly)",
				"documentation": ""
			},
			{
				"signature": "private void logProcessInfo(String prefix, ProcessHandle.Info info)",
				"documentation": ""
			},
			{
				"signature": "private void logFileContents(String description, Path from, boolean tailLogs)",
				"documentation": ""
			},
			{
				"signature": "private String normalizeLogLine(String line)",
				"documentation": ""
			},
			{
				"signature": "private void waitForProcessToExit(ProcessHandle processHandle)",
				"documentation": ""
			},
			{
				"signature": "private void createWorkingDir() throws IOException",
				"documentation": ""
			},
			{
				"signature": "private void setupNodeDistribution(Path distroExtractDir) throws IOException",
				"documentation": ""
			},
			{
				"signature": "private void syncWithLinks(Path sourceRoot, Path destinationRoot)",
				"documentation": "/**\n     * Does the equivalent of `cp -lr` and `chmod -r a-w` to save space and improve speed.\n     * We remove write permissions to make sure files are note mistakenly edited ( e.x. the config file ) and changes\n     * reflected across all copies. Permissions are retained to be able to replace the links.\n     *\n     * @param sourceRoot      where to copy from\n     * @param destinationRoot destination to link to\n     */"
			},
			{
				"signature": "private void syncWithCopy(Path sourceRoot, Path destinationRoot)",
				"documentation": ""
			},
			{
				"signature": "private void sync(Path sourceRoot, Path destinationRoot, BiConsumer\u003cPath, Path\u003e syncMethod)",
				"documentation": ""
			},
			{
				"signature": "private void createConfiguration()",
				"documentation": ""
			},
			{
				"signature": "private void tweakJvmOptions(Path configFileRoot)",
				"documentation": ""
			},
			{
				"signature": "private Map\u003cString, String\u003e jvmOptionExpansions()",
				"documentation": ""
			},
			{
				"signature": "private void checkFrozen()",
				"documentation": ""
			},
			{
				"signature": "private List\u003cString\u003e getTransportPortInternal()",
				"documentation": ""
			},
			{
				"signature": "private List\u003cString\u003e getHttpPortInternal()",
				"documentation": ""
			},
			{
				"signature": "private List\u003cString\u003e getReadinessPortInternal()",
				"documentation": ""
			},
			{
				"signature": "private List\u003cString\u003e readPortsFile(Path file) throws IOException",
				"documentation": ""
			},
			{
				"signature": "private Path getExtractedDistributionDir()",
				"documentation": ""
			},
			{
				"signature": "public FileCollection getInstalledClasspath()",
				"documentation": ""
			},
			{
				"signature": "public FileCollection getInstalledFiles()",
				"documentation": ""
			},
			{
				"signature": "public List\u003cFileTree\u003e getDistributionClasspath()",
				"documentation": ""
			},
			{
				"signature": "public List\u003cFileTree\u003e getDistributionFiles()",
				"documentation": ""
			},
			{
				"signature": "private List\u003cFileTree\u003e getDistributionFiles(Action\u003cPatternFilterable\u003e patternFilter)",
				"documentation": ""
			},
			{
				"signature": "public List\u003cFile\u003e getRoleFiles()",
				"documentation": ""
			},
			{
				"signature": "public List\u003c?\u003e getKeystoreSettings()",
				"documentation": ""
			},
			{
				"signature": "public List\u003c?\u003e getKeystoreFiles()",
				"documentation": ""
			},
			{
				"signature": "public List\u003c?\u003e getCliSetup()",
				"documentation": ""
			},
			{
				"signature": "public List\u003c?\u003e getSettings()",
				"documentation": ""
			},
			{
				"signature": "public List\u003c?\u003e getSystemProperties()",
				"documentation": ""
			},
			{
				"signature": "public List\u003c?\u003e getEnvironment()",
				"documentation": ""
			},
			{
				"signature": "public List\u003c?\u003e getJvmArgs()",
				"documentation": ""
			},
			{
				"signature": "public List\u003c?\u003e getExtraConfigFiles()",
				"documentation": ""
			},
			{
				"signature": "public List\u003cFeatureFlag\u003e getFeatureFlags()",
				"documentation": ""
			},
			{
				"signature": "public boolean isProcessAlive()",
				"documentation": ""
			},
			{
				"signature": "void waitForAllConditions()",
				"documentation": ""
			},
			{
				"signature": "public boolean equals(Object o)",
				"documentation": ""
			},
			{
				"signature": "public int hashCode()",
				"documentation": ""
			},
			{
				"signature": "public String toString()",
				"documentation": ""
			},
			{
				"signature": "List\u003cMap\u003cString, String\u003e\u003e getCredentials()",
				"documentation": ""
			},
			{
				"signature": "private boolean checkPortsFilesExistWithDelay(TestClusterConfiguration node)",
				"documentation": ""
			},
			{
				"signature": "public boolean isHttpSslEnabled()",
				"documentation": ""
			},
			{
				"signature": "void configureHttpWait(WaitForHttpResource wait)",
				"documentation": ""
			},
			{
				"signature": "void setHttpPort(String httpPort)",
				"documentation": ""
			},
			{
				"signature": "void setTransportPort(String transportPort)",
				"documentation": ""
			},
			{
				"signature": "void setDataPath(Path dataPath)",
				"documentation": ""
			},
			{
				"signature": "Path getEsLogFile()",
				"documentation": ""
			}
		],
		"interfaces": [
			"TestClusterConfiguration"
		]
	},
	{
		"documentation": "",
		"name": "org.elasticsearch.gradle.testclusters.ElasticsearchNode.FileEntry",
		"extends": "",
		"Methods": [
			{
				"signature": "FileEntry(String name, File file)",
				"documentation": ""
			},
			{
				"signature": "public String getName()",
				"documentation": ""
			},
			{
				"signature": "public File getFile()",
				"documentation": ""
			}
		],
		"interfaces": [
			"org.gradle.api.Named"
		]
	},
	{
		"documentation": "",
		"name": "org.elasticsearch.gradle.testclusters.ElasticsearchNode.CliEntry",
		"extends": "",
		"Methods": [
			{
				"signature": "CliEntry(String executable, CharSequence[] args)",
				"documentation": ""
			},
			{
				"signature": "public String getExecutable()",
				"documentation": ""
			},
			{
				"signature": "public CharSequence[] getArgs()",
				"documentation": ""
			}
		],
		"interfaces": []
	},
	{
		"documentation": "",
		"name": "org.elasticsearch.gradle.testclusters.private",
		"extends": "",
		"Methods": [
			{
				"signature": "public String getFeature()",
				"documentation": ""
			},
			{
				"signature": "public Version getFrom()",
				"documentation": ""
			},
			{
				"signature": "public Version getUntil()",
				"documentation": ""
			}
		],
		"interfaces": []
	},
	{
		"documentation": "",
		"name": "org.elasticsearch.gradle.testclusters.ElasticsearchNode.LinkCreationException",
		"extends": "java.io.UncheckedIOException",
		"Methods": [
			{
				"signature": "LinkCreationException(String message, IOException cause)",
				"documentation": ""
			}
		],
		"interfaces": []
	},
	{
		"documentation": "",
		"name": "org.elasticsearch.gradle.testclusters.RunTask",
		"extends": "DefaultTestClustersTask",
		"Methods": [
			{
				"signature": "public void setDebug(boolean enabled)",
				"documentation": ""
			},
			{
				"signature": "public Boolean getDebug()",
				"documentation": ""
			},
			{
				"signature": "public void setDataDir(String dataDirStr)",
				"documentation": ""
			},
			{
				"signature": "public Boolean getPreserveData()",
				"documentation": ""
			},
			{
				"signature": "public void setPreserveData(Boolean preserveData)",
				"documentation": ""
			},
			{
				"signature": "public void setKeystorePassword(String password)",
				"documentation": ""
			},
			{
				"signature": "public String getKeystorePassword()",
				"documentation": ""
			},
			{
				"signature": "public String getDataDir()",
				"documentation": ""
			},
			{
				"signature": "public void beforeStart()",
				"documentation": ""
			},
			{
				"signature": "public void runAndWait() throws IOException",
				"documentation": ""
			}
		],
		"interfaces": []
	},
	{
		"documentation": "/**\n * Customized version of Gradle {@link Test} task which tracks a collection of {@link ElasticsearchCluster} as a task input. We must do this\n * as a custom task type because the current {@link org.gradle.api.tasks.TaskInputs} runtime API does not have a way to register\n * {@link Nested} inputs.\n */",
		"name": "org.elasticsearch.gradle.testclusters.StandaloneRestIntegTestTask",
		"extends": "org.gradle.api.tasks.testing.Test",
		"Methods": [
			{
				"signature": "public StandaloneRestIntegTestTask()",
				"documentation": "/**\n * Customized version of Gradle {@link Test} task which tracks a collection of {@link ElasticsearchCluster} as a task input. We must do this\n * as a custom task type because the current {@link org.gradle.api.tasks.TaskInputs} runtime API does not have a way to register\n * {@link Nested} inputs.\n */"
			},
			{
				"signature": "public void setDebugServer(boolean enabled)",
				"documentation": ""
			},
			{
				"signature": "public int getMaxParallelForks()",
				"documentation": ""
			},
			{
				"signature": "public Collection\u003cElasticsearchCluster\u003e getClusters()",
				"documentation": ""
			},
			{
				"signature": "public List\u003cResourceLock\u003e getSharedResources()",
				"documentation": ""
			},
			{
				"signature": "private ResourceLock getResourceLock(SharedResource resource, int nodeCount)",
				"documentation": "/**\n     * SharedResource#getResourceLock has changed its parameters with Gradle 7.5.\n     * We resolve this via reflection for now to be compatible with Gradle before and after 7.5.\n     * This makes migration easier and allows gradle benchmark tests across gradle versions easier.\n     * Likely will be removed in future version.\n     * */"
			},
			{
				"signature": "public WorkResult delete(Object... objects)",
				"documentation": ""
			},
			{
				"signature": "public void beforeStart()",
				"documentation": ""
			}
		],
		"interfaces": [
			"TestClustersAware",
			"org.elasticsearch.gradle.FileSystemOperationsAware"
		]
	},
	{
		"documentation": "",
		"name": "org.elasticsearch.gradle.testclusters.TestClustersException",
		"extends": "RuntimeException",
		"Methods": [
			{
				"signature": "TestClustersException(String message)",
				"documentation": ""
			},
			{
				"signature": "TestClustersException(String message, Throwable cause)",
				"documentation": ""
			},
			{
				"signature": "TestClustersException(Throwable cause)",
				"documentation": ""
			}
		],
		"interfaces": []
	},
	{
		"documentation": "",
		"name": "org.elasticsearch.gradle.testclusters.TestClustersPlugin",
		"extends": "",
		"Methods": [
			{
				"signature": "protected FileSystemOperations getFileSystemOperations()",
				"documentation": ""
			},
			{
				"signature": "protected ArchiveOperations getArchiveOperations()",
				"documentation": ""
			},
			{
				"signature": "protected ExecOperations getExecOperations()",
				"documentation": ""
			},
			{
				"signature": "protected FileOperations getFileOperations()",
				"documentation": ""
			},
			{
				"signature": "public TestClustersPlugin(ProviderFactory providerFactory)",
				"documentation": ""
			},
			{
				"signature": "public void setRuntimeJava(Provider\u003cFile\u003e runtimeJava)",
				"documentation": ""
			},
			{
				"signature": "public void setIsReleasedVersion(Function\u003cVersion, Boolean\u003e isReleasedVersion)",
				"documentation": ""
			},
			{
				"signature": "public void apply(Project project)",
				"documentation": ""
			},
			{
				"signature": "private NamedDomainObjectContainer\u003cElasticsearchCluster\u003e createTestClustersContainerExtension(        Project project,        Provider\u003cReaperService\u003e reaper    )",
				"documentation": ""
			},
			{
				"signature": "private void createListClustersTask(Project project, NamedDomainObjectContainer\u003cElasticsearchCluster\u003e container)",
				"documentation": ""
			}
		],
		"interfaces": [
			"org.gradle.api.Plugin"
		]
	},
	{
		"documentation": "",
		"name": "org.elasticsearch.gradle.testclusters.TestClustersPlugin.TestClustersHookPlugin",
		"extends": "",
		"Methods": [
			{
				"signature": "public void apply(Project project)",
				"documentation": ""
			},
			{
				"signature": "private static void configureClaimClustersHook(Gradle gradle, TestClustersRegistry registry)",
				"documentation": ""
			},
			{
				"signature": "private static void configureStartClustersHook(Gradle gradle, TestClustersRegistry registry)",
				"documentation": ""
			},
			{
				"signature": "public void beforeActions(Task task)",
				"documentation": ""
			},
			{
				"signature": "public void afterActions(Task task)",
				"documentation": ""
			},
			{
				"signature": "private static void configureStopClustersHook(Gradle gradle, TestClustersRegistry registry)",
				"documentation": ""
			},
			{
				"signature": "public void afterExecute(Task task, TaskState state)",
				"documentation": ""
			},
			{
				"signature": "public void beforeExecute(Task task)",
				"documentation": ""
			}
		],
		"interfaces": [
			"org.gradle.api.Plugin"
		]
	},
	{
		"documentation": "",
		"name": "org.elasticsearch.gradle.testclusters.TestClustersRegistry",
		"extends": "",
		"Methods": [
			{
				"signature": "public void claimCluster(ElasticsearchCluster cluster)",
				"documentation": ""
			},
			{
				"signature": "public void maybeStartCluster(ElasticsearchCluster cluster)",
				"documentation": ""
			},
			{
				"signature": "public void stopCluster(ElasticsearchCluster cluster, boolean taskFailed)",
				"documentation": ""
			}
		],
		"interfaces": [
			"org.gradle.api.services.BuildService"
		]
	},
	{
		"documentation": "",
		"name": "org.elasticsearch.gradle.testclusters.TestClustersThrottle",
		"extends": "",
		"Methods": [],
		"interfaces": [
			"org.gradle.api.services.BuildService"
		]
	},
	{
		"documentation": "/**\n * An enumeration of the distributions that may be used in test clusters.\n */",
		"name": "org.elasticsearch.gradle.testclusters.TestDistribution",
		"extends": "",
		"Methods": [],
		"interfaces": []
	},
	{
		"documentation": "/**\n * A utility to wait for a specific HTTP resource to be available, optionally with customized TLS trusted CAs.\n * This is logically similar to using the Ant Get task to retrieve a resource, but with the difference that it can\n * access resources that do not use the JRE's default trusted CAs.\n */",
		"name": "org.elasticsearch.gradle.testclusters.WaitForHttpResource",
		"extends": "",
		"Methods": [
			{
				"signature": "public WaitForHttpResource(String protocol, String host, int numberOfNodes) throws MalformedURLException",
				"documentation": "/**\n * A utility to wait for a specific HTTP resource to be available, optionally with customized TLS trusted CAs.\n * This is logically similar to using the Ant Get task to retrieve a resource, but with the difference that it can\n * access resources that do not use the JRE's default trusted CAs.\n */"
			},
			{
				"signature": "public WaitForHttpResource(URL url)",
				"documentation": ""
			},
			{
				"signature": "public void setValidResponseCodes(int... validResponseCodes)",
				"documentation": ""
			},
			{
				"signature": "public void setCertificateAuthorities(File... certificateAuthorities)",
				"documentation": ""
			},
			{
				"signature": "public void setTrustStoreFile(File trustStoreFile)",
				"documentation": ""
			},
			{
				"signature": "public void setTrustStorePassword(String trustStorePassword)",
				"documentation": ""
			},
			{
				"signature": "public void setUsername(String username)",
				"documentation": ""
			},
			{
				"signature": "public void setPassword(String password)",
				"documentation": ""
			},
			{
				"signature": "public boolean wait(int durationInMs) throws GeneralSecurityException, InterruptedException, IOException",
				"documentation": ""
			},
			{
				"signature": "protected void checkResource(SSLContext ssl) throws IOException",
				"documentation": ""
			},
			{
				"signature": "HttpURLConnection buildConnection(SSLContext ssl) throws IOException",
				"documentation": ""
			},
			{
				"signature": "private void configureSslContext(HttpURLConnection connection, SSLContext ssl)",
				"documentation": ""
			},
			{
				"signature": "private void configureBasicAuth(HttpURLConnection connection)",
				"documentation": ""
			},
			{
				"signature": "KeyStore buildTrustStore() throws GeneralSecurityException, IOException",
				"documentation": ""
			},
			{
				"signature": "private KeyStore buildTrustStoreFromFile() throws GeneralSecurityException, IOException",
				"documentation": ""
			},
			{
				"signature": "private KeyStore buildTrustStoreFromCA() throws GeneralSecurityException, IOException",
				"documentation": ""
			},
			{
				"signature": "private SSLContext createSslContext(KeyStore trustStore) throws GeneralSecurityException",
				"documentation": ""
			},
			{
				"signature": "private void checkForTrustEntry(KeyStore trustStore) throws KeyStoreException",
				"documentation": ""
			}
		],
		"interfaces": []
	},
	{
		"documentation": "",
		"name": "org.elasticsearch.gradle.transform.SymbolicLinkPreservingUntarTransform",
		"extends": "",
		"Methods": [
			{
				"signature": "public void unpack(File tarFile, File targetDir, TransformOutputs outputs, boolean asFiletreeOutput) throws IOException",
				"documentation": ""
			}
		],
		"interfaces": [
			"UnpackTransform"
		]
	},
	{
		"documentation": "",
		"name": "org.elasticsearch.gradle.transform.UnzipTransform",
		"extends": "",
		"Methods": [
			{
				"signature": "public void unpack(File zipFile, File targetDir, TransformOutputs outputs, boolean asFiletreeOutput) throws IOException",
				"documentation": ""
			}
		],
		"interfaces": [
			"UnpackTransform"
		]
	},
	{
		"documentation": "",
		"name": "org.elasticsearch.gradle.util.FileUtils",
		"extends": "",
		"Methods": [
			{
				"signature": "public static void mkdirs(File dir)",
				"documentation": "/**\n     * Like {@link java.io.File#mkdirs()}, except throws an informative error if a dir cannot be created.\n     *\n     * @param dir The dir to create, including any non existent parent dirs.\n     */"
			},
			{
				"signature": "public static String read(File file, String encoding)",
				"documentation": ""
			},
			{
				"signature": "public static List\u003cString\u003e readLines(File file, String encoding)",
				"documentation": ""
			},
			{
				"signature": "public static void write(File outputFile, CharSequence content, String encoding)",
				"documentation": ""
			}
		],
		"interfaces": []
	},
	{
		"documentation": "",
		"name": "org.elasticsearch.gradle.util.GradleUtils",
		"extends": "",
		"Methods": [
			{
				"signature": "public static \u003cT\u003e Action\u003cT\u003e noop()",
				"documentation": ""
			},
			{
				"signature": "public static SourceSetContainer getJavaSourceSets(Project project)",
				"documentation": ""
			},
			{
				"signature": "public static void maybeConfigure(TaskContainer tasks, String name, Action\u003c? super Task\u003e config)",
				"documentation": ""
			},
			{
				"signature": "public static \u003cT extends Task\u003e void maybeConfigure(        TaskContainer tasks,        String name,        Class\u003c? extends T\u003e type,        Action\u003c? super T\u003e config    )",
				"documentation": ""
			},
			{
				"signature": "public static TaskProvider\u003c?\u003e findByName(TaskContainer tasks, String name)",
				"documentation": ""
			},
			{
				"signature": "public static \u003cT extends BuildService\u003c?\u003e\u003e Provider\u003cT\u003e getBuildService(BuildServiceRegistry registry, String name)",
				"documentation": ""
			},
			{
				"signature": "public static TaskProvider\u003cTest\u003e addTestSourceSet(Project project, String sourceSetName)",
				"documentation": "/**\n     * Add a source set and task of the same name that runs tests.\n     * \u003cp\u003e\n     * IDEs are also configured if setup, and the test task is added to check. The new test source\n     * set extends from the normal test source set to allow sharing of utilities.\n     *\n     * @return A task provider for the newly created test task\n     */"
			},
			{
				"signature": "public static void setupIdeForTestSourceSet(Project project, SourceSet testSourceSet)",
				"documentation": ""
			},
			{
				"signature": "public static void extendSourceSet(Project project, String parentSourceSetName, String childSourceSetName)",
				"documentation": "/**\n     * Extend the configurations of one source set from another.\n     */"
			},
			{
				"signature": "public static void extendSourceSet(Project project, String parentSourceSetName, String childSourceSetName, TaskProvider\u003cTest\u003e test)",
				"documentation": "/**\n     * Extends one configuration from another and refreshes the classpath of a provided Test.\n     * The Test parameter is only needed for eagerly defined test tasks.\n     */"
			},
			{
				"signature": "public static Dependency projectDependency(Project project, String projectPath, String projectConfig)",
				"documentation": ""
			},
			{
				"signature": "public static String getProjectPathFromTask(String taskPath)",
				"documentation": "/**\n     * To calculate the project path from a task path without relying on Task#getProject() which is discouraged during\n     * task execution time.\n     */"
			},
			{
				"signature": "public static boolean isModuleProject(String projectPath)",
				"documentation": ""
			},
			{
				"signature": "public static void disableTransitiveDependencies(Configuration config)",
				"documentation": ""
			},
			{
				"signature": "public static String projectPath(String taskPath)",
				"documentation": ""
			}
		],
		"interfaces": []
	},
	{
		"documentation": "",
		"name": "org.elasticsearch.gradle.util.Pair",
		"extends": "",
		"Methods": [
			{
				"signature": "public static \u003cL, R\u003e Pair\u003cL, R\u003e of(L left, R right)",
				"documentation": ""
			}
		],
		"interfaces": []
	},
	{
		"documentation": "",
		"name": "org.elasticsearch.gradle.util.PermissionUtils",
		"extends": "",
		"Methods": [
			{
				"signature": "public static void chmod(Path path, int mode) throws IOException",
				"documentation": ""
			},
			{
				"signature": "private static Set\u003cPosixFilePermission\u003e permissionsFromInt(int mode)",
				"documentation": ""
			},
			{
				"signature": "private static String permissions(final int permissions)",
				"documentation": ""
			}
		],
		"interfaces": []
	},
	{
		"documentation": "",
		"name": "org.elasticsearch.gradle.DistributionDownloadPluginTests",
		"extends": "org.elasticsearch.gradle.internal.test.GradleUnitTestCase",
		"Methods": [
			{
				"signature": "public void testVersionDefault()",
				"documentation": ""
			},
			{
				"signature": "public void testBadVersionFormat()",
				"documentation": ""
			},
			{
				"signature": "public void testTypeDefault()",
				"documentation": ""
			},
			{
				"signature": "public void testPlatformDefault()",
				"documentation": ""
			},
			{
				"signature": "public void testPlatformForIntegTest()",
				"documentation": ""
			},
			{
				"signature": "public void testBundledJdkDefault()",
				"documentation": ""
			},
			{
				"signature": "public void testBundledJdkForIntegTest()",
				"documentation": ""
			},
			{
				"signature": "private void assertDistroError(        Project project,        String name,        String version,        ElasticsearchDistributionType type,        Platform platform,        Boolean bundledJdk,        String message    )",
				"documentation": ""
			},
			{
				"signature": "private ElasticsearchDistribution checkDistro(        Project project,        String name,        String version,        ElasticsearchDistributionType type,        Platform platform,        Boolean bundledJdk    )",
				"documentation": ""
			},
			{
				"signature": "protected ElasticsearchDistribution createDistro(        Project project,        String name,        String version,        ElasticsearchDistributionType type,        ElasticsearchDistribution.Platform platform,        Boolean bundledJdk    )",
				"documentation": ""
			},
			{
				"signature": "protected Project createProject()",
				"documentation": ""
			}
		],
		"interfaces": []
	},
	{
		"documentation": "",
		"name": "org.elasticsearch.gradle.VersionTests",
		"extends": "org.elasticsearch.gradle.internal.test.GradleUnitTestCase",
		"Methods": [
			{
				"signature": "public void testVersionParsing()",
				"documentation": ""
			},
			{
				"signature": "public void testRelaxedVersionParsing()",
				"documentation": ""
			},
			{
				"signature": "public void testCompareWithStringVersions()",
				"documentation": ""
			},
			{
				"signature": "public void testCollections()",
				"documentation": ""
			},
			{
				"signature": "public void testToString()",
				"documentation": ""
			},
			{
				"signature": "public void testCompareVersions()",
				"documentation": ""
			},
			{
				"signature": "public void testExceptionEmpty()",
				"documentation": ""
			},
			{
				"signature": "public void testExceptionSyntax()",
				"documentation": ""
			},
			{
				"signature": "public void testQualifiers()",
				"documentation": ""
			},
			{
				"signature": "private void assertOrder(Version smaller, Version bigger)",
				"documentation": ""
			},
			{
				"signature": "private void assertVersionEquals(String stringVersion, int major, int minor, int revision)",
				"documentation": ""
			},
			{
				"signature": "private void assertVersionEquals(String stringVersion, int major, int minor, int revision, Version.Mode mode)",
				"documentation": ""
			}
		],
		"interfaces": []
	},
	{
		"documentation": "",
		"name": "org.elasticsearch.gradle.plugin.PluginPropertiesExtensionTests",
		"extends": "org.elasticsearch.gradle.internal.test.GradleUnitTestCase",
		"Methods": [
			{
				"signature": "public void testCreatingPluginPropertiesExtensionWithNameAndVersion()",
				"documentation": ""
			},
			{
				"signature": "public void testCreatingPluginPropertiesExtensionWithNameWithoutVersion()",
				"documentation": ""
			},
			{
				"signature": "private Project createProject(String projectName, String version)",
				"documentation": ""
			}
		],
		"interfaces": []
	},
	{
		"documentation": "",
		"name": "org.elasticsearch.gradle.testclusters.WaitForHttpResourceTests",
		"extends": "org.elasticsearch.gradle.internal.test.GradleUnitTestCase",
		"Methods": [
			{
				"signature": "public void testBuildTrustStoreFromFile() throws Exception",
				"documentation": ""
			},
			{
				"signature": "public void testBuildTrustStoreFromCA() throws Exception",
				"documentation": ""
			}
		],
		"interfaces": []
	},
	{
		"documentation": "",
		"name": "org.elasticsearch.gradle.internal.test.BaseTestCase",
		"extends": "org.junit.Assert",
		"Methods": [
			{
				"signature": "public static \u003cT extends Throwable\u003e T expectThrows(Class\u003cT\u003e expectedType, ThrowingRunnable runnable)",
				"documentation": ""
			}
		],
		"interfaces": []
	},
	{
		"documentation": "",
		"name": "org.elasticsearch.gradle.internal.test.GradleIntegrationTestCase",
		"extends": "GradleUnitTestCase",
		"Methods": [
			{
				"signature": "protected File getProjectDir()",
				"documentation": ""
			},
			{
				"signature": "protected GradleRunner getGradleRunner()",
				"documentation": ""
			},
			{
				"signature": "protected File getBuildDir(String name)",
				"documentation": ""
			},
			{
				"signature": "protected void assertOutputContains(String output, String... lines)",
				"documentation": ""
			},
			{
				"signature": "protected void assertOutputContains(String output, Set\u003cString\u003e lines)",
				"documentation": ""
			},
			{
				"signature": "protected void assertOutputContains(String output, String line)",
				"documentation": ""
			},
			{
				"signature": "protected void assertOutputMissing(String output, String line)",
				"documentation": ""
			},
			{
				"signature": "protected void assertOutputMissing(String output, String... lines)",
				"documentation": ""
			},
			{
				"signature": "protected void assertTaskFailed(BuildResult result, String taskName)",
				"documentation": ""
			},
			{
				"signature": "protected void assertTaskSuccessful(BuildResult result, String... taskNames)",
				"documentation": ""
			},
			{
				"signature": "protected void assertTaskSkipped(BuildResult result, String... taskNames)",
				"documentation": ""
			},
			{
				"signature": "protected void assertTaskNoSource(BuildResult result, String... taskNames)",
				"documentation": ""
			},
			{
				"signature": "private void assertTaskOutcome(BuildResult result, String taskName, TaskOutcome taskOutcome)",
				"documentation": ""
			},
			{
				"signature": "protected void assertTaskUpToDate(BuildResult result, String... taskNames)",
				"documentation": ""
			},
			{
				"signature": "protected void assertNoDeprecationWarning(BuildResult result)",
				"documentation": ""
			},
			{
				"signature": "protected void assertBuildFileExists(BuildResult result, String projectName, String path)",
				"documentation": ""
			},
			{
				"signature": "protected void assertBuildFileDoesNotExists(BuildResult result, String projectName, String path)",
				"documentation": ""
			},
			{
				"signature": "protected String getLocalTestDownloadsPath()",
				"documentation": ""
			},
			{
				"signature": "private String getLocalTestPath(String propertyName)",
				"documentation": ""
			},
			{
				"signature": "public void assertOutputOnlyOnce(String output, String... text)",
				"documentation": ""
			}
		],
		"interfaces": []
	},
	{
		"documentation": "/**\n * Filter out threads controlled by gradle that may be created during unit tests.\n *\n * Currently this includes pooled threads for Exec as well as file system event watcher threads.\n */",
		"name": "org.elasticsearch.gradle.internal.test.GradleThreadsFilter",
		"extends": "",
		"Methods": [
			{
				"signature": "public boolean reject(Thread t)",
				"documentation": "/**\n * Filter out threads controlled by gradle that may be created during unit tests.\n *\n * Currently this includes pooled threads for Exec as well as file system event watcher threads.\n */"
			}
		],
		"interfaces": [
			"com.carrotsearch.randomizedtesting.ThreadFilter"
		]
	},
	{
		"documentation": "",
		"name": "org.elasticsearch.gradle.internal.test.GradleUnitTestCase",
		"extends": "BaseTestCase",
		"Methods": [],
		"interfaces": []
	},
	{
		"documentation": "",
		"name": "org.elasticsearch.gradle.internal.test.InternalAwareGradleRunner",
		"extends": "org.gradle.testkit.runner.GradleRunner",
		"Methods": [
			{
				"signature": "public InternalAwareGradleRunner(GradleRunner delegate)",
				"documentation": ""
			},
			{
				"signature": "public GradleRunner withGradleVersion(String gradleVersion)",
				"documentation": ""
			},
			{
				"signature": "public GradleRunner withGradleInstallation(File file)",
				"documentation": ""
			},
			{
				"signature": "public GradleRunner withGradleDistribution(URI uri)",
				"documentation": ""
			},
			{
				"signature": "public GradleRunner withTestKitDir(File file)",
				"documentation": ""
			},
			{
				"signature": "public File getProjectDir()",
				"documentation": ""
			},
			{
				"signature": "public GradleRunner withProjectDir(File projectDir)",
				"documentation": ""
			},
			{
				"signature": "public List\u003cString\u003e getArguments()",
				"documentation": ""
			},
			{
				"signature": "public GradleRunner withArguments(List\u003cString\u003e arguments)",
				"documentation": ""
			},
			{
				"signature": "public GradleRunner withArguments(String... arguments)",
				"documentation": ""
			},
			{
				"signature": "public List\u003c? extends File\u003e getPluginClasspath()",
				"documentation": ""
			},
			{
				"signature": "public GradleRunner withPluginClasspath() throws InvalidPluginMetadataException",
				"documentation": ""
			},
			{
				"signature": "public GradleRunner withPluginClasspath(Iterable\u003c? extends File\u003e iterable)",
				"documentation": ""
			},
			{
				"signature": "public boolean isDebug()",
				"documentation": ""
			},
			{
				"signature": "public GradleRunner withDebug(boolean b)",
				"documentation": ""
			},
			{
				"signature": "public Map\u003cString, String\u003e getEnvironment()",
				"documentation": ""
			},
			{
				"signature": "public GradleRunner withEnvironment(Map\u003cString, String\u003e map)",
				"documentation": ""
			},
			{
				"signature": "public GradleRunner forwardStdOutput(Writer writer)",
				"documentation": ""
			},
			{
				"signature": "public GradleRunner forwardStdError(Writer writer)",
				"documentation": ""
			},
			{
				"signature": "public GradleRunner forwardOutput()",
				"documentation": ""
			},
			{
				"signature": "public BuildResult build() throws InvalidRunnerConfigurationException, UnexpectedBuildFailure",
				"documentation": ""
			},
			{
				"signature": "public BuildResult buildAndFail() throws InvalidRunnerConfigurationException, UnexpectedBuildSuccess",
				"documentation": ""
			}
		],
		"interfaces": []
	},
	{
		"documentation": "/**\n * Backwards compatible test* method provider (public, non-static).\n *\n * copy of org.apache.lucene.util.LuceneJUnit3MethodProvider to avoid a dependency between build and test fw.\n */",
		"name": "org.elasticsearch.gradle.internal.test.JUnit3MethodProvider",
		"extends": "",
		"Methods": [
			{
				"signature": "public Collection\u003cMethod\u003e getTestMethods(Class\u003c?\u003e suiteClass, ClassModel classModel)",
				"documentation": "/**\n * Backwards compatible test* method provider (public, non-static).\n *\n * copy of org.apache.lucene.util.LuceneJUnit3MethodProvider to avoid a dependency between build and test fw.\n */"
			}
		],
		"interfaces": [
			"com.carrotsearch.randomizedtesting.TestMethodProvider"
		]
	},
	{
		"documentation": "",
		"name": "org.elasticsearch.gradle.internal.test.NormalizeOutputGradleRunner",
		"extends": "org.gradle.testkit.runner.GradleRunner",
		"Methods": [
			{
				"signature": "public NormalizeOutputGradleRunner(GradleRunner delegate, File projectRootDir)",
				"documentation": ""
			},
			{
				"signature": "public GradleRunner withGradleVersion(String gradleVersion)",
				"documentation": ""
			},
			{
				"signature": "public GradleRunner withGradleInstallation(File file)",
				"documentation": ""
			},
			{
				"signature": "public GradleRunner withGradleDistribution(URI uri)",
				"documentation": ""
			},
			{
				"signature": "public GradleRunner withTestKitDir(File file)",
				"documentation": ""
			},
			{
				"signature": "public File getProjectDir()",
				"documentation": ""
			},
			{
				"signature": "public GradleRunner withProjectDir(File projectDir)",
				"documentation": ""
			},
			{
				"signature": "public List\u003cString\u003e getArguments()",
				"documentation": ""
			},
			{
				"signature": "public GradleRunner withArguments(List\u003cString\u003e arguments)",
				"documentation": ""
			},
			{
				"signature": "public GradleRunner withArguments(String... arguments)",
				"documentation": ""
			},
			{
				"signature": "public List\u003c? extends File\u003e getPluginClasspath()",
				"documentation": ""
			},
			{
				"signature": "public GradleRunner withPluginClasspath() throws InvalidPluginMetadataException",
				"documentation": ""
			},
			{
				"signature": "public GradleRunner withPluginClasspath(Iterable\u003c? extends File\u003e iterable)",
				"documentation": ""
			},
			{
				"signature": "public boolean isDebug()",
				"documentation": ""
			},
			{
				"signature": "public GradleRunner withDebug(boolean b)",
				"documentation": ""
			},
			{
				"signature": "public Map\u003cString, String\u003e getEnvironment()",
				"documentation": ""
			},
			{
				"signature": "public GradleRunner withEnvironment(Map\u003cString, String\u003e map)",
				"documentation": ""
			},
			{
				"signature": "public GradleRunner forwardStdOutput(Writer writer)",
				"documentation": ""
			},
			{
				"signature": "public GradleRunner forwardStdError(Writer writer)",
				"documentation": ""
			},
			{
				"signature": "public GradleRunner forwardOutput()",
				"documentation": ""
			},
			{
				"signature": "public BuildResult build() throws InvalidRunnerConfigurationException, UnexpectedBuildFailure",
				"documentation": ""
			},
			{
				"signature": "public BuildResult buildAndFail() throws InvalidRunnerConfigurationException, UnexpectedBuildSuccess",
				"documentation": ""
			}
		],
		"interfaces": []
	},
	{
		"documentation": "",
		"name": "org.elasticsearch.gradle.internal.test.NormalizedBuildResult",
		"extends": "",
		"Methods": [
			{
				"signature": "NormalizedBuildResult(BuildResult delegate)",
				"documentation": ""
			},
			{
				"signature": "public String getOutput()",
				"documentation": ""
			},
			{
				"signature": "public List\u003cBuildTask\u003e getTasks()",
				"documentation": ""
			},
			{
				"signature": "public List\u003cBuildTask\u003e tasks(TaskOutcome taskOutcome)",
				"documentation": ""
			},
			{
				"signature": "public List\u003cString\u003e taskPaths(TaskOutcome taskOutcome)",
				"documentation": ""
			},
			{
				"signature": "public BuildTask task(String s)",
				"documentation": ""
			}
		],
		"interfaces": [
			"org.gradle.testkit.runner.BuildResult"
		]
	},
	{
		"documentation": "",
		"name": "org.elasticsearch.gradle.internal.test.TestUtils",
		"extends": "",
		"Methods": [
			{
				"signature": "public static String normalizeString(String input, File projectRootDir)",
				"documentation": ""
			}
		],
		"interfaces": []
	},
	{
		"documentation": "",
		"name": "org.elasticsearch.gradle.ReaperPluginIT",
		"extends": "org.elasticsearch.gradle.internal.test.GradleIntegrationTestCase",
		"Methods": [
			{
				"signature": "public String projectName()",
				"documentation": ""
			},
			{
				"signature": "public void testCanLaunchReaper()",
				"documentation": ""
			}
		],
		"interfaces": []
	},
	{
		"documentation": "",
		"name": "org.elasticsearch.gradle.internal.BuildPluginIT",
		"extends": "org.elasticsearch.gradle.internal.test.GradleIntegrationTestCase",
		"Methods": [
			{
				"signature": "public String projectName()",
				"documentation": ""
			},
			{
				"signature": "public void testPluginCanBeApplied()",
				"documentation": ""
			},
			{
				"signature": "public void testCheckTask()",
				"documentation": ""
			},
			{
				"signature": "public void testLicenseAndNotice() throws IOException",
				"documentation": ""
			}
		],
		"interfaces": []
	},
	{
		"documentation": "",
		"name": "org.elasticsearch.gradle.internal.ExportElasticsearchBuildResourcesTaskIT",
		"extends": "org.elasticsearch.gradle.internal.test.GradleIntegrationTestCase",
		"Methods": [
			{
				"signature": "public String projectName()",
				"documentation": ""
			},
			{
				"signature": "public void testUpToDateWithSourcesConfigured()",
				"documentation": ""
			},
			{
				"signature": "public void testOutputAsInput()",
				"documentation": ""
			},
			{
				"signature": "public void testIncorrectUsage()",
				"documentation": ""
			}
		],
		"interfaces": []
	},
	{
		"documentation": "",
		"name": "org.elasticsearch.gradle.internal.SymbolicLinkPreservingTarIT",
		"extends": "org.elasticsearch.gradle.internal.test.GradleIntegrationTestCase",
		"Methods": [
			{
				"signature": "public String projectName()",
				"documentation": ""
			},
			{
				"signature": "public void before() throws IOException",
				"documentation": ""
			},
			{
				"signature": "public void testBZip2Tar() throws IOException",
				"documentation": ""
			},
			{
				"signature": "public void testBZip2TarDoNotPreserveFileTimestamps() throws IOException",
				"documentation": ""
			},
			{
				"signature": "public void testGZipTar() throws IOException",
				"documentation": ""
			},
			{
				"signature": "public void testGZipTarDoNotPreserveFileTimestamps() throws IOException",
				"documentation": ""
			},
			{
				"signature": "public void testTar() throws IOException",
				"documentation": ""
			},
			{
				"signature": "public void testTarDoNotPreserveFileTimestamps() throws IOException",
				"documentation": ""
			},
			{
				"signature": "private void assertTar(final String extension, final FileInputStreamWrapper wrapper, boolean preserveFileTimestamps)        throws IOException",
				"documentation": ""
			},
			{
				"signature": "private void runBuild(final String task, final boolean preserveFileTimestamps)",
				"documentation": ""
			},
			{
				"signature": "private File getOutputFile(final String extension)",
				"documentation": ""
			}
		],
		"interfaces": []
	},
	{
		"documentation": "",
		"name": "org.elasticsearch.gradle.internal.test.TestClasspathUtils",
		"extends": "",
		"Methods": [
			{
				"signature": "public static void setupJarJdkClasspath(File projectRoot)",
				"documentation": ""
			},
			{
				"signature": "public static void setupJarJdkClasspath(File projectRoot, String errorMessage)",
				"documentation": ""
			},
			{
				"signature": "private static void generateJdkJarHellCheck(File projectRoot, Implementation mainImplementation)",
				"documentation": ""
			},
			{
				"signature": "private static File targetFile(File projectRoot)",
				"documentation": ""
			}
		],
		"interfaces": []
	},
	{
		"documentation": "",
		"name": "org.elasticsearch.gradle.internal.test.TestClasspathUtils.InconsistentParameterReferenceMethod",
		"extends": "",
		"Methods": [
			{
				"signature": "public ByteCodeAppender appender(Target implementationTarget)",
				"documentation": ""
			},
			{
				"signature": "public InstrumentedType prepare(InstrumentedType instrumentedType)",
				"documentation": ""
			}
		],
		"interfaces": [
			"net.bytebuddy.implementation.Implementation"
		]
	},
	{
		"documentation": "",
		"name": "org.elasticsearch.gradle.internal.test.TestClasspathUtils.JdkJarHellBase",
		"extends": "",
		"Methods": [
			{
				"signature": "public static void main(String[] args)",
				"documentation": ""
			}
		],
		"interfaces": []
	},
	{
		"documentation": "",
		"name": "org.elasticsearch.gradle.jarhell.TestingConventionsTasksIT",
		"extends": "org.elasticsearch.gradle.internal.test.GradleIntegrationTestCase",
		"Methods": [
			{
				"signature": "public String projectName()",
				"documentation": ""
			},
			{
				"signature": "public void testInnerClasses()",
				"documentation": ""
			},
			{
				"signature": "public void testNamingConvention()",
				"documentation": ""
			},
			{
				"signature": "public void testNoEmptyTasks()",
				"documentation": ""
			},
			{
				"signature": "public void testAllTestTasksIncluded()",
				"documentation": ""
			},
			{
				"signature": "public void testTaskNotImplementBaseClass()",
				"documentation": ""
			},
			{
				"signature": "public void testValidSetupWithoutBaseClass()",
				"documentation": ""
			},
			{
				"signature": "public void testValidSetupWithBaseClass()",
				"documentation": ""
			},
			{
				"signature": "public void testTestsInMain()",
				"documentation": ""
			}
		],
		"interfaces": []
	},
	{
		"documentation": "",
		"name": "org.elasticsearch.gradle.jarhell.ThirdPartyAuditTaskIT",
		"extends": "org.elasticsearch.gradle.internal.test.GradleIntegrationTestCase",
		"Methods": [
			{
				"signature": "public String projectName()",
				"documentation": ""
			},
			{
				"signature": "public void setUp() throws Exception",
				"documentation": ""
			},
			{
				"signature": "public void testElasticsearchIgnored()",
				"documentation": ""
			},
			{
				"signature": "public void testViolationFoundAndCompileOnlyIgnored()",
				"documentation": ""
			},
			{
				"signature": "public void testClassNotFoundAndCompileOnlyIgnored()",
				"documentation": ""
			},
			{
				"signature": "public void testJarHellWithJDK()",
				"documentation": ""
			},
			{
				"signature": "public void testElasticsearchIgnoredWithViolations()",
				"documentation": ""
			}
		],
		"interfaces": []
	},
	{
		"documentation": "/**\n * Base plugin for building internal plugins or modules. This plugin should only be directly applied by internal test-only plugins or\n * modules. That is, plugins not externally published and modules only included in snapshot builds. Otherwise\n * {@link InternalPluginBuildPlugin} should be used.\n */",
		"name": "org.elasticsearch.gradle.internal.BaseInternalPluginBuildPlugin",
		"extends": "",
		"Methods": [
			{
				"signature": "public void apply(Project project)",
				"documentation": "/**\n * Base plugin for building internal plugins or modules. This plugin should only be directly applied by internal test-only plugins or\n * modules. That is, plugins not externally published and modules only included in snapshot builds. Otherwise\n * {@link InternalPluginBuildPlugin} should be used.\n */"
			},
			{
				"signature": "public void doCall(Object it)",
				"documentation": "/**\n * Base plugin for building internal plugins or modules. This plugin should only be directly applied by internal test-only plugins or\n * modules. That is, plugins not externally published and modules only included in snapshot builds. Otherwise\n * {@link InternalPluginBuildPlugin} should be used.\n */"
			},
			{
				"signature": "public void doCall()",
				"documentation": ""
			},
			{
				"signature": "Optional\u003cString\u003e findModulePath(Project project, String pluginName)",
				"documentation": ""
			},
			{
				"signature": "protected static void addNoticeGeneration(final Project project, PluginPropertiesExtension extension)",
				"documentation": "/**\n     * Configure the pom for the main jar of this plugin\n     */"
			}
		],
		"interfaces": [
			"org.gradle.api.Plugin"
		]
	},
	{
		"documentation": "/**\n * Encapsulates build configuration for elasticsearch projects.\n */",
		"name": "org.elasticsearch.gradle.internal.BuildPlugin",
		"extends": "",
		"Methods": [
			{
				"signature": "BuildPlugin(BuildLayout buildLayout, ObjectFactory objectFactory, ProviderFactory providerFactory, ProjectLayout projectLayout)",
				"documentation": "/**\n * Encapsulates build configuration for elasticsearch projects.\n */"
			},
			{
				"signature": "public void apply(final Project project)",
				"documentation": ""
			},
			{
				"signature": "public void configureLicenseAndNotice(final Project project)",
				"documentation": ""
			},
			{
				"signature": "private void updateJarTasksMetaInf(Project project)",
				"documentation": ""
			},
			{
				"signature": "private void configureLicenseDefaultConvention(RegularFileProperty licenseFileProperty)",
				"documentation": ""
			},
			{
				"signature": "private void configureNoticeDefaultConvention(RegularFileProperty noticeFileProperty)",
				"documentation": ""
			}
		],
		"interfaces": [
			"org.gradle.api.Plugin"
		]
	},
	{
		"documentation": "",
		"name": "org.elasticsearch.gradle.internal.BwcGitExtension",
		"extends": "",
		"Methods": [
			{
				"signature": "public BwcGitExtension(ObjectFactory objectFactory)",
				"documentation": ""
			},
			{
				"signature": "public Provider\u003cVersion\u003e getBwcVersion()",
				"documentation": ""
			},
			{
				"signature": "public void setBwcVersion(Provider\u003cVersion\u003e bwcVersion)",
				"documentation": ""
			},
			{
				"signature": "public Provider\u003cString\u003e getBwcBranch()",
				"documentation": ""
			},
			{
				"signature": "public void setBwcBranch(Provider\u003cString\u003e bwcBranch)",
				"documentation": ""
			},
			{
				"signature": "public Property\u003cFile\u003e getCheckoutDir()",
				"documentation": ""
			}
		],
		"interfaces": []
	},
	{
		"documentation": "/**\n * By registering bwc tasks via this extension we can support declaring custom bwc tasks from the build script\n * without relying on groovy closures and sharing common logic for tasks created by the BwcSetup plugin already.\n */",
		"name": "org.elasticsearch.gradle.internal.BwcSetupExtension",
		"extends": "",
		"Methods": [
			{
				"signature": "public BwcSetupExtension(        Project project,        Provider\u003cBwcVersions.UnreleasedVersionInfo\u003e unreleasedVersionInfo,        Provider\u003cInternalDistributionBwcSetupPlugin.BwcTaskThrottle\u003e bwcTaskThrottleProvider,        Provider\u003cFile\u003e checkoutDir    )",
				"documentation": "/**\n * By registering bwc tasks via this extension we can support declaring custom bwc tasks from the build script\n * without relying on groovy closures and sharing common logic for tasks created by the BwcSetup plugin already.\n */"
			},
			{
				"signature": "TaskProvider\u003cLoggedExec\u003e bwcTask(String name, Action\u003cLoggedExec\u003e configuration)",
				"documentation": ""
			},
			{
				"signature": "private TaskProvider\u003cLoggedExec\u003e createRunBwcGradleTask(Project project, String name, Action\u003cLoggedExec\u003e configAction)",
				"documentation": ""
			},
			{
				"signature": "public void execute(Task t)",
				"documentation": ""
			},
			{
				"signature": "private String minimumCompilerVersionPath(Version bwcVersion)",
				"documentation": ""
			},
			{
				"signature": "private static String readFromFile(File file)",
				"documentation": ""
			}
		],
		"interfaces": []
	},
	{
		"documentation": "",
		"name": "org.elasticsearch.gradle.internal.BwcSetupExtension.IndentingOutputStream",
		"extends": "java.io.OutputStream",
		"Methods": [
			{
				"signature": "IndentingOutputStream(OutputStream delegate, Object version)",
				"documentation": ""
			},
			{
				"signature": "public void write(int b) throws IOException",
				"documentation": ""
			},
			{
				"signature": "public void write(int[] bytes, int offset, int length) throws IOException",
				"documentation": ""
			}
		],
		"interfaces": []
	},
	{
		"documentation": "/**\n * A container for elasticsearch supported version information used in BWC testing.\n * \u003cp\u003e\n * Parse the Java source file containing the versions declarations and use the known rules to figure out which are all\n * the version the current one is wire and index compatible with.\n * On top of this, figure out which of these are unreleased and provide the branch they can be built from.\n * \u003cp\u003e\n * Note that in this context, currentVersion is the unreleased version this build operates on.\n * At any point in time there will be at least three such versions and potentially four in the case of a staged release.\n * \u003cp\u003e\n * \u003cul\u003e\n * \u003cli\u003ethe current version on the `main` branch\u003c/li\u003e\n * \u003cli\u003ethe staged next \u003cb\u003eminor\u003c/b\u003e on the `M.N` branch\u003c/li\u003e\n * \u003cli\u003ethe unreleased \u003cb\u003ebugfix\u003c/b\u003e, `M.N-1` branch\u003c/li\u003e\n * \u003cli\u003ethe unreleased \u003cb\u003emaintenance\u003c/b\u003e, M-1.d.e ( d \u0026gt; 0, e \u0026gt; 0) on the `(M-1).d` branch\u003c/li\u003e\n * \u003c/ul\u003e\n * \u003cp\u003e\n * Each build is only concerned with versions before it, as those are the ones that need to be tested\n * for backwards compatibility. We never look forward, and don't add forward facing version number to branches of previous\n * version.\n * \u003cp\u003e\n * Each branch has a current version, and expected compatible versions are parsed from the server code's Version` class.\n * We can reliably figure out which the unreleased versions are due to the convention of always adding the next unreleased\n * version number to server in all branches when a version is released.\n * E.x when M.N.c is released M.N.c+1 is added to the Version class mentioned above in all the following branches:\n *  `M.N`, and `main` so we can reliably assume that the leafs of the version tree are unreleased.\n * This convention is enforced by checking the versions we consider to be unreleased against an\n * authoritative source (maven central).\n * We are then able to map the unreleased version to branches in git and Gradle projects that are capable of checking\n * out and building them, so we can include these in the testing plan as well.\n */",
		"name": "org.elasticsearch.gradle.internal.BwcVersions",
		"extends": "",
		"Methods": [
			{
				"signature": "public BwcVersions(List\u003cString\u003e versionLines)",
				"documentation": "/**\n * A container for elasticsearch supported version information used in BWC testing.\n * \u003cp\u003e\n * Parse the Java source file containing the versions declarations and use the known rules to figure out which are all\n * the version the current one is wire and index compatible with.\n * On top of this, figure out which of these are unreleased and provide the branch they can be built from.\n * \u003cp\u003e\n * Note that in this context, currentVersion is the unreleased version this build operates on.\n * At any point in time there will be at least three such versions and potentially four in the case of a staged release.\n * \u003cp\u003e\n * \u003cul\u003e\n * \u003cli\u003ethe current version on the `main` branch\u003c/li\u003e\n * \u003cli\u003ethe staged next \u003cb\u003eminor\u003c/b\u003e on the `M.N` branch\u003c/li\u003e\n * \u003cli\u003ethe unreleased \u003cb\u003ebugfix\u003c/b\u003e, `M.N-1` branch\u003c/li\u003e\n * \u003cli\u003ethe unreleased \u003cb\u003emaintenance\u003c/b\u003e, M-1.d.e ( d \u0026gt; 0, e \u0026gt; 0) on the `(M-1).d` branch\u003c/li\u003e\n * \u003c/ul\u003e\n * \u003cp\u003e\n * Each build is only concerned with versions before it, as those are the ones that need to be tested\n * for backwards compatibility. We never look forward, and don't add forward facing version number to branches of previous\n * version.\n * \u003cp\u003e\n * Each branch has a current version, and expected compatible versions are parsed from the server code's Version` class.\n * We can reliably figure out which the unreleased versions are due to the convention of always adding the next unreleased\n * version number to server in all branches when a version is released.\n * E.x when M.N.c is released M.N.c+1 is added to the Version class mentioned above in all the following branches:\n *  `M.N`, and `main` so we can reliably assume that the leafs of the version tree are unreleased.\n * This convention is enforced by checking the versions we consider to be unreleased against an\n * authoritative source (maven central).\n * We are then able to map the unreleased version to branches in git and Gradle projects that are capable of checking\n * out and building them, so we can include these in the testing plan as well.\n */"
			},
			{
				"signature": "public BwcVersions(Version currentVersionProperty, List\u003cVersionPair\u003e allVersions)",
				"documentation": ""
			},
			{
				"signature": "BwcVersions(List\u003cString\u003e versionLines, Version currentVersionProperty)",
				"documentation": ""
			},
			{
				"signature": "private static List\u003cVersionPair\u003e parseVersionLines(List\u003cString\u003e versionLines)",
				"documentation": ""
			},
			{
				"signature": "private void assertCurrentVersionMatchesParsed(Version currentVersionProperty)",
				"documentation": ""
			},
			{
				"signature": "public UnreleasedVersionInfo unreleasedInfo(Version version)",
				"documentation": "/**\n     * Returns info about the unreleased version, or {@code null} if the version is released.\n     */"
			},
			{
				"signature": "public void forPreviousUnreleased(Consumer\u003cUnreleasedVersionInfo\u003e consumer)",
				"documentation": ""
			},
			{
				"signature": "private String getBranchFor(Version version)",
				"documentation": ""
			},
			{
				"signature": "private Map\u003cVersion, UnreleasedVersionInfo\u003e computeUnreleased()",
				"documentation": ""
			},
			{
				"signature": "public List\u003cVersion\u003e getUnreleased()",
				"documentation": ""
			},
			{
				"signature": "private void addUnreleased(Set\u003cVersionPair\u003e unreleased, VersionPair current, int index)",
				"documentation": ""
			},
			{
				"signature": "public void compareToAuthoritative(List\u003cVersion\u003e authoritativeReleasedVersions)",
				"documentation": ""
			},
			{
				"signature": "private List\u003cVersion\u003e getReleased()",
				"documentation": ""
			},
			{
				"signature": "public List\u003cVersion\u003e getIndexCompatible()",
				"documentation": ""
			},
			{
				"signature": "public void withIndexCompatible(BiConsumer\u003cVersion, String\u003e versionAction)",
				"documentation": ""
			},
			{
				"signature": "public void withIndexCompatible(Predicate\u003cVersion\u003e filter, BiConsumer\u003cVersion, String\u003e versionAction)",
				"documentation": ""
			},
			{
				"signature": "public List\u003cVersion\u003e getWireCompatible()",
				"documentation": ""
			},
			{
				"signature": "public void withWireCompatible(BiConsumer\u003cVersion, String\u003e versionAction)",
				"documentation": ""
			},
			{
				"signature": "public void withWireCompatible(Predicate\u003cVersion\u003e filter, BiConsumer\u003cVersion, String\u003e versionAction)",
				"documentation": ""
			},
			{
				"signature": "private List\u003cVersion\u003e filterSupportedVersions(List\u003cVersion\u003e wireCompat)",
				"documentation": ""
			},
			{
				"signature": "public List\u003cVersion\u003e getUnreleasedIndexCompatible()",
				"documentation": ""
			},
			{
				"signature": "public List\u003cVersion\u003e getUnreleasedWireCompatible()",
				"documentation": ""
			},
			{
				"signature": "public Version getMinimumWireCompatibleVersion()",
				"documentation": ""
			}
		],
		"interfaces": []
	},
	{
		"documentation": "",
		"name": "org.elasticsearch.gradle.internal.public",
		"extends": "",
		"Methods": [],
		"interfaces": []
	},
	{
		"documentation": "",
		"name": "org.elasticsearch.gradle.internal.public",
		"extends": "",
		"Methods": [
			{
				"signature": "public int compareTo(VersionPair o)",
				"documentation": ""
			}
		],
		"interfaces": [
			"Comparable"
		]
	},
	{
		"documentation": "/**\n * Concatenates a list of files into one and removes duplicate lines.\n */",
		"name": "org.elasticsearch.gradle.internal.ConcatFilesTask",
		"extends": "org.gradle.api.DefaultTask",
		"Methods": [
			{
				"signature": "public ConcatFilesTask()",
				"documentation": "/**\n * Concatenates a list of files into one and removes duplicate lines.\n */"
			},
			{
				"signature": "public void setFiles(FileTree files)",
				"documentation": "/** line to add at the top of the target file */"
			},
			{
				"signature": "public FileTree getFiles()",
				"documentation": ""
			},
			{
				"signature": "public void setHeaderLine(String headerLine)",
				"documentation": ""
			},
			{
				"signature": "public String getHeaderLine()",
				"documentation": ""
			},
			{
				"signature": "public void setTarget(File target)",
				"documentation": ""
			},
			{
				"signature": "public File getTarget()",
				"documentation": ""
			},
			{
				"signature": "public List\u003cString\u003e getAdditionalLines()",
				"documentation": ""
			},
			{
				"signature": "public void setAdditionalLines(List\u003cString\u003e additionalLines)",
				"documentation": ""
			},
			{
				"signature": "public void concatFiles() throws IOException",
				"documentation": ""
			}
		],
		"interfaces": []
	},
	{
		"documentation": "",
		"name": "org.elasticsearch.gradle.internal.DependenciesGraphPlugin",
		"extends": "",
		"Methods": [
			{
				"signature": "public void apply(Project project)",
				"documentation": ""
			}
		],
		"interfaces": [
			"org.gradle.api.Plugin"
		]
	},
	{
		"documentation": "",
		"name": "org.elasticsearch.gradle.internal.DependenciesGraphPlugin.DependenciesGraphHookPlugin",
		"extends": "",
		"Methods": [
			{
				"signature": "public void apply(Project project)",
				"documentation": ""
			}
		],
		"interfaces": [
			"org.gradle.api.Plugin"
		]
	},
	{
		"documentation": "/**\n * A task to generate a dependency graph of our runtime dependencies and push that via\n * an API call to a given endpoint of a SCA tool/service.\n * The graph is built according to the specification in https://github.com/snyk/dep-graph#depgraphdata\n *\n * Due to the nature of our dependency resolution in gradle, we are abusing the aforementioned graph definition as\n * the graph we construct has a single root ( the subproject ) and all dependencies are children of that root,\n * irrespective of if they are direct dependencies or transitive ones ( that should be children of other children ).\n * Although we end up lacking some contextual information, this allows us to scan and monitor only the dependencies\n * that are bundled and used in runtime.\n */",
		"name": "org.elasticsearch.gradle.internal.DependenciesGraphTask",
		"extends": "org.gradle.api.DefaultTask",
		"Methods": [
			{
				"signature": "public String getUrl()",
				"documentation": "/**\n * A task to generate a dependency graph of our runtime dependencies and push that via\n * an API call to a given endpoint of a SCA tool/service.\n * The graph is built according to the specification in https://github.com/snyk/dep-graph#depgraphdata\n *\n * Due to the nature of our dependency resolution in gradle, we are abusing the aforementioned graph definition as\n * the graph we construct has a single root ( the subproject ) and all dependencies are children of that root,\n * irrespective of if they are direct dependencies or transitive ones ( that should be children of other children ).\n * Although we end up lacking some contextual information, this allows us to scan and monitor only the dependencies\n * that are bundled and used in runtime.\n */"
			},
			{
				"signature": "public void setUrl(String url)",
				"documentation": ""
			},
			{
				"signature": "public String getToken()",
				"documentation": ""
			},
			{
				"signature": "public void setToken(String token)",
				"documentation": ""
			},
			{
				"signature": "public Configuration getRuntimeConfiguration()",
				"documentation": ""
			},
			{
				"signature": "public void setRuntimeConfiguration(Configuration runtimeConfiguration)",
				"documentation": ""
			},
			{
				"signature": "public DependenciesGraphTask(StartParameter startParameter)",
				"documentation": ""
			},
			{
				"signature": "void generateDependenciesGraph()",
				"documentation": ""
			}
		],
		"interfaces": []
	},
	{
		"documentation": "",
		"name": "org.elasticsearch.gradle.internal.DependenciesInfoPlugin",
		"extends": "",
		"Methods": [
			{
				"signature": "public void apply(final Project project)",
				"documentation": ""
			}
		],
		"interfaces": [
			"org.gradle.api.Plugin"
		]
	},
	{
		"documentation": "/**\n * A task to gather information about the dependencies and export them into a csv file.\n * \u003cp\u003e\n * The following information is gathered:\n * \u003cul\u003e\n *     \u003cli\u003ename: name that identifies the library (groupId:artifactId)\u003c/li\u003e\n *     \u003cli\u003eversion\u003c/li\u003e\n *     \u003cli\u003eURL: link to have more information about the dependency.\u003c/li\u003e\n *     \u003cli\u003elicense: \u003ca href=\"https://spdx.org/licenses/\"\u003eSPDX license\u003c/a\u003e identifier, custom license or UNKNOWN.\u003c/li\u003e\n * \u003c/ul\u003e\n */",
		"name": "org.elasticsearch.gradle.internal.DependenciesInfoTask",
		"extends": "org.gradle.api.internal.ConventionTask",
		"Methods": [
			{
				"signature": "public Configuration getRuntimeConfiguration()",
				"documentation": "/**\n * A task to gather information about the dependencies and export them into a csv file.\n * \u003cp\u003e\n * The following information is gathered:\n * \u003cul\u003e\n *     \u003cli\u003ename: name that identifies the library (groupId:artifactId)\u003c/li\u003e\n *     \u003cli\u003eversion\u003c/li\u003e\n *     \u003cli\u003eURL: link to have more information about the dependency.\u003c/li\u003e\n *     \u003cli\u003elicense: \u003ca href=\"https://spdx.org/licenses/\"\u003eSPDX license\u003c/a\u003e identifier, custom license or UNKNOWN.\u003c/li\u003e\n * \u003c/ul\u003e\n */"
			},
			{
				"signature": "public void setRuntimeConfiguration(Configuration runtimeConfiguration)",
				"documentation": ""
			},
			{
				"signature": "public Configuration getCompileOnlyConfiguration()",
				"documentation": ""
			},
			{
				"signature": "public void setCompileOnlyConfiguration(Configuration compileOnlyConfiguration)",
				"documentation": ""
			},
			{
				"signature": "public DirectoryProperty getLicensesDir()",
				"documentation": "/**\n     * Directory to read license files\n     */"
			},
			{
				"signature": "public void setLicensesDir(File licensesDir)",
				"documentation": ""
			},
			{
				"signature": "public File getOutputFile()",
				"documentation": ""
			},
			{
				"signature": "public void setOutputFile(File outputFile)",
				"documentation": ""
			},
			{
				"signature": "public DependenciesInfoTask(ProjectLayout projectLayout, ObjectFactory objectFactory, ProviderFactory providerFactory)",
				"documentation": "/**\n     * We subtract compile-only dependencies.\n     */"
			},
			{
				"signature": "public void generateDependenciesInfo() throws IOException",
				"documentation": ""
			},
			{
				"signature": "public LinkedHashMap\u003cString, String\u003e getMappings()",
				"documentation": ""
			},
			{
				"signature": "public void setMappings(LinkedHashMap\u003cString, String\u003e mappings)",
				"documentation": ""
			},
			{
				"signature": "protected String createURL(final String group, final String name, final String version)",
				"documentation": "/**\n     * Create an URL on \u003ca href=\"https://repo1.maven.org/maven2/\"\u003eMaven Central\u003c/a\u003e\n     * based on dependency coordinates.\n     */"
			},
			{
				"signature": "protected String getLicenseType(final String group, final String name) throws IOException",
				"documentation": "/**\n     * Read the LICENSE file associated with the dependency and determine a license type.\n     * \u003cp\u003e\n     * The license type is one of the following values:\n     * \u003cul\u003e\n     * \u003cli\u003e\u003cem\u003eUNKNOWN\u003c/em\u003e if LICENSE file is not present for this dependency.\u003c/li\u003e\n     * \u003cli\u003e\u003cem\u003eone SPDX identifier\u003c/em\u003e if the LICENSE content matches with an SPDX license.\u003c/li\u003e\n     * \u003cli\u003e\u003cem\u003eCustom;URL\u003c/em\u003e if it's not an SPDX license,\n     * URL is the Github URL to the LICENSE file in elasticsearch repository.\u003c/li\u003e\n     * \u003c/ul\u003e\n     *\n     * @param group dependency group\n     * @param name  dependency name\n     * @return SPDX identifier, UNKNOWN or a Custom license\n     */"
			},
			{
				"signature": "protected File getDependencyInfoFile(final String group, final String name, final String infoFileSuffix)",
				"documentation": ""
			}
		],
		"interfaces": []
	},
	{
		"documentation": "",
		"name": "org.elasticsearch.gradle.internal.DistributionArchive",
		"extends": "",
		"Methods": [
			{
				"signature": "public DistributionArchive(TaskProvider\u003c? extends AbstractArchiveTask\u003e archiveTask, TaskProvider\u003cSync\u003e expandedDistTask, String name)",
				"documentation": ""
			},
			{
				"signature": "public void setArchiveClassifier(String classifier)",
				"documentation": ""
			},
			{
				"signature": "public void content(Supplier\u003cCopySpec\u003e p)",
				"documentation": ""
			},
			{
				"signature": "public String getName()",
				"documentation": ""
			},
			{
				"signature": "public TaskProvider\u003c? extends AbstractArchiveTask\u003e getArchiveTask()",
				"documentation": ""
			},
			{
				"signature": "public TaskProvider\u003cSync\u003e getExpandedDistTask()",
				"documentation": ""
			}
		],
		"interfaces": [
			"org.gradle.api.Named"
		]
	},
	{
		"documentation": "",
		"name": "org.elasticsearch.gradle.internal.DistributionArchiveCheckExtension",
		"extends": "",
		"Methods": [
			{
				"signature": "public DistributionArchiveCheckExtension(ObjectFactory factory)",
				"documentation": ""
			}
		],
		"interfaces": []
	},
	{
		"documentation": "/**\n * This class models the different Docker base images that are used to build Docker distributions of Elasticsearch.\n */",
		"name": "org.elasticsearch.gradle.internal.DockerBase",
		"extends": "",
		"Methods": [
			{
				"signature": "DockerBase(String image, String suffix)",
				"documentation": "/**\n * This class models the different Docker base images that are used to build Docker distributions of Elasticsearch.\n */"
			},
			{
				"signature": "public String getImage()",
				"documentation": ""
			},
			{
				"signature": "public String getSuffix()",
				"documentation": ""
			}
		],
		"interfaces": []
	},
	{
		"documentation": "/**\n * A wrapper around Gradle's Java Base plugin that applies our\n * common configuration for production code.\n */",
		"name": "org.elasticsearch.gradle.internal.ElasticsearchJavaBasePlugin",
		"extends": "",
		"Methods": [
			{
				"signature": "public void apply(Project project)",
				"documentation": "/**\n * A wrapper around Gradle's Java Base plugin that applies our\n * common configuration for production code.\n */"
			},
			{
				"signature": "public static void configureConfigurations(Project project)",
				"documentation": "/**\n     * Makes dependencies non-transitive.\n     * \u003cp\u003e\n     * Gradle allows setting all dependencies as non-transitive very easily.\n     * Sadly this mechanism does not translate into maven pom generation. In order\n     * to effectively make the pom act as if it has no transitive dependencies,\n     * we must exclude each transitive dependency of each direct dependency.\n     * \u003cp\u003e\n     * Determining the transitive deps of a dependency which has been resolved as\n     * non-transitive is difficult because the process of resolving removes the\n     * transitive deps. To sidestep this issue, we create a configuration per\n     * direct dependency version. This specially named and unique configuration\n     * will contain all of the transitive dependencies of this particular\n     * dependency. We can then use this configuration during pom generation\n     * to iterate the transitive dependencies and add excludes.\n     */"
			},
			{
				"signature": "private static void disableTransitiveDependenciesForSourceSet(Project project, SourceSet sourceSet)",
				"documentation": ""
			},
			{
				"signature": "public static void configureCompile(Project project)",
				"documentation": "/**\n     * Adds compiler settings to the project\n     */"
			},
			{
				"signature": "public static void configureInputNormalization(Project project)",
				"documentation": "/**\n     * Apply runtime classpath input normalization so that changes in JAR manifests don't break build cacheability\n     */"
			},
			{
				"signature": "private static Provider\u003cInteger\u003e releaseVersionProviderFromCompileTask(Project project, AbstractCompile compileTask)",
				"documentation": ""
			}
		],
		"interfaces": [
			"org.gradle.api.Plugin"
		]
	},
	{
		"documentation": "/**\n * A wrapper around Gradle's Java plugin that applies our\n * common configuration for production code.\n */",
		"name": "org.elasticsearch.gradle.internal.ElasticsearchJavaPlugin",
		"extends": "",
		"Methods": [
			{
				"signature": "public void apply(Project project)",
				"documentation": "/**\n * A wrapper around Gradle's Java plugin that applies our\n * common configuration for production code.\n */"
			},
			{
				"signature": "private static void testCompileOnlyDeps(Project project)",
				"documentation": ""
			},
			{
				"signature": "static void configureJars(Project project)",
				"documentation": "/**\n     * Adds additional manifest info to jars\n     */"
			},
			{
				"signature": "public void execute(Task task)",
				"documentation": "/**\n     * Adds additional manifest info to jars\n     */"
			},
			{
				"signature": "private static void configureJarManifest(Project project)",
				"documentation": ""
			},
			{
				"signature": "private static void configureJavadoc(Project project)",
				"documentation": ""
			}
		],
		"interfaces": [
			"org.gradle.api.Plugin"
		]
	},
	{
		"documentation": "/**\n * Applies commonly used settings to all Test tasks in the project\n */",
		"name": "org.elasticsearch.gradle.internal.ElasticsearchTestBasePlugin",
		"extends": "",
		"Methods": [
			{
				"signature": "public void apply(Project project)",
				"documentation": "/**\n * Applies commonly used settings to all Test tasks in the project\n */"
			},
			{
				"signature": "public void execute(Task t)",
				"documentation": ""
			}
		],
		"interfaces": [
			"org.gradle.api.Plugin"
		]
	},
	{
		"documentation": "/**\n * Creates an empty directory.\n */",
		"name": "org.elasticsearch.gradle.internal.EmptyDirTask",
		"extends": "org.gradle.api.DefaultTask",
		"Methods": [
			{
				"signature": "public void create()",
				"documentation": "/**\n     * Creates an empty directory with the configured permissions.\n     */"
			},
			{
				"signature": "public Chmod getChmod()",
				"documentation": ""
			},
			{
				"signature": "public File getDir()",
				"documentation": ""
			},
			{
				"signature": "public String getDirPath()",
				"documentation": ""
			},
			{
				"signature": "public void setDir(File dir)",
				"documentation": "/**\n     * @param dir The directory to create\n     */"
			},
			{
				"signature": "public int getDirMode()",
				"documentation": ""
			},
			{
				"signature": "public void setDirMode(int dirMode)",
				"documentation": "/**\n     * @param dirMode The permissions to apply to the new directory\n     */"
			}
		],
		"interfaces": []
	},
	{
		"documentation": "/**\n * Export Elasticsearch build resources to configurable paths\n * \u003cp\u003e\n * Wil overwrite existing files and create missing directories.\n * Useful for resources that that need to be passed to other processes trough the filesystem or otherwise can't be\n * consumed from the classpath.\n */",
		"name": "org.elasticsearch.gradle.internal.ExportElasticsearchBuildResourcesTask",
		"extends": "org.gradle.api.DefaultTask",
		"Methods": [
			{
				"signature": "public ExportElasticsearchBuildResourcesTask(ObjectFactory objects)",
				"documentation": "/**\n * Export Elasticsearch build resources to configurable paths\n * \u003cp\u003e\n * Wil overwrite existing files and create missing directories.\n * Useful for resources that that need to be passed to other processes trough the filesystem or otherwise can't be\n * consumed from the classpath.\n */"
			},
			{
				"signature": "public DirectoryProperty getOutputDir()",
				"documentation": ""
			},
			{
				"signature": "public Set\u003cString\u003e getResources()",
				"documentation": ""
			},
			{
				"signature": "public String getResourcesClasspath()",
				"documentation": ""
			},
			{
				"signature": "public void setOutputDir(File outputDir)",
				"documentation": ""
			},
			{
				"signature": "public void copy(String resource)",
				"documentation": ""
			},
			{
				"signature": "public void doExport()",
				"documentation": ""
			}
		],
		"interfaces": []
	},
	{
		"documentation": "",
		"name": "org.elasticsearch.gradle.internal.InternalAvailableTcpPortProviderPlugin",
		"extends": "",
		"Methods": [
			{
				"signature": "public void apply(Project project)",
				"documentation": ""
			}
		],
		"interfaces": [
			"org.gradle.api.Plugin"
		]
	},
	{
		"documentation": "",
		"name": "org.elasticsearch.gradle.internal.InternalAvailableTcpPortProviderPlugin.InternalAvailableTcpPortProviderRootPlugin",
		"extends": "",
		"Methods": [
			{
				"signature": "public void apply(Project project)",
				"documentation": ""
			}
		],
		"interfaces": [
			"org.gradle.api.Plugin"
		]
	},
	{
		"documentation": "",
		"name": "org.elasticsearch.gradle.internal.InternalBwcGitPlugin",
		"extends": "",
		"Methods": [
			{
				"signature": "public InternalBwcGitPlugin(ProviderFactory providerFactory, ExecOperations execOperations)",
				"documentation": ""
			},
			{
				"signature": "public void apply(Project project)",
				"documentation": ""
			},
			{
				"signature": "public BwcGitExtension getGitExtension()",
				"documentation": ""
			},
			{
				"signature": "private String maybeAlignedRefSpec(Logger logger, String defaultRefSpec)",
				"documentation": "/**\n     * We use a time based approach to make the bwc versions built deterministic and compatible with the current hash.\n     * Most of the time we want to test against latest, but when running delayed exhaustive tests or wanting\n     * reproducible builds we want this to be deterministic by using a hash that was the latest when the current\n     * commit was made.\n     * \u003cp\u003e\n     * This approach doesn't work with merge commits as these can introduce commits in the chronological order\n     * after the fact e.x. a merge done today can add commits dated with yesterday so the result will no longer be\n     * deterministic.\n     * \u003cp\u003e\n     * We don't use merge commits, but for additional safety we check that no such commits exist in the time period\n     * we are interested in.\n     * \u003cp\u003e\n     * Timestamps are at seconds resolution. rev-parse --before and --after are inclusive w.r.t the second\n     * passed as input. This means the results might not be deterministic in the current second, but this\n     * should not matter in practice.\n     */"
			},
			{
				"signature": "private void writeFile(File file, String content)",
				"documentation": ""
			},
			{
				"signature": "private String execInCheckoutDir(Action\u003cExecSpec\u003e execSpecConfig)",
				"documentation": ""
			},
			{
				"signature": "private static boolean isRemoteAvailable(Provider\u003cString\u003e remote, ByteArrayOutputStream output)",
				"documentation": ""
			}
		],
		"interfaces": [
			"org.gradle.api.Plugin"
		]
	},
	{
		"documentation": "",
		"name": "org.elasticsearch.gradle.internal.InternalDistributionArchiveCheckPlugin",
		"extends": "",
		"Methods": [
			{
				"signature": "public InternalDistributionArchiveCheckPlugin(ArchiveOperations archiveOperations)",
				"documentation": ""
			},
			{
				"signature": "public void apply(Project project)",
				"documentation": ""
			},
			{
				"signature": "private File calculateArchiveExtractionDir(Project project)",
				"documentation": ""
			},
			{
				"signature": "private static TaskProvider\u003cTask\u003e registerCheckMlCppNoticeTask(        Project project,        TaskProvider\u003cCopy\u003e checkExtraction,        DistributionArchiveCheckExtension extension    )",
				"documentation": ""
			},
			{
				"signature": "public void execute(Task task)",
				"documentation": ""
			},
			{
				"signature": "private TaskProvider\u003cTask\u003e registerCheckNoticeTask(Project project, TaskProvider\u003cCopy\u003e checkExtraction)",
				"documentation": ""
			},
			{
				"signature": "public void execute(Task task)",
				"documentation": ""
			},
			{
				"signature": "private TaskProvider\u003cTask\u003e registerCheckLicenseTask(Project project, TaskProvider\u003cCopy\u003e checkExtraction)",
				"documentation": ""
			},
			{
				"signature": "public void execute(Task task)",
				"documentation": ""
			},
			{
				"signature": "private TaskProvider\u003cCopy\u003e registerCheckExtractionTask(Project project, TaskProvider\u003cTask\u003e buildDistTask, File archiveExtractionDir)",
				"documentation": ""
			},
			{
				"signature": "private static void assertLinesInFile(Path path, List\u003cString\u003e expectedLines)",
				"documentation": ""
			},
			{
				"signature": "private static boolean toolExists(Project project)",
				"documentation": ""
			},
			{
				"signature": "private static void assertNoClassFile(File file)",
				"documentation": ""
			},
			{
				"signature": "private static boolean zipExists()",
				"documentation": ""
			},
			{
				"signature": "private static boolean tarExists()",
				"documentation": ""
			},
			{
				"signature": "private Object distTaskOutput(TaskProvider\u003cTask\u003e buildDistTask)",
				"documentation": ""
			},
			{
				"signature": "public File call()",
				"documentation": ""
			},
			{
				"signature": "public String toString()",
				"documentation": ""
			},
			{
				"signature": "private String calculateBuildTask(String projectName)",
				"documentation": ""
			}
		],
		"interfaces": [
			"InternalPlugin"
		]
	},
	{
		"documentation": "/**\n * Provides a DSL and common configurations to define different types of\n * Elasticsearch distribution archives. See ':distribution:archives'.\n * \u003cp\u003e\n * This configures the default artifacts for the distribution specific\n * subprojects. We have subprojects for two reasons:\n * 1. Gradle project substitutions can only bind to the default\n * configuration of a project\n * 2. The integ-test-zip and zip distributions have the exact same\n * filename, so they must be placed in different directories.\n * 3. We provide a packed and an unpacked variant of the distribution\n * - the unpacked variant is used by consumers like test cluster definitions\n * 4. Having per-distribution sub-projects means we can build them in parallel.\n */",
		"name": "org.elasticsearch.gradle.internal.InternalDistributionArchiveSetupPlugin",
		"extends": "",
		"Methods": [
			{
				"signature": "public void apply(Project project)",
				"documentation": "/**\n * Provides a DSL and common configurations to define different types of\n * Elasticsearch distribution archives. See ':distribution:archives'.\n * \u003cp\u003e\n * This configures the default artifacts for the distribution specific\n * subprojects. We have subprojects for two reasons:\n * 1. Gradle project substitutions can only bind to the default\n * configuration of a project\n * 2. The integ-test-zip and zip distributions have the exact same\n * filename, so they must be placed in different directories.\n * 3. We provide a packed and an unpacked variant of the distribution\n * - the unpacked variant is used by consumers like test cluster definitions\n * 4. Having per-distribution sub-projects means we can build them in parallel.\n */"
			},
			{
				"signature": "private void registerAndConfigureDistributionArchivesExtension(Project project)",
				"documentation": ""
			},
			{
				"signature": "private void configureGeneralTaskDefaults(Project project)",
				"documentation": ""
			},
			{
				"signature": "private void configureTarDefaults(Project project)",
				"documentation": ""
			},
			{
				"signature": "private void registerEmptyDirectoryTasks(Project project)",
				"documentation": ""
			},
			{
				"signature": "private static String archiveTaskToSubprojectName(String taskName)",
				"documentation": ""
			},
			{
				"signature": "private static String archiveToSubprojectName(String taskName)",
				"documentation": ""
			}
		],
		"interfaces": [
			"InternalPlugin"
		]
	},
	{
		"documentation": "/**\n * We want to be able to do BWC tests for unreleased versions without relying on and waiting for snapshots.\n * For this we need to check out and build the unreleased versions.\n * Since these depend on the current version, we can't name the Gradle projects statically, and don't know what the\n * unreleased versions are when Gradle projects are set up, so we use \"build-unreleased-version-*\" as placeholders\n * and configure them to build various versions here.\n */",
		"name": "org.elasticsearch.gradle.internal.InternalDistributionBwcSetupPlugin",
		"extends": "",
		"Methods": [
			{
				"signature": "public InternalDistributionBwcSetupPlugin(ProviderFactory providerFactory)",
				"documentation": "/**\n * We want to be able to do BWC tests for unreleased versions without relying on and waiting for snapshots.\n * For this we need to check out and build the unreleased versions.\n * Since these depend on the current version, we can't name the Gradle projects statically, and don't know what the\n * unreleased versions are when Gradle projects are set up, so we use \"build-unreleased-version-*\" as placeholders\n * and configure them to build various versions here.\n */"
			},
			{
				"signature": "public void apply(Project project)",
				"documentation": ""
			},
			{
				"signature": "private void configureBwcProject(        Project project,        BwcVersions.UnreleasedVersionInfo versionInfo,        Provider\u003cBwcTaskThrottle\u003e bwcTaskThrottleProvider    )",
				"documentation": ""
			},
			{
				"signature": "private void registerBwcDistributionArtifacts(Project bwcProject, DistributionProject distributionProject)",
				"documentation": ""
			},
			{
				"signature": "private void registerDistributionArchiveArtifact(Project bwcProject, DistributionProject distributionProject, String buildBwcTask)",
				"documentation": ""
			},
			{
				"signature": "private static List\u003cDistributionProject\u003e resolveArchiveProjects(File checkoutDir, Version bwcVersion)",
				"documentation": ""
			},
			{
				"signature": "private static String buildBwcTaskName(String projectName)",
				"documentation": ""
			},
			{
				"signature": "static void createBuildBwcTask(        BwcSetupExtension bwcSetupExtension,        Project project,        Provider\u003cVersion\u003e bwcVersion,        String projectName,        String projectPath,        DistributionProjectArtifact projectArtifact,        TaskProvider\u003cTask\u003e bwcTaskProvider,        String assembleTaskName    )",
				"documentation": ""
			},
			{
				"signature": "public void execute(Task task)",
				"documentation": ""
			}
		],
		"interfaces": [
			"InternalPlugin"
		]
	},
	{
		"documentation": "/**\n     * Represents a distribution project (distribution/**)\n     * we build from a bwc Version in a cloned repository\n     */",
		"name": "org.elasticsearch.gradle.internal.InternalDistributionBwcSetupPlugin.DistributionProject",
		"extends": "",
		"Methods": [
			{
				"signature": "DistributionProject(String name, String baseDir, Version version, String classifier, String extension, File checkoutDir)",
				"documentation": "/**\n         * can be removed once we don't build 7.10 anymore\n         * from source for bwc tests.\n         */"
			},
			{
				"signature": "public String getAssembleTaskName()",
				"documentation": "/**\n         * Newer elasticsearch branches allow building extracted bwc elasticsearch versions\n         * from source without the overhead of creating an archive by using assembleExtracted instead of assemble.\n         */"
			}
		],
		"interfaces": []
	},
	{
		"documentation": "",
		"name": "org.elasticsearch.gradle.internal.InternalDistributionBwcSetupPlugin.DistributionProjectArtifact",
		"extends": "",
		"Methods": [
			{
				"signature": "DistributionProjectArtifact(File distFile, File expandedDistDir)",
				"documentation": ""
			}
		],
		"interfaces": []
	},
	{
		"documentation": "",
		"name": "org.elasticsearch.gradle.internal.BwcTaskThrottle",
		"extends": "",
		"Methods": [],
		"interfaces": [
			"org.gradle.api.services.BuildService"
		]
	},
	{
		"documentation": "/**\n * An internal elasticsearch build plugin that registers additional\n * distribution resolution strategies to the 'elasticsearch.download-distribution' plugin\n * to resolve distributions from a local snapshot or a locally built bwc snapshot.\n */",
		"name": "org.elasticsearch.gradle.internal.InternalDistributionDownloadPlugin",
		"extends": "",
		"Methods": [
			{
				"signature": "public void apply(Project project)",
				"documentation": "/**\n * An internal elasticsearch build plugin that registers additional\n * distribution resolution strategies to the 'elasticsearch.download-distribution' plugin\n * to resolve distributions from a local snapshot or a locally built bwc snapshot.\n */"
			},
			{
				"signature": "private void registerInternalDistributionResolutions(NamedDomainObjectContainer\u003cDistributionResolution\u003e resolutions)",
				"documentation": "/**\n     * Registers internal distribution resolutions.\n     * \u003cp\u003e\n     * Elasticsearch distributions are resolved as project dependencies either representing\n     * the current version pointing to a project either under `:distribution:archives` or :distribution:packages`.\n     * \u003cp\u003e\n     * BWC versions are resolved as project to projects under `:distribution:bwc`.\n     */"
			},
			{
				"signature": "private boolean isCurrentVersion(ElasticsearchDistribution distribution)",
				"documentation": ""
			},
			{
				"signature": "private static String getProjectConfig(ElasticsearchDistribution distribution, BwcVersions.UnreleasedVersionInfo info)",
				"documentation": "/**\n     * Will be removed once this is backported to all unreleased branches.\n     */"
			},
			{
				"signature": "private static String distributionProjectPath(ElasticsearchDistribution distribution)",
				"documentation": ""
			},
			{
				"signature": "public String getExternalUseErrorMessage()",
				"documentation": ""
			},
			{
				"signature": "private static String distributionProjectName(ElasticsearchDistribution distribution)",
				"documentation": "/**\n     * Works out the gradle project name that provides a distribution artifact.\n     *\n     * @param distribution the distribution from which to derive a project name\n     * @return the name of a project. It is not the full project path, only the name.\n     */"
			}
		],
		"interfaces": [
			"InternalPlugin"
		]
	},
	{
		"documentation": "",
		"name": "org.elasticsearch.gradle.internal.InternalDistributionDownloadPlugin.ProjectBasedDistributionDependency",
		"extends": "",
		"Methods": [
			{
				"signature": "ProjectBasedDistributionDependency(Function\u003cString, Dependency\u003e function)",
				"documentation": ""
			},
			{
				"signature": "public Object getDefaultNotation()",
				"documentation": ""
			},
			{
				"signature": "public Object getExtractedNotation()",
				"documentation": ""
			}
		],
		"interfaces": [
			"org.elasticsearch.gradle.DistributionDependency"
		]
	},
	{
		"documentation": "",
		"name": "org.elasticsearch.gradle.internal.InternalPluginBuildPlugin",
		"extends": "",
		"Methods": [
			{
				"signature": "public void apply(Project project)",
				"documentation": ""
			}
		],
		"interfaces": [
			"InternalPlugin"
		]
	},
	{
		"documentation": "",
		"name": "org.elasticsearch.gradle.internal.InternalReaperPlugin",
		"extends": "",
		"Methods": [
			{
				"signature": "public InternalReaperPlugin(ProjectLayout projectLayout)",
				"documentation": ""
			},
			{
				"signature": "public void apply(Project project)",
				"documentation": ""
			}
		],
		"interfaces": [
			"org.gradle.api.Plugin"
		]
	},
	{
		"documentation": "",
		"name": "org.elasticsearch.gradle.internal.InternalTestArtifactBasePlugin",
		"extends": "",
		"Methods": [
			{
				"signature": "public InternalTestArtifactBasePlugin(ProviderFactory providerFactory)",
				"documentation": ""
			},
			{
				"signature": "public void apply(Project project)",
				"documentation": ""
			}
		],
		"interfaces": [
			"org.gradle.api.Plugin"
		]
	},
	{
		"documentation": "",
		"name": "org.elasticsearch.gradle.internal.InternalTestArtifactExtension",
		"extends": "",
		"Methods": [
			{
				"signature": "public InternalTestArtifactExtension(Project project, ProviderFactory providerFactory)",
				"documentation": ""
			},
			{
				"signature": "public void registerTestArtifactFromSourceSet(SourceSet sourceSet)",
				"documentation": ""
			}
		],
		"interfaces": []
	},
	{
		"documentation": "/**\n * Ideally, this plugin is intended to be temporary and in the long run we want to move\n * forward to port our test fixtures to use the gradle test fixtures plugin.\n * */",
		"name": "org.elasticsearch.gradle.internal.InternalTestArtifactPlugin",
		"extends": "",
		"Methods": [
			{
				"signature": "public void apply(Project project)",
				"documentation": "/**\n * Ideally, this plugin is intended to be temporary and in the long run we want to move\n * forward to port our test fixtures to use the gradle test fixtures plugin.\n * */"
			}
		],
		"interfaces": [
			"org.gradle.api.Plugin"
		]
	},
	{
		"documentation": "",
		"name": "org.elasticsearch.gradle.internal.InternalTestClustersPlugin",
		"extends": "",
		"Methods": [
			{
				"signature": "public InternalTestClustersPlugin(ProviderFactory providerFactory)",
				"documentation": ""
			},
			{
				"signature": "public void apply(Project project)",
				"documentation": ""
			}
		],
		"interfaces": [
			"org.gradle.api.Plugin"
		]
	},
	{
		"documentation": "/**\n * A task to manipulate an existing class file.\n */",
		"name": "org.elasticsearch.gradle.internal.JavaClassPublicifier",
		"extends": "org.gradle.api.DefaultTask",
		"Methods": [
			{
				"signature": "public JavaClassPublicifier(ObjectFactory objects)",
				"documentation": "/**\n * A task to manipulate an existing class file.\n */"
			},
			{
				"signature": "public List\u003cString\u003e getClassFiles()",
				"documentation": ""
			},
			{
				"signature": "public void setClassFiles(List\u003cString\u003e classFiles)",
				"documentation": ""
			},
			{
				"signature": "public DirectoryProperty getInputDir()",
				"documentation": ""
			},
			{
				"signature": "public DirectoryProperty getOutputDir()",
				"documentation": ""
			},
			{
				"signature": "public void adapt() throws IOException",
				"documentation": ""
			},
			{
				"signature": "private static void makeInnerClassPublic(ClassNode classNode, String innerClass)",
				"documentation": ""
			},
			{
				"signature": "private void writeClass(String classFile, ClassNode classNode) throws IOException",
				"documentation": ""
			},
			{
				"signature": "private void adjustClass(String classFile, Consumer\u003cClassNode\u003e adjustor) throws IOException",
				"documentation": ""
			}
		],
		"interfaces": []
	},
	{
		"documentation": "",
		"name": "org.elasticsearch.gradle.internal.Jdk",
		"extends": "",
		"Methods": [
			{
				"signature": "Jdk(String name, Configuration configuration, ObjectFactory objectFactory)",
				"documentation": ""
			},
			{
				"signature": "public String getName()",
				"documentation": ""
			},
			{
				"signature": "public String getVendor()",
				"documentation": ""
			},
			{
				"signature": "public void setVendor(final String vendor)",
				"documentation": ""
			},
			{
				"signature": "public String getVersion()",
				"documentation": ""
			},
			{
				"signature": "public void setVersion(String version)",
				"documentation": ""
			},
			{
				"signature": "public String getPlatform()",
				"documentation": ""
			},
			{
				"signature": "public void setPlatform(String platform)",
				"documentation": ""
			},
			{
				"signature": "public String getArchitecture()",
				"documentation": ""
			},
			{
				"signature": "public void setArchitecture(final String architecture)",
				"documentation": ""
			},
			{
				"signature": "public String getBaseVersion()",
				"documentation": ""
			},
			{
				"signature": "public String getMajor()",
				"documentation": ""
			},
			{
				"signature": "public String getBuild()",
				"documentation": ""
			},
			{
				"signature": "public String getHash()",
				"documentation": ""
			},
			{
				"signature": "public String getPath()",
				"documentation": ""
			},
			{
				"signature": "public String getConfigurationName()",
				"documentation": ""
			},
			{
				"signature": "public String toString()",
				"documentation": ""
			},
			{
				"signature": "public TaskDependency getBuildDependencies()",
				"documentation": ""
			},
			{
				"signature": "public Object getBinJavaPath()",
				"documentation": ""
			},
			{
				"signature": "public String toString()",
				"documentation": ""
			},
			{
				"signature": "public Object getJavaHomePath()",
				"documentation": ""
			},
			{
				"signature": "public String toString()",
				"documentation": ""
			},
			{
				"signature": "private String getHomeRoot()",
				"documentation": ""
			},
			{
				"signature": "void finalizeValues()",
				"documentation": ""
			},
			{
				"signature": "public Iterator\u003cFile\u003e iterator()",
				"documentation": ""
			},
			{
				"signature": "private void parseVersion(String version)",
				"documentation": ""
			}
		],
		"interfaces": [
			"org.gradle.api.Buildable",
			"Iterable"
		]
	},
	{
		"documentation": "",
		"name": "org.elasticsearch.gradle.internal.JdkDownloadPlugin",
		"extends": "",
		"Methods": [
			{
				"signature": "public void apply(Project project)",
				"documentation": ""
			},
			{
				"signature": "private void setupRepository(Project project, Jdk jdk)",
				"documentation": ""
			},
			{
				"signature": "public static NamedDomainObjectContainer\u003cJdk\u003e getContainer(Project project)",
				"documentation": ""
			},
			{
				"signature": "private static String dependencyNotation(Jdk jdk)",
				"documentation": ""
			},
			{
				"signature": "private static String groupName(Jdk jdk)",
				"documentation": ""
			}
		],
		"interfaces": [
			"org.gradle.api.Plugin"
		]
	},
	{
		"documentation": "/**\n * Writes data passed to this stream as log messages.\n *\n * The stream will be flushed whenever a newline is detected.\n * Allows setting an optional prefix before each line of output.\n */",
		"name": "org.elasticsearch.gradle.internal.LoggingOutputStream",
		"extends": "java.io.OutputStream",
		"Methods": [
			{
				"signature": "public void write(final int b) throws IOException",
				"documentation": "/** Offset of the end (semi-open) of unwritten data in the buffer */"
			},
			{
				"signature": "public void flush()",
				"documentation": ""
			}
		],
		"interfaces": []
	},
	{
		"documentation": "/**\n * A task to create a notice file which includes dependencies' notices.\n */",
		"name": "org.elasticsearch.gradle.internal.NoticeTask",
		"extends": "org.gradle.api.DefaultTask",
		"Methods": [
			{
				"signature": "public NoticeTask(BuildLayout buildLayout, ProjectLayout projectLayout, FileOperations fileOperations, ObjectFactory objectFactory)",
				"documentation": "/**\n     * Directories to include notices from\n     */"
			},
			{
				"signature": "public void licensesDir(File licensesDir)",
				"documentation": "/**\n     * Add notices from the specified directory.\n     */"
			},
			{
				"signature": "public void source(Object source)",
				"documentation": ""
			},
			{
				"signature": "public void source(SourceDirectorySet source)",
				"documentation": ""
			},
			{
				"signature": "public void generateNotice() throws IOException",
				"documentation": ""
			},
			{
				"signature": "public FileCollection getNoticeFiles()",
				"documentation": ""
			},
			{
				"signature": "private List\u003cFile\u003e existingLicenseDirs()",
				"documentation": ""
			},
			{
				"signature": "public FileCollection getSources()",
				"documentation": ""
			},
			{
				"signature": "public static void appendFile(File file, String name, String type, StringBuilder output)",
				"documentation": ""
			},
			{
				"signature": "public static void appendText(String text, final String name, final String type, StringBuilder output)",
				"documentation": ""
			},
			{
				"signature": "public File getInputFile()",
				"documentation": ""
			},
			{
				"signature": "public void setInputFile(File inputFile)",
				"documentation": ""
			},
			{
				"signature": "public File getOutputFile()",
				"documentation": ""
			},
			{
				"signature": "public void setOutputFile(File outputFile)",
				"documentation": ""
			}
		],
		"interfaces": []
	},
	{
		"documentation": "",
		"name": "org.elasticsearch.gradle.internal.RepositoriesSetupPlugin",
		"extends": "",
		"Methods": [
			{
				"signature": "public void apply(Project project)",
				"documentation": ""
			},
			{
				"signature": "public static void configureRepositories(Project project)",
				"documentation": "/**\n     * Adds repositories used by ES projects and dependencies\n     */"
			}
		],
		"interfaces": [
			"org.gradle.api.Plugin"
		]
	},
	{
		"documentation": "",
		"name": "org.elasticsearch.gradle.internal.ResolveAllDependencies",
		"extends": "org.gradle.api.DefaultTask",
		"Methods": [
			{
				"signature": "public ResolveAllDependencies(ObjectFactory objectFactory)",
				"documentation": ""
			},
			{
				"signature": "public FileCollection getResolvedArtifacts()",
				"documentation": ""
			},
			{
				"signature": "void resolveAll()",
				"documentation": ""
			},
			{
				"signature": "private static boolean canBeResolved(Configuration configuration)",
				"documentation": ""
			}
		],
		"interfaces": []
	},
	{
		"documentation": "/**\n * A custom archive task that assembles a tar archive that preserves symbolic links.\n *\n * This task is necessary because the built-in task {@link org.gradle.api.tasks.bundling.Tar} does not preserve symbolic links.\n */",
		"name": "org.elasticsearch.gradle.internal.SymbolicLinkPreservingTar",
		"extends": "org.gradle.api.tasks.bundling.Tar",
		"Methods": [
			{
				"signature": "protected CopyAction createCopyAction()",
				"documentation": "/**\n * A custom archive task that assembles a tar archive that preserves symbolic links.\n *\n * This task is necessary because the built-in task {@link org.gradle.api.tasks.bundling.Tar} does not preserve symbolic links.\n */"
			}
		],
		"interfaces": []
	},
	{
		"documentation": "",
		"name": "org.elasticsearch.gradle.internal.SymbolicLinkPreservingTar.SymbolicLinkPreservingTarCopyAction",
		"extends": "",
		"Methods": [
			{
				"signature": "SymbolicLinkPreservingTarCopyAction(            final Provider\u003cRegularFile\u003e tarFile,            final ArchiveOutputStreamFactory compressor,            final boolean isPreserveFileTimestamps        )",
				"documentation": ""
			},
			{
				"signature": "public WorkResult execute(final CopyActionProcessingStream stream)",
				"documentation": ""
			},
			{
				"signature": "private long getModTime(final FileCopyDetails details)",
				"documentation": ""
			}
		],
		"interfaces": [
			"org.gradle.api.internal.file.copy.CopyAction"
		]
	},
	{
		"documentation": "",
		"name": "org.elasticsearch.gradle.internal.SymbolicLinkPreservingTarStreamAction",
		"extends": "",
		"Methods": [
			{
				"signature": "SymbolicLinkPreservingTarStreamAction(final TarArchiveOutputStream tar)",
				"documentation": ""
			},
			{
				"signature": "public void processFile(final FileCopyDetailsInternal details)",
				"documentation": ""
			},
			{
				"signature": "private boolean isChildOfVisitedSymbolicLink(final FileCopyDetailsInternal details)",
				"documentation": ""
			},
			{
				"signature": "private boolean isChildOf(final File directory, final File file)",
				"documentation": ""
			},
			{
				"signature": "private boolean isSymbolicLink(final FileCopyDetailsInternal details)",
				"documentation": ""
			},
			{
				"signature": "private void visitSymbolicLink(final FileCopyDetailsInternal details)",
				"documentation": ""
			},
			{
				"signature": "private void visitDirectory(final FileCopyDetailsInternal details)",
				"documentation": ""
			},
			{
				"signature": "private void visitFile(final FileCopyDetailsInternal details)",
				"documentation": ""
			},
			{
				"signature": "private void handleProcessingException(final FileCopyDetailsInternal details, final IOException e)",
				"documentation": ""
			}
		],
		"interfaces": [
			"org.gradle.api.internal.file.CopyActionProcessingStreamAction"
		]
	},
	{
		"documentation": "",
		"name": "org.elasticsearch.gradle.internal.distribution.DebElasticsearchDistributionType",
		"extends": "",
		"Methods": [
			{
				"signature": "DebElasticsearchDistributionType()",
				"documentation": ""
			},
			{
				"signature": "public String getName()",
				"documentation": ""
			},
			{
				"signature": "public String getClassifier(ElasticsearchDistribution.Platform platform, Version version)",
				"documentation": ""
			}
		],
		"interfaces": [
			"org.elasticsearch.gradle.ElasticsearchDistributionType"
		]
	},
	{
		"documentation": "",
		"name": "org.elasticsearch.gradle.internal.distribution.DockerCloudElasticsearchDistributionType",
		"extends": "",
		"Methods": [
			{
				"signature": "DockerCloudElasticsearchDistributionType()",
				"documentation": ""
			},
			{
				"signature": "public String getName()",
				"documentation": ""
			},
			{
				"signature": "public boolean isDocker()",
				"documentation": ""
			}
		],
		"interfaces": [
			"org.elasticsearch.gradle.ElasticsearchDistributionType"
		]
	},
	{
		"documentation": "",
		"name": "org.elasticsearch.gradle.internal.distribution.DockerCloudEssElasticsearchDistributionType",
		"extends": "",
		"Methods": [
			{
				"signature": "DockerCloudEssElasticsearchDistributionType()",
				"documentation": ""
			},
			{
				"signature": "public String getName()",
				"documentation": ""
			},
			{
				"signature": "public boolean isDocker()",
				"documentation": ""
			}
		],
		"interfaces": [
			"org.elasticsearch.gradle.ElasticsearchDistributionType"
		]
	},
	{
		"documentation": "",
		"name": "org.elasticsearch.gradle.internal.distribution.DockerElasticsearchDistributionType",
		"extends": "",
		"Methods": [
			{
				"signature": "DockerElasticsearchDistributionType()",
				"documentation": ""
			},
			{
				"signature": "public String getName()",
				"documentation": ""
			},
			{
				"signature": "public boolean isDocker()",
				"documentation": ""
			}
		],
		"interfaces": [
			"org.elasticsearch.gradle.ElasticsearchDistributionType"
		]
	},
	{
		"documentation": "",
		"name": "org.elasticsearch.gradle.internal.distribution.DockerIronBankElasticsearchDistributionType",
		"extends": "",
		"Methods": [
			{
				"signature": "DockerIronBankElasticsearchDistributionType()",
				"documentation": ""
			},
			{
				"signature": "public String getName()",
				"documentation": ""
			},
			{
				"signature": "public boolean isDocker()",
				"documentation": ""
			}
		],
		"interfaces": [
			"org.elasticsearch.gradle.ElasticsearchDistributionType"
		]
	},
	{
		"documentation": "",
		"name": "org.elasticsearch.gradle.internal.distribution.DockerUbiElasticsearchDistributionType",
		"extends": "",
		"Methods": [
			{
				"signature": "DockerUbiElasticsearchDistributionType()",
				"documentation": ""
			},
			{
				"signature": "public String getName()",
				"documentation": ""
			},
			{
				"signature": "public boolean isDocker()",
				"documentation": ""
			}
		],
		"interfaces": [
			"org.elasticsearch.gradle.ElasticsearchDistributionType"
		]
	},
	{
		"documentation": "",
		"name": "org.elasticsearch.gradle.internal.distribution.ElasticsearchDistributionExtension",
		"extends": "",
		"Methods": [
			{
				"signature": "public ElasticsearchDistributionExtension(Project project)",
				"documentation": ""
			},
			{
				"signature": "private Configuration moduleZip(Project module)",
				"documentation": ""
			},
			{
				"signature": "public void copyModule(TaskProvider\u003cAbstractCopyTask\u003e copyTask, Project module)",
				"documentation": ""
			}
		],
		"interfaces": []
	},
	{
		"documentation": "/**\n * Provides an extension named 'distro' to provide common operations used when setting up and bundling\n * elasticsearch distributions. Having those here instead of in the build scripts makes testing and maintaining\n * this common functionality easier\n * */",
		"name": "org.elasticsearch.gradle.internal.distribution.ElasticsearchDistributionPlugin",
		"extends": "",
		"Methods": [
			{
				"signature": "public void apply(Project project)",
				"documentation": "/**\n * Provides an extension named 'distro' to provide common operations used when setting up and bundling\n * elasticsearch distributions. Having those here instead of in the build scripts makes testing and maintaining\n * this common functionality easier\n * */"
			}
		],
		"interfaces": [
			"org.gradle.api.Plugin"
		]
	},
	{
		"documentation": "",
		"name": "org.elasticsearch.gradle.internal.distribution.InternalElasticsearchDistributionTypes",
		"extends": "",
		"Methods": [],
		"interfaces": []
	},
	{
		"documentation": "",
		"name": "org.elasticsearch.gradle.internal.distribution.RpmElasticsearchDistributionType",
		"extends": "",
		"Methods": [
			{
				"signature": "RpmElasticsearchDistributionType()",
				"documentation": ""
			},
			{
				"signature": "public String getName()",
				"documentation": ""
			},
			{
				"signature": "public boolean shouldExtract()",
				"documentation": ""
			},
			{
				"signature": "public boolean isDocker()",
				"documentation": ""
			}
		],
		"interfaces": [
			"org.elasticsearch.gradle.ElasticsearchDistributionType"
		]
	},
	{
		"documentation": "/**\n * This task wraps up the details of building a Docker image, including adding a pull\n * mechanism that can retry, and emitting the image SHA as a task output.\n */",
		"name": "org.elasticsearch.gradle.internal.docker.DockerBuildTask",
		"extends": "org.gradle.api.DefaultTask",
		"Methods": [
			{
				"signature": "public DockerBuildTask(WorkerExecutor workerExecutor, ObjectFactory objectFactory, ProjectLayout projectLayout)",
				"documentation": "/**\n * This task wraps up the details of building a Docker image, including adding a pull\n * mechanism that can retry, and emitting the image SHA as a task output.\n */"
			},
			{
				"signature": "public void build()",
				"documentation": ""
			},
			{
				"signature": "public DirectoryProperty getDockerContext()",
				"documentation": ""
			},
			{
				"signature": "public String[] getTags()",
				"documentation": ""
			},
			{
				"signature": "public void setTags(String[] tags)",
				"documentation": ""
			},
			{
				"signature": "public boolean isPull()",
				"documentation": ""
			},
			{
				"signature": "public void setPull(boolean pull)",
				"documentation": ""
			},
			{
				"signature": "public boolean isNoCache()",
				"documentation": ""
			},
			{
				"signature": "public void setNoCache(boolean noCache)",
				"documentation": ""
			},
			{
				"signature": "public String[] getBaseImages()",
				"documentation": ""
			},
			{
				"signature": "public void setBaseImages(String[] baseImages)",
				"documentation": ""
			},
			{
				"signature": "public MapProperty\u003cString, String\u003e getBuildArgs()",
				"documentation": ""
			},
			{
				"signature": "public void setBuildArgs(MapProperty\u003cString, String\u003e buildArgs)",
				"documentation": ""
			},
			{
				"signature": "public RegularFileProperty getMarkerFile()",
				"documentation": ""
			}
		],
		"interfaces": []
	},
	{
		"documentation": "",
		"name": "org.elasticsearch.gradle.internal.docker.DockerBuildTask.DockerBuildAction",
		"extends": "",
		"Methods": [
			{
				"signature": "public DockerBuildAction(ExecOperations execOperations)",
				"documentation": ""
			},
			{
				"signature": "private void pullBaseImage(String baseImage)",
				"documentation": "/**\n         * Wraps `docker pull` in a retry loop, to try and provide some resilience against\n         * transient errors\n         * @param baseImage the image to pull.\n         */"
			},
			{
				"signature": "public void execute()",
				"documentation": ""
			},
			{
				"signature": "private String getImageChecksum(String imageTag)",
				"documentation": ""
			}
		],
		"interfaces": [
			"org.gradle.workers.WorkAction"
		]
	},
	{
		"documentation": "/**\n * Plugin providing {@link DockerSupportService} for detecting Docker installations and determining requirements for Docker-based\n * Elasticsearch build tasks.\n */",
		"name": "org.elasticsearch.gradle.internal.docker.DockerSupportPlugin",
		"extends": "",
		"Methods": [
			{
				"signature": "public void apply(Project project)",
				"documentation": "/**\n * Plugin providing {@link DockerSupportService} for detecting Docker installations and determining requirements for Docker-based\n * Elasticsearch build tasks.\n */"
			}
		],
		"interfaces": [
			"org.gradle.api.Plugin"
		]
	},
	{
		"documentation": "/**\n * Build service for detecting available Docker installation and checking for compatibility with Elasticsearch Docker image build\n * requirements. This includes a minimum version requirement, as well as the ability to run privileged commands.\n */",
		"name": "org.elasticsearch.gradle.internal.docker.DockerSupportService",
		"extends": "",
		"Methods": [
			{
				"signature": "public DockerSupportService(ExecOperations execOperations)",
				"documentation": ""
			},
			{
				"signature": "public DockerAvailability getDockerAvailability()",
				"documentation": "/**\n     * Searches for a functional Docker installation, and returns information about the search.\n     *\n     * @return the results of the search.\n     */"
			},
			{
				"signature": "private boolean dockerDaemonIsRunning(String lastResultOutput)",
				"documentation": ""
			},
			{
				"signature": "void failIfDockerUnavailable(List\u003cString\u003e tasks)",
				"documentation": "/**\n     * Given a list of tasks that requires Docker, check whether Docker is available, otherwise throw an exception.\n     *\n     * @throws GradleException if Docker is not available. The exception message gives the reason.\n     */"
			},
			{
				"signature": "private boolean isExcludedOs()",
				"documentation": ""
			},
			{
				"signature": "private List\u003cString\u003e getLinuxExclusionList()",
				"documentation": ""
			},
			{
				"signature": "static String deriveId(Map\u003cString, String\u003e values)",
				"documentation": ""
			},
			{
				"signature": "static Map\u003cString, String\u003e parseOsRelease(final List\u003cString\u003e osReleaseLines)",
				"documentation": ""
			}
		],
		"interfaces": [
			"org.gradle.api.services.BuildService"
		]
	},
	{
		"documentation": "/**\n * The methods in this class take a shell command and wrap it in retry logic, so that our\n * Docker builds can be more robust in the face of transient errors e.g. network issues.\n */",
		"name": "org.elasticsearch.gradle.internal.docker.ShellRetry",
		"extends": "",
		"Methods": [
			{
				"signature": "static String loop(String name, String command)",
				"documentation": "/**\n * The methods in this class take a shell command and wrap it in retry logic, so that our\n * Docker builds can be more robust in the face of transient errors e.g. network issues.\n */"
			},
			{
				"signature": "static String loop(String name, String command, int indentSize, String exitKeyword)",
				"documentation": ""
			}
		],
		"interfaces": []
	},
	{
		"documentation": "",
		"name": "org.elasticsearch.gradle.internal.docker.TransformLog4jConfigFilter",
		"extends": "java.io.FilterReader",
		"Methods": [
			{
				"signature": "public TransformLog4jConfigFilter(Reader in) throws IOException",
				"documentation": ""
			},
			{
				"signature": "private static String transform(Reader reader) throws IOException",
				"documentation": ""
			},
			{
				"signature": "static List\u003cString\u003e skipBlanks(List\u003cString\u003e lines)",
				"documentation": "/** Squeeze multiple empty lines into a single line. */"
			},
			{
				"signature": "static List\u003cString\u003e transformConfig(List\u003cString\u003e lines)",
				"documentation": ""
			}
		],
		"interfaces": []
	},
	{
		"documentation": "",
		"name": "org.elasticsearch.gradle.internal.info.BuildParams",
		"extends": "",
		"Methods": [
			{
				"signature": "public static void init(Consumer\u003cMutableBuildParams\u003e initializer)",
				"documentation": "/**\n     * Initialize global build parameters. This method accepts and a initialization function which in turn accepts a\n     * {@link MutableBuildParams}. Initialization can be done in \"stages\", therefore changes override existing values, and values from\n     * previous calls to {@link #init(Consumer)} carry forward. In cases where you want to clear existing values\n     * {@link MutableBuildParams#reset()} may be used.\n     *\n     * @param initializer Build parameter initializer\n     */"
			},
			{
				"signature": "public static File getRuntimeJavaHome()",
				"documentation": ""
			},
			{
				"signature": "public static Boolean getIsRuntimeJavaHomeSet()",
				"documentation": ""
			},
			{
				"signature": "public static List\u003cJavaHome\u003e getJavaVersions()",
				"documentation": ""
			},
			{
				"signature": "public static JavaVersion getMinimumCompilerVersion()",
				"documentation": ""
			},
			{
				"signature": "public static JavaVersion getMinimumRuntimeVersion()",
				"documentation": ""
			},
			{
				"signature": "public static JavaVersion getGradleJavaVersion()",
				"documentation": ""
			},
			{
				"signature": "public static JavaVersion getRuntimeJavaVersion()",
				"documentation": ""
			},
			{
				"signature": "public static String getRuntimeJavaDetails()",
				"documentation": ""
			},
			{
				"signature": "public static Boolean isInFipsJvm()",
				"documentation": ""
			},
			{
				"signature": "public static String getGitRevision()",
				"documentation": ""
			},
			{
				"signature": "public static String getGitOrigin()",
				"documentation": ""
			},
			{
				"signature": "public static ZonedDateTime getBuildDate()",
				"documentation": ""
			},
			{
				"signature": "public static BwcVersions getBwcVersions()",
				"documentation": ""
			},
			{
				"signature": "public static String getTestSeed()",
				"documentation": ""
			},
			{
				"signature": "public static Boolean isCi()",
				"documentation": ""
			},
			{
				"signature": "public static Integer getDefaultParallel()",
				"documentation": ""
			},
			{
				"signature": "public static boolean isSnapshotBuild()",
				"documentation": ""
			},
			{
				"signature": "private static \u003cT\u003e T value(T object)",
				"documentation": ""
			},
			{
				"signature": "private static String propertyName(String methodName)",
				"documentation": ""
			}
		],
		"interfaces": []
	},
	{
		"documentation": "",
		"name": "org.elasticsearch.gradle.internal.info.BuildParams.MutableBuildParams",
		"extends": "",
		"Methods": [
			{
				"signature": "private MutableBuildParams()",
				"documentation": ""
			},
			{
				"signature": "public void reset()",
				"documentation": "/**\n         * Resets any existing values from previous initializations.\n         */"
			},
			{
				"signature": "public void setRuntimeJavaHome(File runtimeJavaHome)",
				"documentation": ""
			},
			{
				"signature": "public void setIsRuntimeJavaHomeSet(boolean isRutimeJavaHomeSet)",
				"documentation": ""
			},
			{
				"signature": "public void setJavaVersions(List\u003cJavaHome\u003e javaVersions)",
				"documentation": ""
			},
			{
				"signature": "public void setMinimumCompilerVersion(JavaVersion minimumCompilerVersion)",
				"documentation": ""
			},
			{
				"signature": "public void setMinimumRuntimeVersion(JavaVersion minimumRuntimeVersion)",
				"documentation": ""
			},
			{
				"signature": "public void setGradleJavaVersion(JavaVersion gradleJavaVersion)",
				"documentation": ""
			},
			{
				"signature": "public void setRuntimeJavaVersion(JavaVersion runtimeJavaVersion)",
				"documentation": ""
			},
			{
				"signature": "public void setRuntimeJavaDetails(String runtimeJavaDetails)",
				"documentation": ""
			},
			{
				"signature": "public void setInFipsJvm(boolean inFipsJvm)",
				"documentation": ""
			},
			{
				"signature": "public void setGitRevision(String gitRevision)",
				"documentation": ""
			},
			{
				"signature": "public void setGitOrigin(String gitOrigin)",
				"documentation": ""
			},
			{
				"signature": "public void setBuildDate(ZonedDateTime buildDate)",
				"documentation": ""
			},
			{
				"signature": "public void setTestSeed(String testSeed)",
				"documentation": ""
			},
			{
				"signature": "public void setIsCi(boolean isCi)",
				"documentation": ""
			},
			{
				"signature": "public void setDefaultParallel(int defaultParallel)",
				"documentation": ""
			},
			{
				"signature": "public void setIsSnapshotBuild(final boolean isSnapshotBuild)",
				"documentation": ""
			},
			{
				"signature": "public void setBwcVersions(Provider\u003cBwcVersions\u003e bwcVersions)",
				"documentation": ""
			}
		],
		"interfaces": []
	},
	{
		"documentation": "",
		"name": "org.elasticsearch.gradle.internal.info.GlobalBuildInfoPlugin",
		"extends": "",
		"Methods": [
			{
				"signature": "public GlobalBuildInfoPlugin(        JavaInstallationRegistry javaInstallationRegistry,        JvmMetadataDetector metadataDetector,        ProviderFactory providers    )",
				"documentation": ""
			},
			{
				"signature": "public void apply(Project project)",
				"documentation": ""
			},
			{
				"signature": "private String formatJavaVendorDetails(JvmInstallationMetadata runtimeJdkMetaData)",
				"documentation": ""
			},
			{
				"signature": "private static BwcVersions resolveBwcVersions(File root)",
				"documentation": ""
			},
			{
				"signature": "private void logGlobalBuildInfo()",
				"documentation": ""
			},
			{
				"signature": "private JavaVersion determineJavaVersion(String description, File javaHome, JavaVersion requiredVersion)",
				"documentation": ""
			},
			{
				"signature": "private InstallationLocation getJavaInstallation(File javaHome)",
				"documentation": ""
			},
			{
				"signature": "private boolean isSameFile(File javaHome, InstallationLocation installationLocation)",
				"documentation": ""
			},
			{
				"signature": "private List\u003cJavaHome\u003e getAvailableJavaVersions()",
				"documentation": "/**\n     * We resolve all available java versions using auto detected by gradles tool chain\n     * To make transition more reliable we only take env var provided installations into account for now\n     */"
			},
			{
				"signature": "private Stream\u003cInstallationLocation\u003e getAvailableJavaInstallationLocationSteam()",
				"documentation": ""
			},
			{
				"signature": "private static String getTestSeed()",
				"documentation": ""
			},
			{
				"signature": "private static void throwInvalidJavaHomeException(String description, File javaHome, int expectedVersion, int actualVersion)",
				"documentation": ""
			},
			{
				"signature": "private static void assertMinimumCompilerVersion(JavaVersion minimumCompilerVersion)",
				"documentation": ""
			},
			{
				"signature": "private File findRuntimeJavaHome()",
				"documentation": ""
			},
			{
				"signature": "private String findJavaHome(String version)",
				"documentation": ""
			},
			{
				"signature": "private static String getJavaHomeEnvVarName(String version)",
				"documentation": ""
			},
			{
				"signature": "public static String getResourceContents(String resourcePath)",
				"documentation": ""
			}
		],
		"interfaces": [
			"org.gradle.api.Plugin"
		]
	},
	{
		"documentation": "",
		"name": "org.elasticsearch.gradle.internal.info.GlobalBuildInfoPlugin.ErrorTraceMetadataDetector",
		"extends": "",
		"Methods": [
			{
				"signature": "ErrorTraceMetadataDetector(JvmMetadataDetector delegate)",
				"documentation": ""
			},
			{
				"signature": "public JvmInstallationMetadata getMetadata(File file)",
				"documentation": ""
			}
		],
		"interfaces": [
			"org.gradle.internal.jvm.inspection.JvmMetadataDetector"
		]
	},
	{
		"documentation": "",
		"name": "org.elasticsearch.gradle.internal.info.JavaHome",
		"extends": "",
		"Methods": [
			{
				"signature": "private JavaHome(int version, Provider\u003cFile\u003e javaHome)",
				"documentation": ""
			},
			{
				"signature": "public static JavaHome of(int version, Provider\u003cFile\u003e javaHome)",
				"documentation": ""
			},
			{
				"signature": "public Integer getVersion()",
				"documentation": ""
			},
			{
				"signature": "public Provider\u003cFile\u003e getJavaHome()",
				"documentation": ""
			}
		],
		"interfaces": []
	},
	{
		"documentation": "/**\n * This implementation is used to fix gradle 8 compatibility of\n * the CheckForbiddenApis task which is built with gradle 4 support\n * in mind.\n * */",
		"name": "org.elasticsearch.gradle.internal.precommit.CheckForbiddenApisTask",
		"extends": "de.thetaphi.forbiddenapis.gradle.CheckForbiddenApis",
		"Methods": [
			{
				"signature": "public FileTree getClassFiles()",
				"documentation": "/**\n     * Add additional annotation to make this input gradle 8 compliant.\n     * Otherwise we see a deprecation warning here starting with gradle 7.4\n     * */"
			}
		],
		"interfaces": []
	},
	{
		"documentation": "",
		"name": "org.elasticsearch.gradle.internal.precommit.CheckstylePrecommitPlugin",
		"extends": "org.elasticsearch.gradle.internal.conventions.precommit.PrecommitPlugin",
		"Methods": [
			{
				"signature": "public TaskProvider\u003c? extends Task\u003e createTask(Project project)",
				"documentation": ""
			},
			{
				"signature": "public void execute(Task task)",
				"documentation": ""
			}
		],
		"interfaces": [
			"org.elasticsearch.gradle.internal.InternalPlugin"
		]
	},
	{
		"documentation": "",
		"name": "org.elasticsearch.gradle.internal.precommit.DependencyLicensesPrecommitPlugin",
		"extends": "org.elasticsearch.gradle.internal.conventions.precommit.PrecommitPlugin",
		"Methods": [
			{
				"signature": "public TaskProvider\u003c? extends Task\u003e createTask(Project project)",
				"documentation": ""
			}
		],
		"interfaces": [
			"org.elasticsearch.gradle.internal.InternalPlugin"
		]
	},
	{
		"documentation": "/**\n * A task to check licenses for dependencies.\n * \u003cp\u003e\n * There are two parts to the check:\n * \u003cul\u003e\n *   \u003cli\u003eLICENSE, NOTICE and SOURCES files\u003c/li\u003e\n *   \u003cli\u003eSHA checksums for each dependency jar\u003c/li\u003e\n * \u003c/ul\u003e\n * \u003cp\u003e\n * The directory to find the license and sha files in defaults to the dir @{code licenses}\n * in the project directory for this task. You can override this directory:\n * \u003cpre\u003e\n *   dependencyLicenses {\n *     licensesDir = getProject().file(\"mybetterlicensedir\")\n *   }\n * \u003c/pre\u003e\n * \u003cp\u003e\n * The jar files to check default to the dependencies from the default configuration. You\n * can override this, for example, to only check compile dependencies:\n * \u003cpre\u003e\n *   dependencyLicenses {\n *     dependencies = getProject().configurations.compile\n *   }\n * \u003c/pre\u003e\n * \u003cp\u003e\n * Every jar must have a {@code .sha1} file in the licenses dir. These can be managed\n * automatically using the {@code updateShas} helper task that is created along\n * with this task. It will add {@code .sha1} files for new jars that are in dependencies\n * and remove old {@code .sha1} files that are no longer needed.\n * \u003cp\u003e\n * Every jar must also have a LICENSE and NOTICE file. However, multiple jars can share\n * LICENSE and NOTICE files by mapping a pattern to the same name.\n * \u003cpre\u003e\n *   dependencyLicenses {\n *     mapping from: \u0026#47;lucene-.*\u0026#47;, to: \"lucene\"\n *   }\n * \u003c/pre\u003e\n * Dependencies using licenses with stricter distribution requirements (such as LGPL)\n * require a SOURCES file as well. The file should include a URL to a source distribution\n * for the dependency. This artifact will be redistributed by us with the release to\n * comply with the license terms.\n */",
		"name": "org.elasticsearch.gradle.internal.precommit.DependencyLicensesTask",
		"extends": "org.gradle.api.DefaultTask",
		"Methods": [
			{
				"signature": "public void mapping(Map\u003cString, String\u003e props)",
				"documentation": "/**\n     * Add a mapping from a regex pattern for the jar name, to a prefix to find\n     * the LICENSE and NOTICE file for that jar.\n     */"
			},
			{
				"signature": "public DependencyLicensesTask(ObjectFactory objects, ProjectLayout projectLayout)",
				"documentation": ""
			},
			{
				"signature": "public FileCollection getDependencies()",
				"documentation": ""
			},
			{
				"signature": "public void setDependencies(FileCollection dependencies)",
				"documentation": ""
			},
			{
				"signature": "public File getLicensesDir()",
				"documentation": ""
			},
			{
				"signature": "public void setLicensesDir(File licensesDir)",
				"documentation": ""
			},
			{
				"signature": "public void ignoreSha(String dep)",
				"documentation": "/**\n     * Add a rule which will skip SHA checking for the given dependency name. This should be used for\n     * locally build dependencies, which cause the sha to change constantly.\n     */"
			},
			{
				"signature": "public void ignoreFile(String file)",
				"documentation": "/**\n     * Add a file that should be ignored by the check. This should be used for additional license files not tied to jar dependency\n     */"
			},
			{
				"signature": "public void checkDependencies() throws IOException, NoSuchAlgorithmException",
				"documentation": ""
			},
			{
				"signature": "public Provider\u003cDirectory\u003e getOutputMarker()",
				"documentation": ""
			},
			{
				"signature": "private void failIfAnyMissing(String item, Boolean exists, String type)",
				"documentation": ""
			},
			{
				"signature": "private void checkDependencies(        Map\u003cString, Boolean\u003e licenses,        Map\u003cString, Boolean\u003e notices,        Map\u003cString, Boolean\u003e sources,        Set\u003cFile\u003e shaFiles    ) throws NoSuchAlgorithmException, IOException",
				"documentation": ""
			},
			{
				"signature": "private void validateSha(Set\u003cFile\u003e shaFiles, File dependency, String jarName, String depName) throws NoSuchAlgorithmException,        IOException",
				"documentation": ""
			},
			{
				"signature": "private String joinFilenames(Set\u003cFile\u003e shaFiles)",
				"documentation": ""
			},
			{
				"signature": "public static String getDependencyName(Map\u003cString, String\u003e mappings, String dependencyName)",
				"documentation": ""
			},
			{
				"signature": "private void checkSha(File jar, String jarName, Set\u003cFile\u003e shaFiles) throws NoSuchAlgorithmException, IOException",
				"documentation": ""
			},
			{
				"signature": "private void checkFile(String name, String jarName, Map\u003cString, Boolean\u003e counters, String type)",
				"documentation": ""
			},
			{
				"signature": "private String getFileName(String name, Map\u003cString, ?\u003e counters, String type)",
				"documentation": ""
			},
			{
				"signature": "public LinkedHashSet\u003cString\u003e getIgnoreFiles()",
				"documentation": ""
			},
			{
				"signature": "public LinkedHashMap\u003cString, String\u003e getMappings()",
				"documentation": ""
			},
			{
				"signature": "File getShaFile(String jarName)",
				"documentation": ""
			},
			{
				"signature": "Set\u003cFile\u003e getShaFiles()",
				"documentation": ""
			},
			{
				"signature": "String getSha1(File file) throws IOException, NoSuchAlgorithmException",
				"documentation": ""
			}
		],
		"interfaces": []
	},
	{
		"documentation": "",
		"name": "org.elasticsearch.gradle.internal.precommit.FilePermissionsPrecommitPlugin",
		"extends": "org.elasticsearch.gradle.internal.conventions.precommit.PrecommitPlugin",
		"Methods": [
			{
				"signature": "public FilePermissionsPrecommitPlugin(ProviderFactory providerFactory)",
				"documentation": ""
			},
			{
				"signature": "public TaskProvider\u003c? extends Task\u003e createTask(Project project)",
				"documentation": ""
			}
		],
		"interfaces": [
			"org.elasticsearch.gradle.internal.InternalPlugin"
		]
	},
	{
		"documentation": "/**\n * Checks source files for correct file permissions.\n */",
		"name": "org.elasticsearch.gradle.internal.precommit.FilePermissionsTask",
		"extends": "org.gradle.api.DefaultTask",
		"Methods": [
			{
				"signature": "public FilePermissionsTask(ProjectLayout projectLayout)",
				"documentation": "/**\n     * A pattern set of which files should be checked.\n     */"
			},
			{
				"signature": "private static boolean isExecutableFile(File file)",
				"documentation": ""
			},
			{
				"signature": "public FileCollection getFiles()",
				"documentation": "/**\n     * Returns the files this task will check\n     */"
			},
			{
				"signature": "public void checkInvalidPermissions() throws IOException",
				"documentation": ""
			},
			{
				"signature": "public File getOutputMarker()",
				"documentation": ""
			}
		],
		"interfaces": []
	},
	{
		"documentation": "",
		"name": "org.elasticsearch.gradle.internal.precommit.ForbiddenApisPrecommitPlugin",
		"extends": "org.elasticsearch.gradle.internal.conventions.precommit.PrecommitPlugin",
		"Methods": [
			{
				"signature": "public TaskProvider\u003c? extends Task\u003e createTask(Project project)",
				"documentation": ""
			},
			{
				"signature": "public Void call(Object... names)",
				"documentation": ""
			},
			{
				"signature": "public Void call(Object... names)",
				"documentation": ""
			}
		],
		"interfaces": [
			"org.elasticsearch.gradle.internal.InternalPlugin"
		]
	},
	{
		"documentation": "",
		"name": "org.elasticsearch.gradle.internal.precommit.ForbiddenPatternsPrecommitPlugin",
		"extends": "org.elasticsearch.gradle.internal.conventions.precommit.PrecommitPlugin",
		"Methods": [
			{
				"signature": "public ForbiddenPatternsPrecommitPlugin(ProviderFactory providerFactory)",
				"documentation": ""
			},
			{
				"signature": "public TaskProvider\u003c? extends Task\u003e createTask(Project project)",
				"documentation": ""
			}
		],
		"interfaces": [
			"org.elasticsearch.gradle.internal.InternalPlugin"
		]
	},
	{
		"documentation": "/**\n * Checks for patterns in source files for the project which are forbidden.\n */",
		"name": "org.elasticsearch.gradle.internal.precommit.ForbiddenPatternsTask",
		"extends": "org.gradle.api.DefaultTask",
		"Methods": [
			{
				"signature": "public ForbiddenPatternsTask(ProjectLayout projectLayout)",
				"documentation": ""
			},
			{
				"signature": "public FileCollection getFiles()",
				"documentation": ""
			},
			{
				"signature": "public void checkInvalidPatterns() throws IOException",
				"documentation": ""
			},
			{
				"signature": "public File getOutputMarker()",
				"documentation": ""
			},
			{
				"signature": "public Map\u003cString, String\u003e getPatterns()",
				"documentation": ""
			},
			{
				"signature": "public void exclude(String... excludes)",
				"documentation": ""
			},
			{
				"signature": "public void rule(Map\u003cString, String\u003e props)",
				"documentation": ""
			},
			{
				"signature": "Provider\u003cString\u003e getRootDirPath()",
				"documentation": ""
			}
		],
		"interfaces": []
	},
	{
		"documentation": "/**\n * Internal precommit plugins that adds elasticsearch project specific\n * checks to the common precommit plugin.\n */",
		"name": "org.elasticsearch.gradle.internal.precommit.InternalPrecommitTasks",
		"extends": "",
		"Methods": [
			{
				"signature": "public static void create(Project project, boolean withProductiveCode)",
				"documentation": "/**\n     * Adds a precommit task, which depends on non-test verification tasks.\n     */"
			}
		],
		"interfaces": []
	},
	{
		"documentation": "",
		"name": "org.elasticsearch.gradle.internal.precommit.JarHellPrecommitPlugin",
		"extends": "org.elasticsearch.gradle.internal.conventions.precommit.PrecommitPlugin",
		"Methods": [
			{
				"signature": "public TaskProvider\u003c? extends Task\u003e createTask(Project project)",
				"documentation": ""
			}
		],
		"interfaces": []
	},
	{
		"documentation": "",
		"name": "org.elasticsearch.gradle.internal.precommit.LicenseAnalyzer",
		"extends": "",
		"Methods": [
			{
				"signature": "public static LicenseInfo licenseType(File licenseFile)",
				"documentation": ""
			}
		],
		"interfaces": []
	},
	{
		"documentation": "",
		"name": "org.elasticsearch.gradle.internal.precommit.public",
		"extends": "",
		"Methods": [],
		"interfaces": []
	},
	{
		"documentation": "",
		"name": "org.elasticsearch.gradle.internal.precommit.private",
		"extends": "",
		"Methods": [
			{
				"signature": "public boolean matches(File licenseFile)",
				"documentation": ""
			}
		],
		"interfaces": []
	},
	{
		"documentation": "",
		"name": "org.elasticsearch.gradle.internal.precommit.LoggerUsagePrecommitPlugin",
		"extends": "org.elasticsearch.gradle.internal.conventions.precommit.PrecommitPlugin",
		"Methods": [
			{
				"signature": "public TaskProvider\u003c? extends Task\u003e createTask(Project project)",
				"documentation": ""
			}
		],
		"interfaces": [
			"org.elasticsearch.gradle.internal.InternalPlugin"
		]
	},
	{
		"documentation": "/**\n * Runs LoggerUsageCheck on a set of directories.\n */",
		"name": "org.elasticsearch.gradle.internal.precommit.LoggerUsageTask",
		"extends": "org.elasticsearch.gradle.internal.conventions.precommit.PrecommitTask",
		"Methods": [
			{
				"signature": "public LoggerUsageTask(ObjectFactory objectFactory)",
				"documentation": "/**\n * Runs LoggerUsageCheck on a set of directories.\n */"
			},
			{
				"signature": "public void runLoggerUsageTask()",
				"documentation": ""
			},
			{
				"signature": "public FileCollection getClasspath()",
				"documentation": ""
			},
			{
				"signature": "public void setClasspath(FileCollection classpath)",
				"documentation": ""
			},
			{
				"signature": "public FileCollection getClassDirectories()",
				"documentation": ""
			},
			{
				"signature": "public void addSourceSet(SourceSet sourceSet)",
				"documentation": ""
			}
		],
		"interfaces": []
	},
	{
		"documentation": "",
		"name": "org.elasticsearch.gradle.internal.precommit.LoggerUsageTask.LoggerUsageWorkAction",
		"extends": "",
		"Methods": [
			{
				"signature": "public LoggerUsageWorkAction(ExecOperations execOperations)",
				"documentation": ""
			},
			{
				"signature": "public void execute()",
				"documentation": ""
			}
		],
		"interfaces": [
			"org.gradle.workers.WorkAction"
		]
	},
	{
		"documentation": "",
		"name": "org.elasticsearch.gradle.internal.precommit.SplitPackagesAuditPrecommitPlugin",
		"extends": "org.elasticsearch.gradle.internal.conventions.precommit.PrecommitPlugin",
		"Methods": [
			{
				"signature": "public TaskProvider\u003c? extends Task\u003e createTask(Project project)",
				"documentation": ""
			},
			{
				"signature": "private static Map\u003cFile, String\u003e getProjectBuildDirs(Project project)",
				"documentation": ""
			}
		],
		"interfaces": []
	},
	{
		"documentation": "/**\n * Checks for split packages with dependencies. These are not allowed in a future modularized world.\n */",
		"name": "org.elasticsearch.gradle.internal.precommit.SplitPackagesAuditTask",
		"extends": "org.gradle.api.DefaultTask",
		"Methods": [
			{
				"signature": "public SplitPackagesAuditTask(WorkerExecutor workerExecutor, ObjectFactory objectFactory, ProjectLayout projectLayout)",
				"documentation": "/**\n * Checks for split packages with dependencies. These are not allowed in a future modularized world.\n */"
			},
			{
				"signature": "public void auditSplitPackages()",
				"documentation": ""
			},
			{
				"signature": "public FileCollection getClasspath()",
				"documentation": ""
			},
			{
				"signature": "public void setClasspath(FileCollection classpath)",
				"documentation": ""
			},
			{
				"signature": "public SetProperty\u003cFile\u003e getSrcDirs()",
				"documentation": ""
			},
			{
				"signature": "public SetProperty\u003cString\u003e getIgnoreClasses()",
				"documentation": ""
			},
			{
				"signature": "public void ignoreClasses(String... classes)",
				"documentation": "/**\n     * Add classes that exist in split packages but should be ignored.\n     */"
			},
			{
				"signature": "public RegularFileProperty getMarkerFile()",
				"documentation": ""
			},
			{
				"signature": "public void setProjectBuildDirs(Map\u003cFile, String\u003e projectBuildDirs)",
				"documentation": ""
			}
		],
		"interfaces": []
	},
	{
		"documentation": "",
		"name": "org.elasticsearch.gradle.internal.precommit.SplitPackagesAuditTask.SplitPackagesAuditAction",
		"extends": "",
		"Methods": [
			{
				"signature": "public void execute()",
				"documentation": ""
			},
			{
				"signature": "private Map\u003cString, List\u003cFile\u003e\u003e getDependencyPackages()",
				"documentation": ""
			},
			{
				"signature": "private Map\u003cString, Set\u003cString\u003e\u003e findSplitPackages(Set\u003cString\u003e dependencyPackages)",
				"documentation": ""
			},
			{
				"signature": "private void filterSplitPackages(Map\u003cString, Set\u003cString\u003e\u003e splitPackages)",
				"documentation": ""
			},
			{
				"signature": "private static Set\u003cString\u003e readPackages(File classpathElement)",
				"documentation": ""
			},
			{
				"signature": "private static void walkJavaFiles(Path root, String suffix, Consumer\u003cPath\u003e classConsumer) throws IOException",
				"documentation": ""
			},
			{
				"signature": "private static String getPackageName(Path path)",
				"documentation": ""
			},
			{
				"signature": "private String formatDependency(File dependencyFile)",
				"documentation": ""
			}
		],
		"interfaces": [
			"org.gradle.workers.WorkAction"
		]
	},
	{
		"documentation": "/**\n * Represent rules for tests enforced by the @{link {@link TestingConventionsTasks}}\n *\n * Rules are identified by name, tests must have this name as a suffix and implement one of the base classes\n * and be part of all the specified tasks.\n */",
		"name": "org.elasticsearch.gradle.internal.precommit.TestingConventionRule",
		"extends": "",
		"Methods": [
			{
				"signature": "public TestingConventionRule(String suffix)",
				"documentation": "/**\n * Represent rules for tests enforced by the @{link {@link TestingConventionsTasks}}\n *\n * Rules are identified by name, tests must have this name as a suffix and implement one of the base classes\n * and be part of all the specified tasks.\n */"
			},
			{
				"signature": "public String getSuffix()",
				"documentation": ""
			},
			{
				"signature": "public String getName()",
				"documentation": "/**\n     * Alias for @{link getSuffix} as Gradle requires a name property\n     *\n     */"
			},
			{
				"signature": "public void baseClass(String clazz)",
				"documentation": ""
			},
			{
				"signature": "public void setBaseClasses(Collection\u003cString\u003e baseClasses)",
				"documentation": ""
			},
			{
				"signature": "public void taskName(Pattern expression)",
				"documentation": ""
			},
			{
				"signature": "public void taskName(String expression)",
				"documentation": ""
			},
			{
				"signature": "public void setTaskNames(Collection\u003cPattern\u003e expressions)",
				"documentation": ""
			},
			{
				"signature": "public Set\u003cString\u003e getBaseClasses()",
				"documentation": ""
			},
			{
				"signature": "public Set\u003cPattern\u003e getTaskNames()",
				"documentation": ""
			},
			{
				"signature": "public boolean equals(Object o)",
				"documentation": ""
			},
			{
				"signature": "public int hashCode()",
				"documentation": ""
			}
		],
		"interfaces": [
			"java.io.Serializable"
		]
	},
	{
		"documentation": "",
		"name": "org.elasticsearch.gradle.internal.precommit.TestingConventionsPrecommitPlugin",
		"extends": "org.elasticsearch.gradle.internal.conventions.precommit.PrecommitPlugin",
		"Methods": [
			{
				"signature": "public TaskProvider\u003c? extends Task\u003e createTask(Project project)",
				"documentation": ""
			}
		],
		"interfaces": [
			"org.elasticsearch.gradle.internal.InternalPlugin"
		]
	},
	{
		"documentation": "",
		"name": "org.elasticsearch.gradle.internal.precommit.TestingConventionsTasks",
		"extends": "org.gradle.api.DefaultTask",
		"Methods": [
			{
				"signature": "public void setCandidateClassFilesProvider(Provider\u003cMap\u003cString, Set\u003cFile\u003e\u003e\u003e candidateClassFilesProvider)",
				"documentation": ""
			},
			{
				"signature": "public TestingConventionsTasks(ProjectLayout projectLayout, ObjectFactory objectFactory)",
				"documentation": ""
			},
			{
				"signature": "public Map\u003cString, Set\u003cFile\u003e\u003e getClassFilesPerEnabledTask()",
				"documentation": ""
			},
			{
				"signature": "public Map\u003cString, File\u003e getTestClassNames()",
				"documentation": ""
			},
			{
				"signature": "public NamedDomainObjectContainer\u003cTestingConventionRule\u003e getNaming()",
				"documentation": ""
			},
			{
				"signature": "public File getSuccessMarker()",
				"documentation": ""
			},
			{
				"signature": "public void naming(Closure\u003c?\u003e action)",
				"documentation": ""
			},
			{
				"signature": "public Set\u003cString\u003e getMainClassNamedLikeTests()",
				"documentation": ""
			},
			{
				"signature": "public void doCheck() throws IOException",
				"documentation": ""
			},
			{
				"signature": "private String collectProblems(String... problems)",
				"documentation": ""
			},
			{
				"signature": "private String checkNoneExists(String message, Stream\u003c? extends Class\u003c?\u003e\u003e stream)",
				"documentation": ""
			},
			{
				"signature": "private String checkNoneExists(String message, Set\u003c? extends String\u003e candidates)",
				"documentation": ""
			},
			{
				"signature": "private String checkAtLeastOneExists(String message, Stream\u003c? extends Class\u003c?\u003e\u003e stream)",
				"documentation": ""
			},
			{
				"signature": "private boolean seemsLikeATest(Class\u003c?\u003e clazz)",
				"documentation": ""
			},
			{
				"signature": "private boolean implementsNamingConvention(Class\u003c?\u003e clazz)",
				"documentation": ""
			},
			{
				"signature": "private boolean implementsNamingConvention(String className)",
				"documentation": ""
			},
			{
				"signature": "private boolean matchesTestMethodNamingConvention(Method method)",
				"documentation": ""
			},
			{
				"signature": "private boolean isAnnotated(Method method, Class\u003c?\u003e annotation)",
				"documentation": ""
			},
			{
				"signature": "public FileCollection getTestsClassPath()",
				"documentation": ""
			},
			{
				"signature": "private Map\u003cString, File\u003e walkPathAndLoadClasses(File testRoot)",
				"documentation": ""
			},
			{
				"signature": "public FileVisitResult preVisitDirectory(Path dir, BasicFileAttributes attrs) throws IOException",
				"documentation": ""
			},
			{
				"signature": "public FileVisitResult postVisitDirectory(Path dir, IOException exc) throws IOException",
				"documentation": ""
			},
			{
				"signature": "public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException",
				"documentation": ""
			},
			{
				"signature": "public FileVisitResult visitFileFailed(Path file, IOException exc) throws IOException",
				"documentation": ""
			},
			{
				"signature": "private Class\u003c?\u003e loadClassWithoutInitializing(String name, ClassLoader isolatedClassLoader)",
				"documentation": ""
			},
			{
				"signature": "private URL fileToUrl(File file)",
				"documentation": ""
			},
			{
				"signature": "public void setSourceSets(SourceSetContainer sourceSets)",
				"documentation": ""
			}
		],
		"interfaces": []
	},
	{
		"documentation": "",
		"name": "org.elasticsearch.gradle.internal.precommit.ThirdPartyAuditPrecommitPlugin",
		"extends": "org.elasticsearch.gradle.internal.conventions.precommit.PrecommitPlugin",
		"Methods": [
			{
				"signature": "public TaskProvider\u003c? extends Task\u003e createTask(Project project)",
				"documentation": ""
			}
		],
		"interfaces": [
			"org.elasticsearch.gradle.internal.InternalPlugin"
		]
	},
	{
		"documentation": "",
		"name": "org.elasticsearch.gradle.internal.precommit.ThirdPartyAuditTask",
		"extends": "org.gradle.api.DefaultTask",
		"Methods": [
			{
				"signature": "public ThirdPartyAuditTask(        ArchiveOperations archiveOperations,        ExecOperations execOperations,        FileSystemOperations fileSystemOperations,        ProjectLayout projectLayout,        ObjectFactory objectFactory    )",
				"documentation": ""
			},
			{
				"signature": "public Property\u003cJavaVersion\u003e getTargetCompatibility()",
				"documentation": ""
			},
			{
				"signature": "public FileCollection getForbiddenAPIsClasspath()",
				"documentation": ""
			},
			{
				"signature": "public void setForbiddenAPIsClasspath(FileCollection forbiddenApisClasspath)",
				"documentation": ""
			},
			{
				"signature": "public File getSignatureFile()",
				"documentation": ""
			},
			{
				"signature": "public void setSignatureFile(File signatureFile)",
				"documentation": ""
			},
			{
				"signature": "public String getJavaHome()",
				"documentation": ""
			},
			{
				"signature": "public void setJavaHome(String javaHome)",
				"documentation": ""
			},
			{
				"signature": "public File getJarExpandDir()",
				"documentation": ""
			},
			{
				"signature": "public File getSuccessMarker()",
				"documentation": ""
			},
			{
				"signature": "public FileCollection getJdkJarHellClasspath()",
				"documentation": ""
			},
			{
				"signature": "public void setJdkJarHellClasspath(FileCollection jdkJarHellClasspath)",
				"documentation": ""
			},
			{
				"signature": "public void ignoreMissingClasses(String... classesOrPackages)",
				"documentation": ""
			},
			{
				"signature": "public void ignoreViolations(String... violatingClasses)",
				"documentation": ""
			},
			{
				"signature": "public void ignoreJarHellWithJDK(String... classes)",
				"documentation": ""
			},
			{
				"signature": "public Set\u003cString\u003e getJdkJarHellExcludes()",
				"documentation": ""
			},
			{
				"signature": "public Set\u003cString\u003e getMissingClassExcludes()",
				"documentation": ""
			},
			{
				"signature": "public FileCollection getJarsToScan()",
				"documentation": ""
			},
			{
				"signature": "public void runThirdPartyAudit() throws IOException",
				"documentation": ""
			},
			{
				"signature": "private void success() throws IOException",
				"documentation": ""
			},
			{
				"signature": "private void logForbiddenAPIsOutput(String forbiddenApisOutput)",
				"documentation": ""
			},
			{
				"signature": "private void throwNotConfiguredCorrectlyException()",
				"documentation": ""
			},
			{
				"signature": "private void extractJars(Set\u003cFile\u003e jars, File jarExpandDir)",
				"documentation": "/**\n     * Ideally we would do unpacking already via artifact transform and keep unpacked jars across builds.\n     * At the moment transform target folder is not configurable and forbidden CLI only takes one common\n     * directory as input which makes it incompatible with gradle artifact transforms as we use them today.\n     * */"
			},
			{
				"signature": "private void assertNoJarHell(Set\u003cString\u003e jdkJarHellClasses)",
				"documentation": ""
			},
			{
				"signature": "private void assertNoPointlessExclusions(String specifics, Set\u003cString\u003e excludes, Set\u003cString\u003e problematic)",
				"documentation": ""
			},
			{
				"signature": "private String formatClassList(Set\u003cString\u003e classList)",
				"documentation": ""
			},
			{
				"signature": "private String runForbiddenAPIsCli() throws IOException",
				"documentation": ""
			},
			{
				"signature": "private Set\u003cString\u003e runJdkJarHellCheck() throws IOException",
				"documentation": ""
			},
			{
				"signature": "public void setClasspath(FileCollection classpath)",
				"documentation": ""
			},
			{
				"signature": "public void setJarsToScan(FileCollection jarsToScan)",
				"documentation": ""
			}
		],
		"interfaces": []
	},
	{
		"documentation": "/**\n * A task to update shas used by {@code DependencyLicensesCheck}\n */",
		"name": "org.elasticsearch.gradle.internal.precommit.UpdateShasTask",
		"extends": "org.gradle.api.DefaultTask",
		"Methods": [
			{
				"signature": "public UpdateShasTask()",
				"documentation": "/** The parent dependency licenses task to use configuration from */"
			},
			{
				"signature": "public void updateShas() throws NoSuchAlgorithmException, IOException",
				"documentation": ""
			},
			{
				"signature": "private void createSha(File dependency, String jarName, File shaFile) throws IOException, NoSuchAlgorithmException",
				"documentation": ""
			},
			{
				"signature": "public DependencyLicensesTask getParentTask()",
				"documentation": ""
			},
			{
				"signature": "public void setParentTask(TaskProvider\u003cDependencyLicensesTask\u003e parentTask)",
				"documentation": ""
			}
		],
		"interfaces": []
	},
	{
		"documentation": "/**\n * Incremental task to validate a set of JSON files against a schema.\n */",
		"name": "org.elasticsearch.gradle.internal.precommit.ValidateJsonAgainstSchemaTask",
		"extends": "org.gradle.api.DefaultTask",
		"Methods": [
			{
				"signature": "public FileCollection getInputFiles()",
				"documentation": "/**\n * Incremental task to validate a set of JSON files against a schema.\n */"
			},
			{
				"signature": "public void setInputFiles(FileCollection inputFiles)",
				"documentation": ""
			},
			{
				"signature": "public File getJsonSchema()",
				"documentation": ""
			},
			{
				"signature": "public void setJsonSchema(File jsonSchema)",
				"documentation": ""
			},
			{
				"signature": "public void setReport(File report)",
				"documentation": ""
			},
			{
				"signature": "public File getReport()",
				"documentation": ""
			},
			{
				"signature": "protected ObjectMapper getMapper()",
				"documentation": ""
			},
			{
				"signature": "protected String getFileType()",
				"documentation": ""
			},
			{
				"signature": "public void validate(InputChanges inputChanges) throws IOException",
				"documentation": ""
			},
			{
				"signature": "private JsonSchema buildSchemaObject(File jsonSchemaOnDisk) throws IOException",
				"documentation": ""
			},
			{
				"signature": "private void maybeLogAndCollectError(Set\u003cValidationMessage\u003e messages, Map\u003cFile, Set\u003cString\u003e\u003e errors, File file)",
				"documentation": ""
			}
		],
		"interfaces": []
	},
	{
		"documentation": "/**\n * Incremental task to validate that the API names in set of JSON files do not contain\n * programming language keywords.\n * \u003cp\u003e\n * The keywords are defined in a JSON file, although it's worth noting that what is and isn't a\n * keyword depends on the language and sometimes the context in which a keyword is used. For example,\n * `delete` is an operator in JavaScript, but it isn't in the keywords list for JavaScript or\n * TypeScript because it's OK to use `delete` as a method name.\n */",
		"name": "org.elasticsearch.gradle.internal.precommit.ValidateJsonNoKeywordsTask",
		"extends": "org.gradle.api.DefaultTask",
		"Methods": [
			{
				"signature": "public FileCollection getInputFiles()",
				"documentation": "/**\n * Incremental task to validate that the API names in set of JSON files do not contain\n * programming language keywords.\n * \u003cp\u003e\n * The keywords are defined in a JSON file, although it's worth noting that what is and isn't a\n * keyword depends on the language and sometimes the context in which a keyword is used. For example,\n * `delete` is an operator in JavaScript, but it isn't in the keywords list for JavaScript or\n * TypeScript because it's OK to use `delete` as a method name.\n */"
			},
			{
				"signature": "public void setInputFiles(FileCollection inputFiles)",
				"documentation": ""
			},
			{
				"signature": "public File getJsonKeywords()",
				"documentation": ""
			},
			{
				"signature": "public void setJsonKeywords(File jsonKeywords)",
				"documentation": ""
			},
			{
				"signature": "public void setReport(File report)",
				"documentation": ""
			},
			{
				"signature": "public File getReport()",
				"documentation": ""
			},
			{
				"signature": "public void validate(InputChanges inputChanges)",
				"documentation": ""
			},
			{
				"signature": "private Map\u003cString, Set\u003cString\u003e\u003e loadKeywords(ObjectMapper mapper)",
				"documentation": "/**\n     * Loads the known keywords. Although the JSON on disk maps from language to keywords, this method\n     * inverts this to map from keyword to languages. This is because the same keywords are found in\n     * multiple languages, so it is easier and more useful to have a single map of keywords.\n     *\n     * @return a mapping from keyword to languages.\n     */"
			}
		],
		"interfaces": []
	},
	{
		"documentation": "",
		"name": "org.elasticsearch.gradle.internal.precommit.ValidateRestSpecPlugin",
		"extends": "",
		"Methods": [
			{
				"signature": "public void apply(Project project)",
				"documentation": ""
			}
		],
		"interfaces": [
			"org.elasticsearch.gradle.internal.InternalPlugin"
		]
	},
	{
		"documentation": "/**\n * Incremental task to validate a set of YAML files against a schema.\n */",
		"name": "org.elasticsearch.gradle.internal.precommit.ValidateYamlAgainstSchemaTask",
		"extends": "ValidateJsonAgainstSchemaTask",
		"Methods": [
			{
				"signature": "protected String getFileType()",
				"documentation": "/**\n * Incremental task to validate a set of YAML files against a schema.\n */"
			},
			{
				"signature": "protected ObjectMapper getMapper()",
				"documentation": ""
			}
		],
		"interfaces": []
	},
	{
		"documentation": "/**\n * Generates the page that contains breaking changes deprecations for a minor release series.\n */",
		"name": "org.elasticsearch.gradle.internal.release.BreakingChangesGenerator",
		"extends": "",
		"Methods": [
			{
				"signature": "static void update(File migrationTemplateFile, File migrationOutputFile, List\u003cChangelogEntry\u003e entries) throws IOException",
				"documentation": "/**\n * Generates the page that contains breaking changes deprecations for a minor release series.\n */"
			},
			{
				"signature": "static String generateMigrationFile(QualifiedVersion version, String template, List\u003cChangelogEntry\u003e entries) throws IOException",
				"documentation": ""
			}
		],
		"interfaces": []
	},
	{
		"documentation": "/**\n * This class models the contents of a changelog YAML file. We validate it using a\n * JSON Schema, as well as some programmatic checks in {@link ValidateChangelogEntryTask}.\n * \u003cul\u003e\n *   \u003cli\u003e\u003ccode\u003ebuildSrc/src/main/resources/changelog-schema.json\u003c/code\u003e\u003c/li\u003e\n *   \u003cli\u003e\u003ca href=\"https://json-schema.org/understanding-json-schema/\"\u003eUnderstanding JSON Schema\u003c/a\u003e\u003c/li\u003e\n * \u003c/ul\u003e\n */",
		"name": "org.elasticsearch.gradle.internal.release.ChangelogEntry",
		"extends": "",
		"Methods": [
			{
				"signature": "public static ChangelogEntry parse(File file)",
				"documentation": "/**\n     * Create a new instance by parsing the supplied file\n     * @param file the YAML file to parse\n     * @return a new instance\n     */"
			},
			{
				"signature": "public Integer getPr()",
				"documentation": ""
			},
			{
				"signature": "public void setPr(Integer pr)",
				"documentation": ""
			},
			{
				"signature": "public List\u003cInteger\u003e getIssues()",
				"documentation": ""
			},
			{
				"signature": "public void setIssues(List\u003cInteger\u003e issues)",
				"documentation": ""
			},
			{
				"signature": "public String getArea()",
				"documentation": ""
			},
			{
				"signature": "public void setArea(String area)",
				"documentation": ""
			},
			{
				"signature": "public String getType()",
				"documentation": ""
			},
			{
				"signature": "public void setType(String type)",
				"documentation": ""
			},
			{
				"signature": "public String getSummary()",
				"documentation": ""
			},
			{
				"signature": "public void setSummary(String summary)",
				"documentation": ""
			},
			{
				"signature": "public Highlight getHighlight()",
				"documentation": ""
			},
			{
				"signature": "public void setHighlight(Highlight highlight)",
				"documentation": ""
			},
			{
				"signature": "public Breaking getBreaking()",
				"documentation": ""
			},
			{
				"signature": "public void setBreaking(Breaking breaking)",
				"documentation": ""
			},
			{
				"signature": "public Deprecation getDeprecation()",
				"documentation": ""
			},
			{
				"signature": "public void setDeprecation(Deprecation deprecation)",
				"documentation": ""
			},
			{
				"signature": "public boolean equals(Object o)",
				"documentation": ""
			},
			{
				"signature": "public int hashCode()",
				"documentation": ""
			},
			{
				"signature": "public String toString()",
				"documentation": ""
			},
			{
				"signature": "private static String generatedAnchor(String input)",
				"documentation": ""
			}
		],
		"interfaces": []
	},
	{
		"documentation": "",
		"name": "org.elasticsearch.gradle.internal.release.ChangelogEntry.Highlight",
		"extends": "",
		"Methods": [
			{
				"signature": "public boolean isNotable()",
				"documentation": ""
			},
			{
				"signature": "public void setNotable(boolean notable)",
				"documentation": ""
			},
			{
				"signature": "public String getTitle()",
				"documentation": ""
			},
			{
				"signature": "public void setTitle(String title)",
				"documentation": ""
			},
			{
				"signature": "public String getBody()",
				"documentation": ""
			},
			{
				"signature": "public void setBody(String body)",
				"documentation": ""
			},
			{
				"signature": "public String getAnchor()",
				"documentation": ""
			},
			{
				"signature": "public boolean equals(Object o)",
				"documentation": ""
			},
			{
				"signature": "public int hashCode()",
				"documentation": ""
			},
			{
				"signature": "public String toString()",
				"documentation": ""
			}
		],
		"interfaces": []
	},
	{
		"documentation": "",
		"name": "org.elasticsearch.gradle.internal.release.ChangelogEntry.Breaking",
		"extends": "CompatibilityChange",
		"Methods": [],
		"interfaces": []
	},
	{
		"documentation": "",
		"name": "org.elasticsearch.gradle.internal.release.ChangelogEntry.Deprecation",
		"extends": "CompatibilityChange",
		"Methods": [],
		"interfaces": []
	},
	{
		"documentation": "",
		"name": "org.elasticsearch.gradle.internal.release.ChangelogEntry.CompatibilityChange",
		"extends": "",
		"Methods": [
			{
				"signature": "public String getArea()",
				"documentation": ""
			},
			{
				"signature": "public void setArea(String area)",
				"documentation": ""
			},
			{
				"signature": "public String getTitle()",
				"documentation": ""
			},
			{
				"signature": "public void setTitle(String title)",
				"documentation": ""
			},
			{
				"signature": "public String getDetails()",
				"documentation": ""
			},
			{
				"signature": "public void setDetails(String details)",
				"documentation": ""
			},
			{
				"signature": "public String getImpact()",
				"documentation": ""
			},
			{
				"signature": "public void setImpact(String impact)",
				"documentation": ""
			},
			{
				"signature": "public boolean isNotable()",
				"documentation": ""
			},
			{
				"signature": "public void setNotable(boolean notable)",
				"documentation": ""
			},
			{
				"signature": "public String getAnchor()",
				"documentation": ""
			},
			{
				"signature": "public boolean isEssSettingChange()",
				"documentation": ""
			},
			{
				"signature": "public void setEssSettingChange(boolean essSettingChange)",
				"documentation": ""
			},
			{
				"signature": "public boolean equals(Object o)",
				"documentation": ""
			},
			{
				"signature": "public int hashCode()",
				"documentation": ""
			},
			{
				"signature": "public String toString()",
				"documentation": ""
			}
		],
		"interfaces": []
	},
	{
		"documentation": "/**\n * Orchestrates the steps required to generate or update various release notes files.\n */",
		"name": "org.elasticsearch.gradle.internal.release.GenerateReleaseNotesTask",
		"extends": "org.gradle.api.DefaultTask",
		"Methods": [
			{
				"signature": "public GenerateReleaseNotesTask(ObjectFactory objectFactory, ExecOperations execOperations)",
				"documentation": "/**\n * Orchestrates the steps required to generate or update various release notes files.\n */"
			},
			{
				"signature": "public void executeTask() throws IOException",
				"documentation": ""
			},
			{
				"signature": "static Set\u003cQualifiedVersion\u003e getVersions(GitWrapper gitWrapper, String currentVersion)",
				"documentation": "/**\n     * Find all tags in the major series for the supplied version\n     * @param gitWrapper used to call `git`\n     * @param currentVersion the version to base the query upon\n     * @return all versions in the series\n     */"
			},
			{
				"signature": "static Map\u003cQualifiedVersion, Set\u003cFile\u003e\u003e partitionFilesByVersion(        GitWrapper gitWrapper,        String versionString,        Set\u003cFile\u003e allFilesInCheckout    )",
				"documentation": "/**\n     * Group a set of files by the version in which they first appeared, up until the supplied version. Any files not\n     * present in an earlier version are assumed to have been introduced in the specified version.\n     *\n     * \u003cp\u003eThis method works by finding all git tags prior to {@param versionString} in the same minor series, and\n     * examining the git tree for that tag. By doing this over each tag, it is possible to see how the contents\n     * of the changelog directory changed over time.\n     *\n     * @param gitWrapper used to call `git`\n     * @param versionString the \"current\" version. Does not require a tag in git.\n     * @param allFilesInCheckout the files to partition\n     * @return a mapping from version to the files added in that version.\n     */"
			},
			{
				"signature": "private static void findAndUpdateUpstreamRemote(GitWrapper gitWrapper)",
				"documentation": "/**\n     * Ensure the upstream git remote is up-to-date. The upstream is whatever git remote references `elastic/elasticsearch`.\n     * @param gitWrapper used to call `git`\n     */"
			},
			{
				"signature": "static boolean needsGitTags(String versionString)",
				"documentation": "/**\n     * This methods checks the supplied version and answers {@code false} if the fetching of git\n     * tags can be skipped, or {@code true} otherwise.\n     * \u003cp\u003e\n     * The first version in a minor series will never have any preceding versions, so there's no\n     * need to fetch tags and examine the repository state in the past. This applies when the\n     * version is a release version, a snapshot, or the first alpha version. Subsequent alphas,\n     * betas and release candidates need to check the previous prelease tags.\n     *\n     * @param versionString the version string to check\n     * @return whether fetching git tags is required\n     */"
			},
			{
				"signature": "public FileCollection getChangelogs()",
				"documentation": ""
			},
			{
				"signature": "public void setChangelogs(FileCollection files)",
				"documentation": ""
			},
			{
				"signature": "public RegularFileProperty getReleaseNotesIndexTemplate()",
				"documentation": ""
			},
			{
				"signature": "public void setReleaseNotesIndexTemplate(RegularFile file)",
				"documentation": ""
			},
			{
				"signature": "public RegularFileProperty getReleaseNotesTemplate()",
				"documentation": ""
			},
			{
				"signature": "public void setReleaseNotesTemplate(RegularFile file)",
				"documentation": ""
			},
			{
				"signature": "public RegularFileProperty getReleaseHighlightsTemplate()",
				"documentation": ""
			},
			{
				"signature": "public void setReleaseHighlightsTemplate(RegularFile file)",
				"documentation": ""
			},
			{
				"signature": "public RegularFileProperty getBreakingChangesTemplate()",
				"documentation": ""
			},
			{
				"signature": "public void setBreakingChangesTemplate(RegularFile file)",
				"documentation": ""
			},
			{
				"signature": "public RegularFileProperty getReleaseNotesIndexFile()",
				"documentation": ""
			},
			{
				"signature": "public void setReleaseNotesIndexFile(RegularFile file)",
				"documentation": ""
			},
			{
				"signature": "public RegularFileProperty getReleaseNotesFile()",
				"documentation": ""
			},
			{
				"signature": "public void setReleaseNotesFile(RegularFile file)",
				"documentation": ""
			},
			{
				"signature": "public RegularFileProperty getReleaseHighlightsFile()",
				"documentation": ""
			},
			{
				"signature": "public void setReleaseHighlightsFile(RegularFile file)",
				"documentation": ""
			},
			{
				"signature": "public RegularFileProperty getBreakingChangesMigrationFile()",
				"documentation": ""
			},
			{
				"signature": "public void setBreakingChangesMigrationFile(RegularFile file)",
				"documentation": ""
			}
		],
		"interfaces": []
	},
	{
		"documentation": "/**\n * This class wraps certain {@code git} operations. This is partly for convenience, and partly so that these\n * operations can be easily mocked in testing.\n */",
		"name": "org.elasticsearch.gradle.internal.release.GitWrapper",
		"extends": "",
		"Methods": [
			{
				"signature": "public GitWrapper(ExecOperations execOperations)",
				"documentation": "/**\n * This class wraps certain {@code git} operations. This is partly for convenience, and partly so that these\n * operations can be easily mocked in testing.\n */"
			},
			{
				"signature": "public Map\u003cString, String\u003e listRemotes()",
				"documentation": "/**\n     * @return a mapping from remote names to remote URLs.\n     */"
			},
			{
				"signature": "String runCommand(String... args)",
				"documentation": ""
			},
			{
				"signature": "public void updateRemote(String remote)",
				"documentation": "/**\n     * Updates the git repository from the specified remote\n     * @param remote the remote to use to update\n     */"
			},
			{
				"signature": "public void updateTags(String remote)",
				"documentation": "/**\n     * Updates the git repository's tags from the specified remote\n     * @param remote the remote to use to update\n     */"
			},
			{
				"signature": "public Stream\u003cQualifiedVersion\u003e listVersions(String pattern)",
				"documentation": "/**\n     * Fetch all tags matching the specified pattern, returning them as {@link QualifiedVersion} instances.\n     * @param pattern the tag pattern to match\n     * @return matching versions\n     */"
			},
			{
				"signature": "public Stream\u003cString\u003e listFiles(String ref, String path)",
				"documentation": "/**\n     * Returns all files at the specified {@param path} for the state of the git repository at {@param ref}.\n     *\n     * @param ref the ref to use\n     * @param path the path to list\n     * @return A stream of file names. No path information is included.\n     */"
			}
		],
		"interfaces": []
	},
	{
		"documentation": "/**\n * Once a minor release has happened, we no longer need to keep the changelog files that went into\n * that release in the development branch for that major series or the branch for the next major\n * series\n * \u003cp\u003e\n * This last examines the git history in order to work out which files can be deleted, and\n * does the deletion after confirming with the user.\n */",
		"name": "org.elasticsearch.gradle.internal.release.PruneChangelogsTask",
		"extends": "org.gradle.api.DefaultTask",
		"Methods": [
			{
				"signature": "public PruneChangelogsTask(Project project, ObjectFactory objectFactory, ExecOperations execOperations)",
				"documentation": "/**\n * Once a minor release has happened, we no longer need to keep the changelog files that went into\n * that release in the development branch for that major series or the branch for the next major\n * series\n * \u003cp\u003e\n * This last examines the git history in order to work out which files can be deleted, and\n * does the deletion after confirming with the user.\n */"
			},
			{
				"signature": "public FileCollection getChangelogs()",
				"documentation": ""
			},
			{
				"signature": "public void setChangelogs(FileCollection files)",
				"documentation": ""
			},
			{
				"signature": "public void executeTask()",
				"documentation": ""
			},
			{
				"signature": "static void findAndDeleteFiles(        GitWrapper gitWrapper,        DeleteHelper deleteHelper,        QualifiedVersion version,        Set\u003cFile\u003e allFilesInCheckout,        Path rootDir    )",
				"documentation": ""
			},
			{
				"signature": "private static Set\u003cString\u003e findAllFilesInEarlierVersions(GitWrapper gitWrapper, QualifiedVersion version)",
				"documentation": "/**\n     * Find the releases prior to the supplied version, and find the changelog files in those releases by inspecting the\n     * git trees at each tag.\n     * \u003cp\u003e\n     * If the supplied version is the very first in a new major series, then the method will look tag in the previous\n     * major series. Otherwise, all git tags in the current major series will be inspected.\n     *\n     * @param gitWrapper used for git operations\n     * @param version the git history is inspected relative to this version\n     * @return filenames for changelog files in previous releases, without any path\n     */"
			},
			{
				"signature": "static Stream\u003cQualifiedVersion\u003e findPreviousVersion(GitWrapper gitWrapper, QualifiedVersion version)",
				"documentation": "/**\n     * Find the releases prior to the supplied version. The current major and the previous major are both\n     * listed, since changes may be backported to the prior major e.g. in the event of a series bug\n     * or security problem.\n     *\n     * @param gitWrapper used for git operations\n     * @param version the git tags are inspected relative to this version\n     * @return a stream of earlier versions\n     */"
			}
		],
		"interfaces": []
	},
	{
		"documentation": "/**\n * Encapsulates comparison and printing logic for an x.y.z version with optional qualifier. This class is very similar\n * to {@link Version}, but it dissects the qualifier in such a way that is incompatible\n * with how {@link Version} is used in the build. It also retains any qualifier (prerelease) information, and uses\n * that information when comparing instances.\n */",
		"name": "org.elasticsearch.gradle.internal.release.public",
		"extends": "",
		"Methods": [
			{
				"signature": "public static QualifiedVersion of(final String s)",
				"documentation": "/**\n     * Parses the supplied string into an object.\n     *\n     * @param s a version string in strict semver\n     * @return a new instance\n     */"
			},
			{
				"signature": "public String toString()",
				"documentation": ""
			},
			{
				"signature": "public boolean hasQualifier()",
				"documentation": ""
			},
			{
				"signature": "public boolean isSnapshot()",
				"documentation": ""
			},
			{
				"signature": "public QualifiedVersion withoutQualifier()",
				"documentation": ""
			},
			{
				"signature": "public int compareTo(QualifiedVersion other)",
				"documentation": ""
			},
			{
				"signature": "public boolean isBefore(QualifiedVersion other)",
				"documentation": ""
			}
		],
		"interfaces": [
			"Comparable"
		]
	},
	{
		"documentation": "",
		"name": "org.elasticsearch.gradle.internal.release.private",
		"extends": "",
		"Methods": [],
		"interfaces": []
	},
	{
		"documentation": "",
		"name": "org.elasticsearch.gradle.internal.release.private",
		"extends": "",
		"Methods": [
			{
				"signature": "private static Qualifier of(String qualifier)",
				"documentation": ""
			},
			{
				"signature": "public int compareTo(Qualifier other)",
				"documentation": ""
			},
			{
				"signature": "public String toString()",
				"documentation": ""
			}
		],
		"interfaces": [
			"Comparable"
		]
	},
	{
		"documentation": "/**\n * Generates the release highlights notes, for changelog files that contain the \u003ccode\u003ehighlight\u003c/code\u003e field.\n */",
		"name": "org.elasticsearch.gradle.internal.release.ReleaseHighlightsGenerator",
		"extends": "",
		"Methods": [
			{
				"signature": "static void update(File templateFile, File outputFile, List\u003cChangelogEntry\u003e entries) throws IOException",
				"documentation": "/**\n * Generates the release highlights notes, for changelog files that contain the \u003ccode\u003ehighlight\u003c/code\u003e field.\n */"
			},
			{
				"signature": "static String generateFile(QualifiedVersion version, String template, List\u003cChangelogEntry\u003e entries) throws IOException",
				"documentation": ""
			}
		],
		"interfaces": []
	},
	{
		"documentation": "/**\n * Generates the release notes i.e. list of changes that have gone into this release. They are grouped by the\n * type of change, then by team area.\n */",
		"name": "org.elasticsearch.gradle.internal.release.ReleaseNotesGenerator",
		"extends": "",
		"Methods": [
			{
				"signature": "static",
				"documentation": "/**\n     * These mappings translate change types into the headings as they should appear in the release notes.\n     */"
			},
			{
				"signature": "static void update(File templateFile, File outputFile, QualifiedVersion version, Set\u003cChangelogEntry\u003e changelogs) throws IOException",
				"documentation": ""
			},
			{
				"signature": "static String generateFile(String template, QualifiedVersion version, Set\u003cChangelogEntry\u003e changelogs) throws IOException",
				"documentation": ""
			},
			{
				"signature": "private static Map\u003cString, Map\u003cString, List\u003cChangelogEntry\u003e\u003e\u003e buildChangelogBreakdown(Set\u003cChangelogEntry\u003e changelogs)",
				"documentation": ""
			}
		],
		"interfaces": []
	},
	{
		"documentation": "/**\n * This class ensures that the release notes index page has the appropriate anchors and include directives\n * for the current repository version.\n */",
		"name": "org.elasticsearch.gradle.internal.release.ReleaseNotesIndexGenerator",
		"extends": "",
		"Methods": [
			{
				"signature": "static void update(Set\u003cQualifiedVersion\u003e versions, File indexTemplate, File indexFile) throws IOException",
				"documentation": "/**\n * This class ensures that the release notes index page has the appropriate anchors and include directives\n * for the current repository version.\n */"
			},
			{
				"signature": "static String generateFile(Set\u003cQualifiedVersion\u003e versionsSet, String template) throws IOException",
				"documentation": ""
			}
		],
		"interfaces": []
	},
	{
		"documentation": "/**\n * This plugin defines tasks related to releasing Elasticsearch.\n */",
		"name": "org.elasticsearch.gradle.internal.release.ReleaseToolsPlugin",
		"extends": "",
		"Methods": [
			{
				"signature": "public ReleaseToolsPlugin(ProjectLayout projectLayout)",
				"documentation": "/**\n * This plugin defines tasks related to releasing Elasticsearch.\n */"
			},
			{
				"signature": "public void apply(Project project)",
				"documentation": ""
			}
		],
		"interfaces": [
			"org.gradle.api.Plugin"
		]
	},
	{
		"documentation": "/**\n * Methods for working with Groovy templates.\n */",
		"name": "org.elasticsearch.gradle.internal.release.TemplateUtils",
		"extends": "",
		"Methods": [
			{
				"signature": "public static String render(String template, Map\u003cString, Object\u003e bindings) throws IOException",
				"documentation": "/**\n     * Applies {@code bindings} to {@code template}, then removes all carriage returns from\n     * the result.\n     *\n     * @param template a Groovy template\n     * @param bindings parameters for the template\n     * @return the rendered template\n     */"
			}
		],
		"interfaces": []
	},
	{
		"documentation": "/**\n * Performs additional checks on changelog files, beyond whether they conform to the schema.\n */",
		"name": "org.elasticsearch.gradle.internal.release.ValidateChangelogEntryTask",
		"extends": "org.gradle.api.DefaultTask",
		"Methods": [
			{
				"signature": "public ValidateChangelogEntryTask(ObjectFactory objectFactory, ProjectLayout projectLayout)",
				"documentation": "/**\n * Performs additional checks on changelog files, beyond whether they conform to the schema.\n */"
			},
			{
				"signature": "public void executeTask()",
				"documentation": ""
			},
			{
				"signature": "public FileCollection getChangelogs()",
				"documentation": ""
			},
			{
				"signature": "public void setChangelogs(FileCollection files)",
				"documentation": ""
			}
		],
		"interfaces": []
	},
	{
		"documentation": "/**\n * A task to transform REST tests for use in REST API compatibility before they are executed.\n */",
		"name": "org.elasticsearch.gradle.internal.rest.compat.RestCompatTestTransformTask",
		"extends": "org.gradle.api.DefaultTask",
		"Methods": [
			{
				"signature": "public RestCompatTestTransformTask(        FileSystemOperations fileSystemOperations,        Factory\u003cPatternSet\u003e patternSetFactory,        ObjectFactory objectFactory    )",
				"documentation": "/**\n * A task to transform REST tests for use in REST API compatibility before they are executed.\n */"
			},
			{
				"signature": "private static boolean doesNotHaveCatOperation(ObjectNode doNodeValue)",
				"documentation": ""
			},
			{
				"signature": "public void skipTest(String fullTestName, String reason)",
				"documentation": ""
			},
			{
				"signature": "public void skipTestsByFilePattern(String filePattern, String reason)",
				"documentation": ""
			},
			{
				"signature": "public void replaceValueInMatch(String subKey, Object value)",
				"documentation": "/**\n     * Replaces all the values of a match assertion for all project REST tests.\n     * For example \"match\":{\"_type\": \"foo\"} to \"match\":{\"_type\": \"bar\"}\n     *\n     * @param subKey the key name directly under match to replace. For example \"_type\"\n     * @param value  the value used in the replacement. For example \"bar\"\n     */"
			},
			{
				"signature": "public void replaceValueInMatch(String subKey, Object value, String testName)",
				"documentation": "/**\n     * Replaces the values of a match assertion for the given REST test. For example \"match\":{\"_type\": \"foo\"} to \"match\":{\"_type\": \"bar\"}\n     *\n     * @param subKey   the key name directly under match to replace. For example \"_type\"\n     * @param value    the value used in the replacement. For example \"bar\"\n     * @param testName the testName to apply replacement\n     */"
			},
			{
				"signature": "public void replaceKeyInDo(String oldKeyName, String newKeyName, String testName)",
				"documentation": "/**\n     * A transformation to replace the key in a do section.\n     *\n     * @param oldKeyName the key name directly under do to replace.\n     * @param newKeyName the new key name directly under do.\n     * @param testName   the testName to apply replacement\n     * @see ReplaceKeyInDo\n     */"
			},
			{
				"signature": "public void replaceKeyInDo(String oldKeyName, String newKeyName)",
				"documentation": "/**\n     * A transformation to replace the key in a do section for given REST test.\n     *\n     * @param oldKeyName the key name directly under do to replace.\n     * @param newKeyName the new key name directly under do.\n     * @see ReplaceKeyInDo\n     */"
			},
			{
				"signature": "public void replaceKeyInLength(String oldKeyName, String newKeyName)",
				"documentation": "/**\n     * A transformation to replace the key in a length assertion.\n     *\n     * @param oldKeyName the key name directly under length to replace.\n     * @param newKeyName the new key name directly under length.\n     * @see ReplaceKeyInLength\n     */"
			},
			{
				"signature": "public void replaceValueInLength(String subKey, int value)",
				"documentation": "/**\n     * Replaces all the values of a length assertion for all project REST tests.\n     * For example \"length\":{\"x\": 1} to \"length\":{\"x\": 99}\n     *\n     * @param subKey the key name directly under match to replace. For example \"x\"\n     * @param value  the value used in the replacement. For example 99\n     */"
			},
			{
				"signature": "public void replaceValueInLength(String subKey, int value, String testName)",
				"documentation": "/**\n     * Replaces all the values of a length assertion for the given REST test.\n     * For example \"length\":{\"x\": 1} to \"length\":{\"x\": 99}\n     *\n     * @param subKey   the key name directly under match to replace. For example \"x\"\n     * @param value    the value used in the replacement. For example 99\n     * @param testName the testName to apply replacement\n     */"
			},
			{
				"signature": "public void replaceKeyInMatch(String oldKeyName, String newKeyName)",
				"documentation": "/**\n     * A transformation to replace the key in a match assertion.\n     *\n     * @param oldKeyName the key name directly under match to replace.\n     * @param newKeyName the new key name directly under match.\n     * @see ReplaceKeyInMatch\n     */"
			},
			{
				"signature": "public void replaceIsTrue(String oldValue, Object newValue)",
				"documentation": "/**\n     * Replaces all the values of a is_true assertion for all project REST tests.\n     * For example \"is_true\": \"value_to_replace\" to \"is_true\": \"value_replaced\"\n     *\n     * @param oldValue the value that has to match and will be replaced\n     * @param newValue the value used in the replacement\n     */"
			},
			{
				"signature": "public void replaceIsFalse(String oldValue, Object newValue)",
				"documentation": "/**\n     * Replaces all the values of a is_false assertion for all project REST tests.\n     * For example \"is_false\": \"value_to_replace\" to \"is_false\": \"value_replaced\"\n     *\n     * @param oldValue the value that has to match and will be replaced\n     * @param newValue the value used in the replacement\n     */"
			},
			{
				"signature": "public void replaceIsFalse(String oldValue, Object newValue, String testName)",
				"documentation": "/**\n     * Replaces all the values of a is_false assertion for given REST test.\n     * For example \"is_false\": \"value_to_replace\" to \"is_false\": \"value_replaced\"\n     *\n     * @param oldValue the value that has to match and will be replaced\n     * @param newValue the value used in the replacement\n     * @param testName the testName to apply replacement\n     */"
			},
			{
				"signature": "public void replaceValueTextByKeyValue(String key, String oldValue, Object newValue)",
				"documentation": "/**\n     * Replaces all the values of a given key/value pairs for all project REST tests.\n     * For example \"foo\": \"bar\" can replaced as \"foo\": \"baz\"\n     *\n     * @param key      the key to find\n     * @param oldValue the value of that key to find\n     * @param newValue the value used in the replacement\n     */"
			},
			{
				"signature": "public void replaceValueTextByKeyValue(String key, String oldValue, Object newValue, String testName)",
				"documentation": "/**\n     * Replaces all the values of a given key/value pairs for given REST test.\n     * For example \"foo\": \"bar\" can replaced as \"foo\": \"baz\"\n     *\n     * @param key      the key to find\n     * @param oldValue the value of that key to find\n     * @param newValue the value used in the replacement\n     * @param testName the testName to apply replacement\n     */"
			},
			{
				"signature": "public void removeMatch(String subKey)",
				"documentation": "/**\n     * Removes the key/value of a match assertion all project REST tests for the matching subkey.\n     * For example \"match\":{\"_type\": \"foo\"} to \"match\":{}\n     * An empty match is retained if there is only a single key under match.\n     *\n     * @param subKey the key name directly under match to replace. For example \"_type\"\n     */"
			},
			{
				"signature": "public void removeMatch(String subKey, String testName)",
				"documentation": "/**\n     * Removes the key/value of a match assertion for the given REST tests for the matching subkey.\n     * For example \"match\":{\"_type\": \"foo\"} to \"match\":{}\n     * An empty match is retained if there is only a single key under match.\n     *\n     * @param subKey   the key name directly under match to remove. For example \"_type\"\n     * @param testName the testName to apply removal\n     */"
			},
			{
				"signature": "public void addMatch(String subKey, Object value, String testName)",
				"documentation": "/**\n     * Adds a match assertion for the given REST test. For example add \"match\":{\"_type\": \"foo\"} to the test.\n     *\n     * @param subKey   the key name directly under match to add. For example \"_type\"\n     * @param value    the value used in the addition. For example \"foo\"\n     * @param testName the testName to apply addition\n     */"
			},
			{
				"signature": "public void addWarning(String testName, String... warnings)",
				"documentation": "/**\n     * Adds one or more warnings to the given test\n     *\n     * @param testName the test name to add the warning\n     * @param warnings the warning(s) to add\n     */"
			},
			{
				"signature": "public void addWarningRegex(String testName, String... warningsRegex)",
				"documentation": "/**\n     * Adds one or more regex warnings to the given test\n     *\n     * @param testName      the test name to add the regex warning\n     * @param warningsRegex the regex warning(s) to add\n     */"
			},
			{
				"signature": "public void removeWarning(String... warnings)",
				"documentation": "/**\n     * Removes one or more warnings\n     *\n     * @param warnings the warning(s) to remove\n     */"
			},
			{
				"signature": "public void removeWarningForTest(String warnings, String testName)",
				"documentation": "/**\n     * Removes one or more warnings\n     *\n     * @param warnings the warning(s) to remove\n     * @param testName the test name to remove the warning\n     */"
			},
			{
				"signature": "public void addAllowedWarning(String... allowedWarnings)",
				"documentation": "/**\n     * Adds one or more allowed warnings\n     *\n     * @param allowedWarnings the warning(s) to add\n     */"
			},
			{
				"signature": "public void addAllowedWarningRegex(String... allowedWarningsRegex)",
				"documentation": "/**\n     * Adds one or more allowed regular expression warnings\n     *\n     * @param allowedWarningsRegex the regex warning(s) to add\n     */"
			},
			{
				"signature": "public void addAllowedWarningRegexForTest(String allowedWarningsRegex, String testName)",
				"documentation": "/**\n     * Adds one or more allowed regular expression warnings\n     *\n     * @param allowedWarningsRegex the regex warning(s) to add\n     * @testName the test name to add a allowedWarningRegex\n     */"
			},
			{
				"signature": "public DirectoryProperty getOutputDirectory()",
				"documentation": ""
			},
			{
				"signature": "public FileTree getTestFiles()",
				"documentation": ""
			},
			{
				"signature": "public void transform() throws IOException",
				"documentation": ""
			},
			{
				"signature": "public DirectoryProperty getSourceDirectory()",
				"documentation": ""
			},
			{
				"signature": "public List\u003cRestTestTransform\u003c?\u003e\u003e getTransformations()",
				"documentation": ""
			},
			{
				"signature": "public String getSkippedTestByFilePatternTransformations()",
				"documentation": ""
			},
			{
				"signature": "public String getSkippedTestByTestNameTransformations()",
				"documentation": ""
			}
		],
		"interfaces": []
	},
	{
		"documentation": "/**\n * Apply this plugin to run the YAML based REST tests from a prior major version against this version's cluster.\n */",
		"name": "org.elasticsearch.gradle.internal.rest.compat.YamlRestCompatTestPlugin",
		"extends": "",
		"Methods": [
			{
				"signature": "public void apply(Project project)",
				"documentation": "/**\n * Apply this plugin to run the YAML based REST tests from a prior major version against this version's cluster.\n */"
			},
			{
				"signature": "private boolean isEnabled(Project project)",
				"documentation": ""
			},
			{
				"signature": "private Path getCompatProjectPath(Project project, Path checkoutDir)",
				"documentation": ""
			}
		],
		"interfaces": [
			"org.gradle.api.Plugin"
		]
	},
	{
		"documentation": "/**\n * This class defines gradle tasks for testing our various distribution artifacts.\n */",
		"name": "org.elasticsearch.gradle.internal.test.DistroTestPlugin",
		"extends": "",
		"Methods": [
			{
				"signature": "public DistroTestPlugin(BuildLayout buildLayout)",
				"documentation": "/**\n * This class defines gradle tasks for testing our various distribution artifacts.\n */"
			},
			{
				"signature": "public void apply(Project project)",
				"documentation": ""
			},
			{
				"signature": "private static Map\u003cElasticsearchDistributionType, TaskProvider\u003c?\u003e\u003e lifecycleTasks(Project project, String taskPrefix)",
				"documentation": ""
			},
			{
				"signature": "private static Map\u003cString, TaskProvider\u003c?\u003e\u003e versionTasks(Project project, String taskPrefix)",
				"documentation": ""
			},
			{
				"signature": "private static TaskProvider\u003cCopy\u003e createJdk(        Project project,        String purpose,        String vendor,        String version,        String platform,        String architecture    )",
				"documentation": ""
			},
			{
				"signature": "private static void configureVM(        Project project,        File rootDir,        TaskProvider\u003cCopy\u003e gradleJdkProvider,        TaskProvider\u003cCopy\u003e systemJdkProvider    )",
				"documentation": ""
			},
			{
				"signature": "private static Object convertPath(        File rootDirectory,        VagrantExtension vagrant,        TaskProvider\u003cCopy\u003e jdkProvider,        String additionaLinux,        String additionalWindows    )",
				"documentation": ""
			},
			{
				"signature": "private static Configuration configureExamplePlugin(Project project)",
				"documentation": ""
			},
			{
				"signature": "private static void configureVMWrapperTasks(        Project project,        List\u003cTaskProvider\u003cTest\u003e\u003e destructiveTasks,        Map\u003cString, TaskProvider\u003c?\u003e\u003e depsTasks,        Action\u003cTaskProvider\u003cGradleDistroTestTask\u003e\u003e configure,        Object... additionalDeps    )",
				"documentation": ""
			},
			{
				"signature": "private static TaskProvider\u003cTest\u003e configureTestTask(        Project project,        String taskname,        ElasticsearchDistribution distribution,        Action\u003c? super Test\u003e configure,        Object... deps    )",
				"documentation": ""
			},
			{
				"signature": "private List\u003cElasticsearchDistribution\u003e configureDistributions(Project project)",
				"documentation": ""
			},
			{
				"signature": "private static ElasticsearchDistribution createDistro(        NamedDomainObjectContainer\u003cElasticsearchDistribution\u003e distributions,        Architecture architecture,        ElasticsearchDistributionType type,        Platform platform,        boolean bundledJdk,        String version    )",
				"documentation": ""
			},
			{
				"signature": "private static boolean isWindows(Project project)",
				"documentation": ""
			},
			{
				"signature": "private static String distroId(ElasticsearchDistributionType type, Platform platform, boolean bundledJdk, Architecture architecture)",
				"documentation": ""
			},
			{
				"signature": "private static String destructiveDistroTestTaskName(ElasticsearchDistribution distro)",
				"documentation": ""
			},
			{
				"signature": "private static String destructiveDistroUpgradeTestTaskName(ElasticsearchDistribution distro, String bwcVersion)",
				"documentation": ""
			},
			{
				"signature": "private static void addDistributionSysprop(Test task, String sysprop, Supplier\u003cString\u003e valueSupplier)",
				"documentation": ""
			}
		],
		"interfaces": [
			"org.gradle.api.Plugin"
		]
	},
	{
		"documentation": "",
		"name": "org.elasticsearch.gradle.internal.test.ErrorReportingTestListener",
		"extends": "",
		"Methods": [
			{
				"signature": "public ErrorReportingTestListener(TestLogging testLogging, Logger taskLogger, File outputDirectory)",
				"documentation": ""
			},
			{
				"signature": "public void onOutput(TestDescriptor testDescriptor, TestOutputEvent outputEvent)",
				"documentation": ""
			},
			{
				"signature": "public void beforeSuite(TestDescriptor suite)",
				"documentation": ""
			},
			{
				"signature": "public void afterSuite(final TestDescriptor suite, TestResult result)",
				"documentation": ""
			},
			{
				"signature": "public void beforeTest(TestDescriptor testDescriptor)",
				"documentation": ""
			},
			{
				"signature": "public void afterTest(TestDescriptor testDescriptor, TestResult result)",
				"documentation": ""
			},
			{
				"signature": "public Destination getDestination()",
				"documentation": ""
			},
			{
				"signature": "public String getMessage()",
				"documentation": ""
			},
			{
				"signature": "public Set\u003cDescriptor\u003e getFailedTests()",
				"documentation": ""
			}
		],
		"interfaces": [
			"org.gradle.api.tasks.testing.TestOutputListener",
			"org.gradle.api.tasks.testing.TestListener"
		]
	},
	{
		"documentation": "/**\n     * Class for identifying test output sources. We use this rather than Gradle's {@link TestDescriptor} as we want\n     * to avoid any nasty memory leak issues that come from keeping Gradle implementation types in memory. Since we\n     * use this a the key for our HashMap, it's best to control the implementation as there's no guarantee that Gradle's\n     * various {@link TestDescriptor} implementations reliably implement equals and hashCode.\n     */",
		"name": "org.elasticsearch.gradle.internal.test.public",
		"extends": "",
		"Methods": [
			{
				"signature": "public static Descriptor of(TestDescriptor d)",
				"documentation": "/**\n     * Class for identifying test output sources. We use this rather than Gradle's {@link TestDescriptor} as we want\n     * to avoid any nasty memory leak issues that come from keeping Gradle implementation types in memory. Since we\n     * use this a the key for our HashMap, it's best to control the implementation as there's no guarantee that Gradle's\n     * various {@link TestDescriptor} implementations reliably implement equals and hashCode.\n     */"
			},
			{
				"signature": "public String getFullName()",
				"documentation": ""
			}
		],
		"interfaces": []
	},
	{
		"documentation": "",
		"name": "org.elasticsearch.gradle.internal.test.EventWriter",
		"extends": "",
		"Methods": [
			{
				"signature": "EventWriter(Descriptor descriptor)",
				"documentation": ""
			},
			{
				"signature": "public void write(TestOutputEvent event)",
				"documentation": ""
			},
			{
				"signature": "public void flush() throws IOException",
				"documentation": ""
			},
			{
				"signature": "public BufferedReader reader()",
				"documentation": ""
			},
			{
				"signature": "public void close() throws IOException",
				"documentation": ""
			}
		],
		"interfaces": [
			"java.io.Closeable"
		]
	},
	{
		"documentation": "/**\n * Run a gradle task of the current build, within the configured vagrant VM.\n */",
		"name": "org.elasticsearch.gradle.internal.test.GradleDistroTestTask",
		"extends": "org.elasticsearch.gradle.internal.vagrant.VagrantShellTask",
		"Methods": [
			{
				"signature": "public GradleDistroTestTask(BuildLayout buildLayout, ProjectLayout projectLayout)",
				"documentation": "/**\n * Run a gradle task of the current build, within the configured vagrant VM.\n */"
			},
			{
				"signature": "public void setTaskName(String taskName)",
				"documentation": ""
			},
			{
				"signature": "public String getTaskName()",
				"documentation": ""
			},
			{
				"signature": "public void setTestClass(String testClass)",
				"documentation": ""
			},
			{
				"signature": "public List\u003cString\u003e getExtraArgs()",
				"documentation": ""
			},
			{
				"signature": "public void extraArg(String arg)",
				"documentation": ""
			},
			{
				"signature": "public void setLogLevel(String logLevel)",
				"documentation": ""
			},
			{
				"signature": "protected List\u003cString\u003e getWindowsScript()",
				"documentation": ""
			},
			{
				"signature": "protected List\u003cString\u003e getLinuxScript()",
				"documentation": ""
			},
			{
				"signature": "private List\u003cString\u003e getScript(boolean isWindows)",
				"documentation": ""
			}
		],
		"interfaces": []
	},
	{
		"documentation": "",
		"name": "org.elasticsearch.gradle.internal.test.InternalClusterTestPlugin",
		"extends": "",
		"Methods": [
			{
				"signature": "public void apply(Project project)",
				"documentation": ""
			}
		],
		"interfaces": [
			"org.gradle.api.Plugin"
		]
	},
	{
		"documentation": "/**\n * Sub typed version of {@link StandaloneRestIntegTestTask}  that is used to differentiate between plain standalone\n * integ test tasks based on {@link StandaloneRestIntegTestTask} and\n * conventional configured tasks of {@link RestIntegTestTask}\n */",
		"name": "org.elasticsearch.gradle.internal.test.RestIntegTestTask",
		"extends": "org.elasticsearch.gradle.testclusters.StandaloneRestIntegTestTask",
		"Methods": [],
		"interfaces": []
	},
	{
		"documentation": "",
		"name": "org.elasticsearch.gradle.internal.test.RestTestBasePlugin",
		"extends": "",
		"Methods": [
			{
				"signature": "public RestTestBasePlugin(ProviderFactory providerFactory)",
				"documentation": ""
			},
			{
				"signature": "public void apply(Project project)",
				"documentation": ""
			},
			{
				"signature": "private String systemProperty(String propName)",
				"documentation": ""
			}
		],
		"interfaces": [
			"org.gradle.api.Plugin"
		]
	},
	{
		"documentation": "/**\n * Adds support for starting an Elasticsearch cluster before running integration\n * tests. Used in conjunction with {@link StandaloneRestTestPlugin} for qa\n * projects and in conjunction with {@link BuildPlugin} for testing the rest\n * client.\n */",
		"name": "org.elasticsearch.gradle.internal.test.RestTestPlugin",
		"extends": "",
		"Methods": [
			{
				"signature": "public void apply(final Project project)",
				"documentation": "/**\n * Adds support for starting an Elasticsearch cluster before running integration\n * tests. Used in conjunction with {@link StandaloneRestTestPlugin} for qa\n * projects and in conjunction with {@link BuildPlugin} for testing the rest\n * client.\n */"
			}
		],
		"interfaces": [
			"org.gradle.api.Plugin"
		]
	},
	{
		"documentation": "/**\n * A {@link CommandLineArgumentProvider} implementation that simply returns the given list. This implementation does not track any\n * arguments as inputs, so this is useful for passing arguments that should not be used for the purposes of input snapshotting.\n */",
		"name": "org.elasticsearch.gradle.internal.test.SimpleCommandLineArgumentProvider",
		"extends": "",
		"Methods": [
			{
				"signature": "public SimpleCommandLineArgumentProvider(String... arguments)",
				"documentation": "/**\n * A {@link CommandLineArgumentProvider} implementation that simply returns the given list. This implementation does not track any\n * arguments as inputs, so this is useful for passing arguments that should not be used for the purposes of input snapshotting.\n */"
			},
			{
				"signature": "public Iterable\u003cString\u003e asArguments()",
				"documentation": ""
			}
		],
		"interfaces": [
			"org.gradle.process.CommandLineArgumentProvider"
		]
	},
	{
		"documentation": "/**\n * Configures the build to compile tests against Elasticsearch's test framework\n * and run REST tests. Use BuildPlugin if you want to build main code as well\n * as tests.\n */",
		"name": "org.elasticsearch.gradle.internal.test.StandaloneRestTestPlugin",
		"extends": "",
		"Methods": [
			{
				"signature": "public void apply(final Project project)",
				"documentation": "/**\n * Configures the build to compile tests against Elasticsearch's test framework\n * and run REST tests. Use BuildPlugin if you want to build main code as well\n * as tests.\n */"
			}
		],
		"interfaces": [
			"org.gradle.api.Plugin"
		]
	},
	{
		"documentation": "/**\n * Configures the build to compile against Elasticsearch's test framework and\n * run integration and unit tests. Use BuildPlugin if you want to build main\n * code as well as tests.\n */",
		"name": "org.elasticsearch.gradle.internal.test.StandaloneTestPlugin",
		"extends": "",
		"Methods": [
			{
				"signature": "public void apply(final Project project)",
				"documentation": "/**\n * Configures the build to compile against Elasticsearch's test framework and\n * run integration and unit tests. Use BuildPlugin if you want to build main\n * code as well as tests.\n */"
			}
		],
		"interfaces": [
			"org.gradle.api.Plugin"
		]
	},
	{
		"documentation": "/**\n * A plugin to run tests that depend on other plugins or modules.\n * \u003cp\u003e\n * This plugin will add the plugin-metadata and properties files for each\n * dependency to the test source set.\n */",
		"name": "org.elasticsearch.gradle.internal.test.TestWithDependenciesPlugin",
		"extends": "",
		"Methods": [
			{
				"signature": "public void apply(final Project project)",
				"documentation": "/**\n * A plugin to run tests that depend on other plugins or modules.\n * \u003cp\u003e\n * This plugin will add the plugin-metadata and properties files for each\n * dependency to the test source set.\n */"
			},
			{
				"signature": "private static void addPluginResources(final Project project, final Project pluginProject)",
				"documentation": ""
			}
		],
		"interfaces": [
			"org.gradle.api.Plugin"
		]
	},
	{
		"documentation": "",
		"name": "org.elasticsearch.gradle.internal.test.TestWithSslPlugin",
		"extends": "",
		"Methods": [
			{
				"signature": "public void apply(Project project)",
				"documentation": ""
			}
		],
		"interfaces": [
			"org.gradle.api.Plugin"
		]
	},
	{
		"documentation": "",
		"name": "org.elasticsearch.gradle.internal.test.rerun.TestRerunPlugin",
		"extends": "",
		"Methods": [
			{
				"signature": "TestRerunPlugin(ObjectFactory objectFactory)",
				"documentation": ""
			},
			{
				"signature": "public void apply(Project project)",
				"documentation": ""
			}
		],
		"interfaces": [
			"org.gradle.api.Plugin"
		]
	},
	{
		"documentation": "/**\n * Allows configuring test rerun mechanics.\n * \u003cp\u003e\n * This extension is added with the name 'rerun' to all {@link Test} tasks.\n */",
		"name": "org.elasticsearch.gradle.internal.test.rerun.TestRerunTaskExtension",
		"extends": "",
		"Methods": [
			{
				"signature": "public TestRerunTaskExtension(ObjectFactory objects)",
				"documentation": "/**\n     * The name of the extension added to each test task.\n     */"
			},
			{
				"signature": "public Property\u003cInteger\u003e getMaxReruns()",
				"documentation": "/**\n     * The maximum number of times to rerun all tests.\n     * \u003cp\u003e\n     * This setting defaults to {@code 0}, which results in no retries.\n     * Any value less than 1 disables rerunning.\n     *\n     * @return the maximum number of times to rerun all tests of a task\n     */"
			},
			{
				"signature": "public Property\u003cBoolean\u003e getDidRerun()",
				"documentation": "/**\n     /**\n     * @return whether tests tests have been rerun or not. Defaults to false.\n     */"
			}
		],
		"interfaces": []
	},
	{
		"documentation": "",
		"name": "org.elasticsearch.gradle.internal.test.rerun.TestTaskConfigurer",
		"extends": "",
		"Methods": [
			{
				"signature": "private TestTaskConfigurer()",
				"documentation": ""
			},
			{
				"signature": "public static void configureTestTask(Test test, ObjectFactory objectFactory)",
				"documentation": ""
			},
			{
				"signature": "private static RerunTestExecuter createRetryTestExecuter(Task task, TestRerunTaskExtension extension)",
				"documentation": ""
			},
			{
				"signature": "private static TestExecuter\u003cJvmTestExecutionSpec\u003e getTestExecuter(Task task)",
				"documentation": ""
			},
			{
				"signature": "private static void setTestExecuter(Task task, RerunTestExecuter rerunTestExecuter)",
				"documentation": ""
			},
			{
				"signature": "private static Method declaredMethod(Class\u003c?\u003e type, String methodName, Class\u003c?\u003e... paramTypes)",
				"documentation": ""
			},
			{
				"signature": "private static Method makeAccessible(Method method)",
				"documentation": ""
			},
			{
				"signature": "private static \u003cT\u003e T invoke(Method method, Object instance, Object... args)",
				"documentation": ""
			}
		],
		"interfaces": []
	},
	{
		"documentation": "",
		"name": "org.elasticsearch.gradle.internal.test.rerun.TestTaskConfigurer.InitTaskAction",
		"extends": "",
		"Methods": [
			{
				"signature": "InitTaskAction(TestRerunTaskExtension extension)",
				"documentation": ""
			},
			{
				"signature": "public void execute(Task task)",
				"documentation": ""
			}
		],
		"interfaces": [
			"org.gradle.api.Action"
		]
	},
	{
		"documentation": "",
		"name": "org.elasticsearch.gradle.internal.test.rerun.executer.RerunTestExecuter",
		"extends": "",
		"Methods": [
			{
				"signature": "public RerunTestExecuter(TestRerunTaskExtension extension, TestExecuter\u003cJvmTestExecutionSpec\u003e delegate)",
				"documentation": ""
			},
			{
				"signature": "public void execute(JvmTestExecutionSpec spec, TestResultProcessor testResultProcessor)",
				"documentation": ""
			},
			{
				"signature": "public void stopNow()",
				"documentation": ""
			},
			{
				"signature": "void report(int runCount, List\u003cTestDescriptorInternal\u003e activeDescriptors)",
				"documentation": ""
			}
		],
		"interfaces": [
			"org.gradle.api.internal.tasks.testing.TestExecuter"
		]
	},
	{
		"documentation": "",
		"name": "org.elasticsearch.gradle.internal.test.rerun.executer.RerunTestResultProcessor",
		"extends": "",
		"Methods": [
			{
				"signature": "RerunTestResultProcessor(TestResultProcessor delegate)",
				"documentation": "/**\n     * gradle structures tests in a tree structure with the test task itself\n     * being the root element. This is required to be tracked here to get the\n     * structure right when rerunning a test task tests.\n     * */"
			},
			{
				"signature": "public void started(TestDescriptorInternal descriptor, TestStartEvent testStartEvent)",
				"documentation": ""
			},
			{
				"signature": "public void completed(Object testId, TestCompleteEvent testCompleteEvent)",
				"documentation": ""
			},
			{
				"signature": "public void output(Object testId, TestOutputEvent testOutputEvent)",
				"documentation": ""
			},
			{
				"signature": "public void failure(Object testId, Throwable throwable)",
				"documentation": ""
			},
			{
				"signature": "private void logTracing(Object testId, IllegalArgumentException illegalArgumentException)",
				"documentation": ""
			},
			{
				"signature": "public void reset()",
				"documentation": ""
			},
			{
				"signature": "public List\u003cTestDescriptorInternal\u003e getActiveDescriptors()",
				"documentation": ""
			}
		],
		"interfaces": [
			"org.gradle.api.internal.tasks.testing.TestResultProcessor"
		]
	},
	{
		"documentation": "/**\n * Copies the files needed for the Rest YAML specs to the current projects test resources output directory.\n * This is intended to be be used from {@link RestResourcesPlugin} since the plugin wires up the needed\n * configurations and custom extensions.\n *\n * @see RestResourcesPlugin\n */",
		"name": "org.elasticsearch.gradle.internal.test.rest.CopyRestApiTask",
		"extends": "org.gradle.api.DefaultTask",
		"Methods": [
			{
				"signature": "public CopyRestApiTask(        ProjectLayout projectLayout,        Factory\u003cPatternSet\u003e patternSetFactory,        FileSystemOperations fileSystemOperations,        ObjectFactory objectFactory    )",
				"documentation": "/**\n * Copies the files needed for the Rest YAML specs to the current projects test resources output directory.\n * This is intended to be be used from {@link RestResourcesPlugin} since the plugin wires up the needed\n * configurations and custom extensions.\n *\n * @see RestResourcesPlugin\n */"
			},
			{
				"signature": "public ListProperty\u003cString\u003e getInclude()",
				"documentation": ""
			},
			{
				"signature": "public boolean isSkipHasRestTestCheck()",
				"documentation": ""
			},
			{
				"signature": "public FileTree getInputDir()",
				"documentation": ""
			},
			{
				"signature": "public DirectoryProperty getOutputResourceDir()",
				"documentation": ""
			},
			{
				"signature": "public DirectoryProperty getAdditionalYamlTestsDir()",
				"documentation": ""
			},
			{
				"signature": "void copy()",
				"documentation": ""
			},
			{
				"signature": "private boolean projectHasYamlRestTests()",
				"documentation": "/**\n     * Returns true if any files with a .yml extension exist the test resources rest-api-spec/test directory (from source or output dir)\n     */"
			},
			{
				"signature": "public void setSourceResourceDir(File sourceResourceDir)",
				"documentation": ""
			},
			{
				"signature": "public void setSkipHasRestTestCheck(boolean skipHasRestTestCheck)",
				"documentation": ""
			},
			{
				"signature": "public void setConfig(FileCollection config)",
				"documentation": ""
			},
			{
				"signature": "public void setAdditionalConfig(FileCollection additionalConfig)",
				"documentation": ""
			},
			{
				"signature": "public void setConfigToFileTree(Function\u003cFileCollection, FileTree\u003e configToFileTree)",
				"documentation": ""
			},
			{
				"signature": "public void setAdditionalConfigToFileTree(Function\u003cFileCollection, FileTree\u003e additionalConfigToFileTree)",
				"documentation": ""
			}
		],
		"interfaces": []
	},
	{
		"documentation": "/**\n * Copies the Rest YAML test to the current projects test resources output directory.\n * This is intended to be be used from {@link RestResourcesPlugin} since the plugin wires up the needed\n * configurations and custom extensions.\n *\n * @see RestResourcesPlugin\n */",
		"name": "org.elasticsearch.gradle.internal.test.rest.CopyRestTestsTask",
		"extends": "org.gradle.api.DefaultTask",
		"Methods": [
			{
				"signature": "public CopyRestTestsTask(        ProjectLayout projectLayout,        Factory\u003cPatternSet\u003e patternSetFactory,        FileSystemOperations fileSystemOperations,        ObjectFactory objectFactory    )",
				"documentation": "/**\n * Copies the Rest YAML test to the current projects test resources output directory.\n * This is intended to be be used from {@link RestResourcesPlugin} since the plugin wires up the needed\n * configurations and custom extensions.\n *\n * @see RestResourcesPlugin\n */"
			},
			{
				"signature": "public ListProperty\u003cString\u003e getIncludeCore()",
				"documentation": ""
			},
			{
				"signature": "public ListProperty\u003cString\u003e getIncludeXpack()",
				"documentation": ""
			},
			{
				"signature": "public void setSubstitutions(Map\u003cString, String\u003e substitutions)",
				"documentation": ""
			},
			{
				"signature": "public Map\u003cString, String\u003e getSubstitutions()",
				"documentation": ""
			},
			{
				"signature": "public FileTree getInputDir()",
				"documentation": ""
			},
			{
				"signature": "public DirectoryProperty getOutputResourceDir()",
				"documentation": ""
			},
			{
				"signature": "void copy()",
				"documentation": ""
			},
			{
				"signature": "public void setCoreConfig(FileCollection coreConfig)",
				"documentation": ""
			},
			{
				"signature": "public void setXpackConfig(FileCollection xpackConfig)",
				"documentation": ""
			},
			{
				"signature": "public void setAdditionalConfig(FileCollection additionalConfig)",
				"documentation": ""
			},
			{
				"signature": "public void setCoreConfigToFileTree(Function\u003cFileCollection, FileTree\u003e coreConfigToFileTree)",
				"documentation": ""
			},
			{
				"signature": "public void setXpackConfigToFileTree(Function\u003cFileCollection, FileTree\u003e xpackConfigToFileTree)",
				"documentation": ""
			},
			{
				"signature": "public void setAdditionalConfigToFileTree(Function\u003cFileCollection, FileTree\u003e additionalConfigToFileTree)",
				"documentation": ""
			}
		],
		"interfaces": []
	},
	{
		"documentation": "/**\n * Apply this plugin to run the Java based REST tests.\n */",
		"name": "org.elasticsearch.gradle.internal.test.rest.InternalJavaRestTestPlugin",
		"extends": "",
		"Methods": [
			{
				"signature": "public void apply(Project project)",
				"documentation": "/**\n * Apply this plugin to run the Java based REST tests.\n */"
			}
		],
		"interfaces": [
			"org.gradle.api.Plugin"
		]
	},
	{
		"documentation": "/**\n * Apply this plugin to run the YAML based REST tests.\n */",
		"name": "org.elasticsearch.gradle.internal.test.rest.InternalYamlRestTestPlugin",
		"extends": "",
		"Methods": [
			{
				"signature": "public void apply(Project project)",
				"documentation": "/**\n * Apply this plugin to run the YAML based REST tests.\n */"
			}
		],
		"interfaces": [
			"org.gradle.api.Plugin"
		]
	},
	{
		"documentation": "/**\n * Custom extension to configure the {@link CopyRestApiTask}\n */",
		"name": "org.elasticsearch.gradle.internal.test.rest.RestResourcesExtension",
		"extends": "",
		"Methods": [
			{
				"signature": "public RestResourcesExtension(ObjectFactory objects)",
				"documentation": "/**\n * Custom extension to configure the {@link CopyRestApiTask}\n */"
			},
			{
				"signature": "void restApi(Action\u003c? super RestResourcesSpec\u003e spec)",
				"documentation": ""
			},
			{
				"signature": "void restTests(Action\u003c? super XpackRestResourcesSpec\u003e spec)",
				"documentation": ""
			},
			{
				"signature": "public RestResourcesSpec getRestApi()",
				"documentation": ""
			},
			{
				"signature": "public XpackRestResourcesSpec getRestTests()",
				"documentation": ""
			}
		],
		"interfaces": []
	},
	{
		"documentation": "",
		"name": "org.elasticsearch.gradle.internal.test.rest.RestResourcesExtension.RestResourcesSpec",
		"extends": "",
		"Methods": [
			{
				"signature": "RestResourcesSpec(ObjectFactory objects)",
				"documentation": ""
			},
			{
				"signature": "public void include(String... include)",
				"documentation": ""
			},
			{
				"signature": "public ListProperty\u003cString\u003e getInclude()",
				"documentation": ""
			}
		],
		"interfaces": []
	},
	{
		"documentation": "",
		"name": "org.elasticsearch.gradle.internal.test.rest.RestResourcesExtension.XpackRestResourcesSpec",
		"extends": "",
		"Methods": [
			{
				"signature": "XpackRestResourcesSpec(ObjectFactory objects)",
				"documentation": ""
			},
			{
				"signature": "public void includeCore(String... include)",
				"documentation": ""
			},
			{
				"signature": "public void includeXpack(String... include)",
				"documentation": ""
			},
			{
				"signature": "public ListProperty\u003cString\u003e getIncludeCore()",
				"documentation": ""
			},
			{
				"signature": "public ListProperty\u003cString\u003e getIncludeXpack()",
				"documentation": ""
			}
		],
		"interfaces": []
	},
	{
		"documentation": "/**\n * \u003cp\u003e\n * Gradle plugin to help configure {@link CopyRestApiTask}'s and {@link CopyRestTestsTask} that copies the artifacts needed for the Rest API\n * spec and YAML based rest tests.\n * \u003c/p\u003e\n * \u003cstrong\u003eRest API specification:\u003c/strong\u003e \u003cbr\u003e\n * When the {@link RestResourcesPlugin} has been applied the {@link CopyRestApiTask} will automatically copy the core Rest API specification\n * if there are any Rest YAML tests present in source, or copied from {@link CopyRestTestsTask} output. X-pack specs must be explicitly\n * declared to be copied.\n * \u003cbr\u003e\n * \u003ci\u003eFor example:\u003c/i\u003e\n * \u003cpre\u003e\n * restResources {\n *   restApi {\n *     includeXpack 'enrich'\n *   }\n * }\n * \u003c/pre\u003e\n * Will copy the entire core Rest API specifications (assuming the project has tests) and any of the the X-pack specs starting with enrich*.\n * It is recommended (but not required) to also explicitly declare which core specs your project depends on to help optimize the caching\n * behavior.\n * \u003ci\u003eFor example:\u003c/i\u003e\n * \u003cpre\u003e\n * restResources {\n *   restApi {\n *     includeCore 'index', 'cat'\n *     includeXpack 'enrich'\n *   }\n * }\n * \u003c/pre\u003e\n * \u003cbr\u003e\n * \u003cstrong\u003eRest YAML tests :\u003c/strong\u003e \u003cbr\u003e\n * When the {@link RestResourcesPlugin} has been applied the {@link CopyRestTestsTask} will copy the Rest YAML tests if explicitly\n * configured with `includeCore` or `includeXpack` through the `restResources.restTests` extension.\n * \u003ci\u003eFor example:\u003c/i\u003e\n * \u003cpre\u003e\n * restResources {\n *  restApi {\n *      includeXpack 'graph'\n *   }\n *   restTests {\n *     includeXpack 'graph'\n *   }\n * }\n * \u003c/pre\u003e\n * Will copy any of the the x-pack tests that start with graph, and will copy the X-pack graph specification, as well as the full core\n * Rest API specification.\n * \u003cp\u003e\n * Additionally you can specify which sourceSetName resources should be copied to. The default is the yamlRestTest source set.\n *\n * @see CopyRestApiTask\n * @see CopyRestTestsTask\n */",
		"name": "org.elasticsearch.gradle.internal.test.rest.RestResourcesPlugin",
		"extends": "",
		"Methods": [
			{
				"signature": "public void apply(Project project)",
				"documentation": "/**\n * \u003cp\u003e\n * Gradle plugin to help configure {@link CopyRestApiTask}'s and {@link CopyRestTestsTask} that copies the artifacts needed for the Rest API\n * spec and YAML based rest tests.\n * \u003c/p\u003e\n * \u003cstrong\u003eRest API specification:\u003c/strong\u003e \u003cbr\u003e\n * When the {@link RestResourcesPlugin} has been applied the {@link CopyRestApiTask} will automatically copy the core Rest API specification\n * if there are any Rest YAML tests present in source, or copied from {@link CopyRestTestsTask} output. X-pack specs must be explicitly\n * declared to be copied.\n * \u003cbr\u003e\n * \u003ci\u003eFor example:\u003c/i\u003e\n * \u003cpre\u003e\n * restResources {\n *   restApi {\n *     includeXpack 'enrich'\n *   }\n * }\n * \u003c/pre\u003e\n * Will copy the entire core Rest API specifications (assuming the project has tests) and any of the the X-pack specs starting with enrich*.\n * It is recommended (but not required) to also explicitly declare which core specs your project depends on to help optimize the caching\n * behavior.\n * \u003ci\u003eFor example:\u003c/i\u003e\n * \u003cpre\u003e\n * restResources {\n *   restApi {\n *     includeCore 'index', 'cat'\n *     includeXpack 'enrich'\n *   }\n * }\n * \u003c/pre\u003e\n * \u003cbr\u003e\n * \u003cstrong\u003eRest YAML tests :\u003c/strong\u003e \u003cbr\u003e\n * When the {@link RestResourcesPlugin} has been applied the {@link CopyRestTestsTask} will copy the Rest YAML tests if explicitly\n * configured with `includeCore` or `includeXpack` through the `restResources.restTests` extension.\n * \u003ci\u003eFor example:\u003c/i\u003e\n * \u003cpre\u003e\n * restResources {\n *  restApi {\n *      includeXpack 'graph'\n *   }\n *   restTests {\n *     includeXpack 'graph'\n *   }\n * }\n * \u003c/pre\u003e\n * Will copy any of the the x-pack tests that start with graph, and will copy the X-pack graph specification, as well as the full core\n * Rest API specification.\n * \u003cp\u003e\n * Additionally you can specify which sourceSetName resources should be copied to. The default is the yamlRestTest source set.\n *\n * @see CopyRestApiTask\n * @see CopyRestTestsTask\n */"
			}
		],
		"interfaces": [
			"org.gradle.api.Plugin"
		]
	},
	{
		"documentation": "/**\n * Utility class to configure the necessary tasks and dependencies.\n */",
		"name": "org.elasticsearch.gradle.internal.test.rest.RestTestUtil",
		"extends": "",
		"Methods": [
			{
				"signature": "private RestTestUtil()",
				"documentation": "/**\n * Utility class to configure the necessary tasks and dependencies.\n */"
			},
			{
				"signature": "public static Provider\u003cRestIntegTestTask\u003e registerTestTask(Project project, SourceSet sourceSet)",
				"documentation": "/**\n     * Creates a {@link RestIntegTestTask} task with the source set of the same name\n     */"
			},
			{
				"signature": "public static Provider\u003cRestIntegTestTask\u003e registerTestTask(Project project, SourceSet sourceSet, String taskName)",
				"documentation": "/**\n     * Creates a {@link RestIntegTestTask} task with a custom name for the provided source set\n     */"
			},
			{
				"signature": "public static void setupYamlRestTestDependenciesDefaults(Project project, SourceSet sourceSet)",
				"documentation": "/**\n     * Setup the dependencies needed for the YAML REST tests.\n     */"
			},
			{
				"signature": "public static void setupJavaRestTestDependenciesDefaults(Project project, SourceSet sourceSet)",
				"documentation": "/**\n     * Setup the dependencies needed for the Java REST tests.\n     */"
			}
		],
		"interfaces": []
	},
	{
		"documentation": "/**\n * An abstract common class to handle replacing key and values under a parent object\n * This class can be subclass to transform the\n * \"getKeyToFind\": {\"requiredChildKey\": \"foo\"}\n * into\n * \"getKeyToFind\": {\"newChildKey\": \"getReplacementNode\"}\n * a getKeyToFind and transformTest would have to be implemented in a subclass\n */",
		"name": "org.elasticsearch.gradle.internal.test.rest.transform.ReplaceByKey",
		"extends": "",
		"Methods": [
			{
				"signature": "public ReplaceByKey(String requiredChildKey, JsonNode replacementNode)",
				"documentation": "/**\n * An abstract common class to handle replacing key and values under a parent object\n * This class can be subclass to transform the\n * \"getKeyToFind\": {\"requiredChildKey\": \"foo\"}\n * into\n * \"getKeyToFind\": {\"newChildKey\": \"getReplacementNode\"}\n * a getKeyToFind and transformTest would have to be implemented in a subclass\n */"
			},
			{
				"signature": "public ReplaceByKey(String requiredChildKey, JsonNode replacementNode, String testName)",
				"documentation": ""
			},
			{
				"signature": "public ReplaceByKey(String requiredChildKey, String newChildKey, JsonNode replacementNode, String testName)",
				"documentation": ""
			},
			{
				"signature": "public String requiredChildKey()",
				"documentation": ""
			},
			{
				"signature": "public String getNewChildKey()",
				"documentation": ""
			},
			{
				"signature": "public boolean shouldApply(RestTestContext testContext)",
				"documentation": ""
			},
			{
				"signature": "public JsonNode getReplacementNode()",
				"documentation": ""
			},
			{
				"signature": "public String getTestName()",
				"documentation": ""
			}
		],
		"interfaces": [
			"RestTestTransformByParentObject"
		]
	},
	{
		"documentation": "/**\n * A place to stash information about a test that is being transformed.\n */",
		"name": "org.elasticsearch.gradle.internal.test.rest.transform.public",
		"extends": "",
		"Methods": [],
		"interfaces": []
	},
	{
		"documentation": "/**\n * Perform the transformations against the set of RestTests from a given file.\n */",
		"name": "org.elasticsearch.gradle.internal.test.rest.transform.RestTestTransformer",
		"extends": "",
		"Methods": [
			{
				"signature": "public List\u003cObjectNode\u003e transformRestTests(LinkedList\u003cObjectNode\u003e tests, List\u003cRestTestTransform\u003c?\u003e\u003e transformations)",
				"documentation": "/**\n     * Transforms a REST test based on the requested {@link RestTestTransform}'s\n     *\n     * @param tests           The REST tests from the same file. Uses linked list so we can easily add to the beginning of the list.\n     * @param transformations The set of transformations to perform against the test\n     * @return the transformed tests\n     */"
			},
			{
				"signature": "private void traverseTest(        RestTestContext testContext,        JsonNode currentNode,        String parentKeyName,        Map\u003cString, List\u003cRestTestTransformByParentObject\u003e\u003e objectKeyFinders,        Map\u003cString, List\u003cRestTestTransformByParentArray\u003e\u003e arrayByObjectKeyFinders    )",
				"documentation": "/**\n     * Recursive method to traverse the test.\n     *\n     * @param testContext             A pojo to hold information about the current state of the test that is being traversed.\n     * @param currentNode             The current node that is being evaluated.\n     * @param parentKeyName           The name of the parent key object for the current node. null if none.\n     * @param objectKeyFinders        A Map of object keys to find and their associated transformation by parent Object\n     * @param arrayByObjectKeyFinders A Map of object keys to find and their associated transformation by parent Array\n     */"
			}
		],
		"interfaces": []
	},
	{
		"documentation": "/**\n * A transformation to replace the key in a do. For example, change from \"do\":{\"some-thing\":{}} to \"do\":{\"some-other-thing\":{}}\n */",
		"name": "org.elasticsearch.gradle.internal.test.rest.transform.do_.ReplaceKeyInDo",
		"extends": "org.elasticsearch.gradle.internal.test.rest.transform.ReplaceByKey",
		"Methods": [
			{
				"signature": "public ReplaceKeyInDo(String replaceKey, String newKeyName, String testName)",
				"documentation": "/**\n * A transformation to replace the key in a do. For example, change from \"do\":{\"some-thing\":{}} to \"do\":{\"some-other-thing\":{}}\n */"
			},
			{
				"signature": "public String getKeyToFind()",
				"documentation": ""
			},
			{
				"signature": "public void transformTest(ObjectNode doParent)",
				"documentation": ""
			}
		],
		"interfaces": []
	},
	{
		"documentation": "/**\n * A parent class for transformations that are backed by a feature. This will inject the necessary \"feature\" into the\n * global setup and teardown section. See also org.elasticsearch.test.rest.yaml.Features for a list of possible features.\n */",
		"name": "org.elasticsearch.gradle.internal.test.rest.transform.feature.FeatureInjector",
		"extends": "",
		"Methods": [
			{
				"signature": "public ObjectNode transformSetup(ObjectNode setupNodeParent)",
				"documentation": "/**\n * A parent class for transformations that are backed by a feature. This will inject the necessary \"feature\" into the\n * global setup and teardown section. See also org.elasticsearch.test.rest.yaml.Features for a list of possible features.\n */"
			},
			{
				"signature": "public ObjectNode transformTeardown(@Nullable ObjectNode teardownNodeParent)",
				"documentation": ""
			},
			{
				"signature": "private boolean hasFeature(ArrayNode skipParent)",
				"documentation": "/**\n     * The name of the feature to skip. These are defined in org.elasticsearch.test.rest.yaml.Features and found in the tests at\n     * as the value of skip.feature. For example this method should return \"allowed_warnings\" :\n     * \u003cpre\u003e\n     * skip:\n     *       features: allowed_warnings\n     * \u003c/pre\u003e\n     */"
			},
			{
				"signature": "private void addSkip(ArrayNode skipParent)",
				"documentation": ""
			}
		],
		"interfaces": [
			"org.elasticsearch.gradle.internal.test.rest.transform.RestTestTransformGlobalSetup",
			"org.elasticsearch.gradle.internal.test.rest.transform.RestTestTransformGlobalTeardown"
		]
	},
	{
		"documentation": "/**\n * A {@link RestTestTransform} that injects HTTP headers into a REST test. This includes adding the necessary values to the \"do\" section\n * as well as adding headers as a features to the \"setup\" and \"teardown\" sections.\n */",
		"name": "org.elasticsearch.gradle.internal.test.rest.transform.headers.InjectHeaders",
		"extends": "org.elasticsearch.gradle.internal.test.rest.transform.feature.FeatureInjector",
		"Methods": [
			{
				"signature": "public InjectHeaders(Map\u003cString, String\u003e headers, Set\u003cFunction\u003cObjectNode, Boolean\u003e\u003e applyConditions)",
				"documentation": "/**\n     * @param headers The headers to inject\n     * @param applyConditions a set of conditions that has to be satisfied in order to apply headers\n     *                        If the Set is empty then headers are always applied.\n     */"
			},
			{
				"signature": "public void transformTest(ObjectNode doNodeParent)",
				"documentation": ""
			},
			{
				"signature": "private boolean shouldApplyHeaders(ObjectNode doNodeValue)",
				"documentation": ""
			},
			{
				"signature": "public String getKeyToFind()",
				"documentation": ""
			},
			{
				"signature": "public String getSkipFeatureName()",
				"documentation": ""
			},
			{
				"signature": "public Map\u003cString, String\u003e getHeaders()",
				"documentation": ""
			}
		],
		"interfaces": [
			"org.elasticsearch.gradle.internal.test.rest.transform.RestTestTransformByParentObject"
		]
	},
	{
		"documentation": "/**\n * A transformation to replace the key in a length assertion.\n * For example, change from \"length\":{\"index._type\": 1} to \"length\":{\"index._doc\": 1}\n */",
		"name": "org.elasticsearch.gradle.internal.test.rest.transform.length.ReplaceKeyInLength",
		"extends": "org.elasticsearch.gradle.internal.test.rest.transform.ReplaceByKey",
		"Methods": [
			{
				"signature": "public ReplaceKeyInLength(String replaceKey, String newKeyName, String testName)",
				"documentation": "/**\n * A transformation to replace the key in a length assertion.\n * For example, change from \"length\":{\"index._type\": 1} to \"length\":{\"index._doc\": 1}\n */"
			},
			{
				"signature": "public String getKeyToFind()",
				"documentation": ""
			},
			{
				"signature": "public void transformTest(ObjectNode lengthParent)",
				"documentation": ""
			}
		],
		"interfaces": []
	},
	{
		"documentation": "/**\n * A transformation to replace the key in a length assertion, must be a numeric type\n * For example, change from \"length\":{\"index._doc\": 1} to \"length\":{\"index._doc\": 2}\n */",
		"name": "org.elasticsearch.gradle.internal.test.rest.transform.length.ReplaceValueInLength",
		"extends": "org.elasticsearch.gradle.internal.test.rest.transform.ReplaceByKey",
		"Methods": [
			{
				"signature": "public ReplaceValueInLength(String replaceKey, NumericNode replacementNode)",
				"documentation": "/**\n * A transformation to replace the key in a length assertion, must be a numeric type\n * For example, change from \"length\":{\"index._doc\": 1} to \"length\":{\"index._doc\": 2}\n */"
			},
			{
				"signature": "public ReplaceValueInLength(String replaceKey, NumericNode replacementNode, String testName)",
				"documentation": ""
			},
			{
				"signature": "public String getKeyToFind()",
				"documentation": ""
			},
			{
				"signature": "public void transformTest(ObjectNode matchParent)",
				"documentation": ""
			}
		],
		"interfaces": []
	},
	{
		"documentation": "/**\n * Adds a match for a REST test. For example add the follow where it did not exist prior to running this: \"match\":{\"_type\": \"foo\"}\n */",
		"name": "org.elasticsearch.gradle.internal.test.rest.transform.match.AddMatch",
		"extends": "",
		"Methods": [
			{
				"signature": "public AddMatch(String matchKey, JsonNode matchValue, String testName)",
				"documentation": "/**\n * Adds a match for a REST test. For example add the follow where it did not exist prior to running this: \"match\":{\"_type\": \"foo\"}\n */"
			},
			{
				"signature": "public boolean shouldApply(RestTestContext testContext)",
				"documentation": ""
			},
			{
				"signature": "public void transformTest(ArrayNode matchParent)",
				"documentation": ""
			},
			{
				"signature": "public String getKeyOfArrayToFind()",
				"documentation": ""
			},
			{
				"signature": "public String getMatchKey()",
				"documentation": ""
			},
			{
				"signature": "public String getTestName()",
				"documentation": ""
			},
			{
				"signature": "public JsonNode getMatchValue()",
				"documentation": ""
			}
		],
		"interfaces": [
			"org.elasticsearch.gradle.internal.test.rest.transform.RestTestTransformByParentArray"
		]
	},
	{
		"documentation": "/**\n * A transformation to remove the key/value of a given match. To help keep logic simple, an empty match object will be left behind\n * if/when the only key/value is removed.\n */",
		"name": "org.elasticsearch.gradle.internal.test.rest.transform.match.RemoveMatch",
		"extends": "",
		"Methods": [
			{
				"signature": "public RemoveMatch(String removeKey)",
				"documentation": "/**\n * A transformation to remove the key/value of a given match. To help keep logic simple, an empty match object will be left behind\n * if/when the only key/value is removed.\n */"
			},
			{
				"signature": "public RemoveMatch(String removeKey, String testName)",
				"documentation": ""
			},
			{
				"signature": "public String getKeyToFind()",
				"documentation": ""
			},
			{
				"signature": "public String requiredChildKey()",
				"documentation": ""
			},
			{
				"signature": "public boolean shouldApply(RestTestContext testContext)",
				"documentation": ""
			},
			{
				"signature": "public void transformTest(ObjectNode matchParent)",
				"documentation": ""
			},
			{
				"signature": "public String getRemoveKey()",
				"documentation": ""
			},
			{
				"signature": "public String getTestName()",
				"documentation": ""
			}
		],
		"interfaces": [
			"org.elasticsearch.gradle.internal.test.rest.transform.RestTestTransformByParentObject"
		]
	},
	{
		"documentation": "/**\n * A transformation to replace the key in a match. For example, change from \"match\":{\"index._type\": \"foo\"} to \"match\":{\"index._doc\": \"foo\"}\n */",
		"name": "org.elasticsearch.gradle.internal.test.rest.transform.match.ReplaceKeyInMatch",
		"extends": "org.elasticsearch.gradle.internal.test.rest.transform.ReplaceByKey",
		"Methods": [
			{
				"signature": "public ReplaceKeyInMatch(String replaceKey, String newKeyName, String testName)",
				"documentation": "/**\n * A transformation to replace the key in a match. For example, change from \"match\":{\"index._type\": \"foo\"} to \"match\":{\"index._doc\": \"foo\"}\n */"
			},
			{
				"signature": "public String getKeyToFind()",
				"documentation": ""
			},
			{
				"signature": "public void transformTest(ObjectNode matchParent)",
				"documentation": ""
			}
		],
		"interfaces": []
	},
	{
		"documentation": "/**\n * A transformation to replace the value of a match. For example, change from \"match\":{\"_type\": \"foo\"} to \"match\":{\"_type\": \"bar\"}\n */",
		"name": "org.elasticsearch.gradle.internal.test.rest.transform.match.ReplaceValueInMatch",
		"extends": "org.elasticsearch.gradle.internal.test.rest.transform.ReplaceByKey",
		"Methods": [
			{
				"signature": "public ReplaceValueInMatch(String replaceKey, JsonNode replacementNode)",
				"documentation": "/**\n * A transformation to replace the value of a match. For example, change from \"match\":{\"_type\": \"foo\"} to \"match\":{\"_type\": \"bar\"}\n */"
			},
			{
				"signature": "public ReplaceValueInMatch(String replaceKey, JsonNode replacementNode, String testName)",
				"documentation": ""
			},
			{
				"signature": "public String getKeyToFind()",
				"documentation": ""
			},
			{
				"signature": "public void transformTest(ObjectNode matchParent)",
				"documentation": ""
			}
		],
		"interfaces": []
	},
	{
		"documentation": "/**\n * A {@link RestTestTransform} that injects a skip into a REST test.\n */",
		"name": "org.elasticsearch.gradle.internal.test.rest.transform.skip.Skip",
		"extends": "",
		"Methods": [
			{
				"signature": "public Skip(String testName, String skipReason)",
				"documentation": "/**\n * A {@link RestTestTransform} that injects a skip into a REST test.\n */"
			},
			{
				"signature": "public Skip(String skipReason)",
				"documentation": ""
			},
			{
				"signature": "public ObjectNode transformSetup(ObjectNode setupNodeParent)",
				"documentation": ""
			},
			{
				"signature": "private void addSkip(ArrayNode skipParent)",
				"documentation": ""
			},
			{
				"signature": "public void transformTest(ObjectNode parent)",
				"documentation": ""
			},
			{
				"signature": "public String getKeyToFind()",
				"documentation": ""
			},
			{
				"signature": "public String getSkipReason()",
				"documentation": ""
			},
			{
				"signature": "public String getTestName()",
				"documentation": ""
			}
		],
		"interfaces": [
			"org.elasticsearch.gradle.internal.test.rest.transform.RestTestTransformGlobalSetup",
			"org.elasticsearch.gradle.internal.test.rest.transform.RestTestTransformByParentObject"
		]
	},
	{
		"documentation": "",
		"name": "org.elasticsearch.gradle.internal.test.rest.transform.text.ReplaceIsFalse",
		"extends": "ReplaceTextual",
		"Methods": [
			{
				"signature": "public ReplaceIsFalse(String valueToBeReplaced, TextNode replacementNode)",
				"documentation": ""
			},
			{
				"signature": "public ReplaceIsFalse(String valueToBeReplaced, TextNode replacementNode, String testName)",
				"documentation": ""
			}
		],
		"interfaces": []
	},
	{
		"documentation": "",
		"name": "org.elasticsearch.gradle.internal.test.rest.transform.text.ReplaceIsTrue",
		"extends": "ReplaceTextual",
		"Methods": [
			{
				"signature": "public ReplaceIsTrue(String valueToBeReplaced, TextNode replacementNode)",
				"documentation": ""
			}
		],
		"interfaces": []
	},
	{
		"documentation": "/**\n * A transformation to replace a key/value combination.\n */",
		"name": "org.elasticsearch.gradle.internal.test.rest.transform.text.ReplaceTextual",
		"extends": "",
		"Methods": [
			{
				"signature": "public ReplaceTextual(String keyToReplaceName, String valueToBeReplaced, TextNode replacementNode)",
				"documentation": "/**\n * A transformation to replace a key/value combination.\n */"
			},
			{
				"signature": "public ReplaceTextual(String keyToReplaceName, String valueToBeReplaced, TextNode replacementNode, String testName)",
				"documentation": ""
			},
			{
				"signature": "public String getKeyToFind()",
				"documentation": ""
			},
			{
				"signature": "public String requiredChildKey()",
				"documentation": ""
			},
			{
				"signature": "public boolean shouldApply(RestTestContext testContext)",
				"documentation": ""
			},
			{
				"signature": "public void transformTest(ObjectNode matchParent)",
				"documentation": ""
			},
			{
				"signature": "public String getValueToBeReplaced()",
				"documentation": ""
			},
			{
				"signature": "public JsonNode getReplacementNode()",
				"documentation": ""
			},
			{
				"signature": "public String getTestName()",
				"documentation": ""
			},
			{
				"signature": "public boolean matches(JsonNode child)",
				"documentation": ""
			}
		],
		"interfaces": [
			"org.elasticsearch.gradle.internal.test.rest.transform.RestTestTransformByParentObject"
		]
	},
	{
		"documentation": "/**\n * A transformation to inject an allowed warning.\n */",
		"name": "org.elasticsearch.gradle.internal.test.rest.transform.warnings.InjectAllowedWarnings",
		"extends": "org.elasticsearch.gradle.internal.test.rest.transform.feature.FeatureInjector",
		"Methods": [
			{
				"signature": "public InjectAllowedWarnings(List\u003cString\u003e allowedWarnings)",
				"documentation": "/**\n     * @param allowedWarnings The allowed warnings to inject\n     */"
			},
			{
				"signature": "public InjectAllowedWarnings(boolean isRegex, List\u003cString\u003e allowedWarnings)",
				"documentation": "/**\n     * @param isRegex true if should inject the regex variant of allowed warnings\n     * @param allowedWarnings The allowed warnings to inject\n     */"
			},
			{
				"signature": "public InjectAllowedWarnings(boolean isRegex, List\u003cString\u003e allowedWarnings, String testName)",
				"documentation": "/**\n     * @param isRegex true if should inject the regex variant of allowed warnings\n     * @param allowedWarnings The allowed warnings to inject\n     * @param testName The testName to inject\n     */"
			},
			{
				"signature": "public void transformTest(ObjectNode doNodeParent)",
				"documentation": ""
			},
			{
				"signature": "public String getKeyToFind()",
				"documentation": ""
			},
			{
				"signature": "public String getSkipFeatureName()",
				"documentation": ""
			},
			{
				"signature": "public List\u003cString\u003e getAllowedWarnings()",
				"documentation": ""
			},
			{
				"signature": "public boolean shouldApply(RestTestContext testContext)",
				"documentation": ""
			},
			{
				"signature": "public String getTestName()",
				"documentation": ""
			}
		],
		"interfaces": [
			"org.elasticsearch.gradle.internal.test.rest.transform.RestTestTransformByParentObject"
		]
	},
	{
		"documentation": "/**\n * A transformation to inject an expected warning for a given test.\n */",
		"name": "org.elasticsearch.gradle.internal.test.rest.transform.warnings.InjectWarnings",
		"extends": "org.elasticsearch.gradle.internal.test.rest.transform.feature.FeatureInjector",
		"Methods": [
			{
				"signature": "public InjectWarnings(List\u003cString\u003e warnings, String testName)",
				"documentation": "/**\n     * @param warnings The warnings to inject\n     * @param testName The testName to inject\n     */"
			},
			{
				"signature": "public InjectWarnings(boolean isRegex, List\u003cString\u003e warnings, String testName)",
				"documentation": "/**\n     * @param isRegex true is should inject the regex variant of warning\n     * @param warnings The warnings to inject\n     * @param testName The testName to inject\n     */"
			},
			{
				"signature": "public void transformTest(ObjectNode doNodeParent)",
				"documentation": ""
			},
			{
				"signature": "public String getKeyToFind()",
				"documentation": ""
			},
			{
				"signature": "public String getSkipFeatureName()",
				"documentation": ""
			},
			{
				"signature": "public boolean shouldApply(RestTestContext testContext)",
				"documentation": ""
			},
			{
				"signature": "public List\u003cString\u003e getWarnings()",
				"documentation": ""
			},
			{
				"signature": "public String getTestName()",
				"documentation": ""
			}
		],
		"interfaces": [
			"org.elasticsearch.gradle.internal.test.rest.transform.RestTestTransformByParentObject"
		]
	},
	{
		"documentation": "/**\n * A transformation to to remove any warnings that match exactly.\n * If this removes all of the warnings, this will not remove the feature from the setup and/or teardown and will leave behind an empty array\n * While it would be more technically correct to do so, the effort/complexity does not warrant it, since for the expected usage it makes\n * no difference.\n */",
		"name": "org.elasticsearch.gradle.internal.test.rest.transform.warnings.RemoveWarnings",
		"extends": "",
		"Methods": [
			{
				"signature": "public RemoveWarnings(Set\u003cString\u003e warnings)",
				"documentation": "/**\n     * @param warnings The allowed warnings to inject\n     */"
			},
			{
				"signature": "public RemoveWarnings(Set\u003cString\u003e warnings, String testName)",
				"documentation": "/**\n     * @param warnings The allowed warnings to inject\n     * @param testName The testName to inject\n     */"
			},
			{
				"signature": "public void transformTest(ObjectNode doNodeParent)",
				"documentation": ""
			},
			{
				"signature": "public String getKeyToFind()",
				"documentation": ""
			},
			{
				"signature": "public Set\u003cString\u003e getWarnings()",
				"documentation": ""
			},
			{
				"signature": "public boolean shouldApply(RestTestContext testContext)",
				"documentation": ""
			},
			{
				"signature": "public String getTestName()",
				"documentation": ""
			}
		],
		"interfaces": [
			"org.elasticsearch.gradle.internal.test.rest.transform.RestTestTransformByParentObject"
		]
	},
	{
		"documentation": "",
		"name": "org.elasticsearch.gradle.internal.testfixtures.DockerComposeThrottle",
		"extends": "",
		"Methods": [],
		"interfaces": [
			"org.gradle.api.services.BuildService"
		]
	},
	{
		"documentation": "",
		"name": "org.elasticsearch.gradle.internal.testfixtures.TestFixtureExtension",
		"extends": "",
		"Methods": [
			{
				"signature": "public TestFixtureExtension(Project project)",
				"documentation": ""
			},
			{
				"signature": "public void useFixture()",
				"documentation": ""
			},
			{
				"signature": "public void useFixture(String path)",
				"documentation": ""
			},
			{
				"signature": "public void useFixture(String path, String serviceName)",
				"documentation": ""
			},
			{
				"signature": "private String getServiceNameKey(String fixtureProjectPath, String serviceName)",
				"documentation": ""
			},
			{
				"signature": "private Optional\u003cString\u003e findOtherProjectUsingService(String serviceName)",
				"documentation": ""
			},
			{
				"signature": "private void addFixtureProject(String path)",
				"documentation": ""
			},
			{
				"signature": "boolean isServiceRequired(String serviceName, String fixtureProject)",
				"documentation": ""
			}
		],
		"interfaces": []
	},
	{
		"documentation": "",
		"name": "org.elasticsearch.gradle.internal.testfixtures.TestFixturesPlugin",
		"extends": "",
		"Methods": [
			{
				"signature": "protected FileSystemOperations getFileSystemOperations()",
				"documentation": ""
			},
			{
				"signature": "public void apply(Project project)",
				"documentation": ""
			},
			{
				"signature": "public void execute(Task task)",
				"documentation": ""
			},
			{
				"signature": "private void maybeSkipTasks(TaskContainer tasks, Provider\u003cDockerSupportService\u003e dockerSupport, Class\u003c? extends DefaultTask\u003e taskClass)",
				"documentation": ""
			},
			{
				"signature": "private void maybeSkipTask(Provider\u003cDockerSupportService\u003e dockerSupport, TaskProvider\u003cTask\u003e task)",
				"documentation": ""
			},
			{
				"signature": "private void maybeSkipTask(Provider\u003cDockerSupportService\u003e dockerSupport, Task task)",
				"documentation": ""
			},
			{
				"signature": "private void configureServiceInfoForTask(        Task task,        Project fixtureProject,        boolean enableFilter,        BiConsumer\u003cString, Integer\u003e consumer    )",
				"documentation": ""
			},
			{
				"signature": "public void execute(Task theTask)",
				"documentation": ""
			},
			{
				"signature": "private Class\u003c? extends DefaultTask\u003e getTaskClass(String type)",
				"documentation": ""
			}
		],
		"interfaces": [
			"org.gradle.api.Plugin"
		]
	},
	{
		"documentation": "",
		"name": "org.elasticsearch.gradle.internal.util.HdfsUtils",
		"extends": "",
		"Methods": [
			{
				"signature": "public static boolean isHdfsFixtureSupported(Project project)",
				"documentation": ""
			},
			{
				"signature": "private static boolean isHadoopWindowsInstallationAvailable()",
				"documentation": ""
			},
			{
				"signature": "public static boolean isLegalHdfsPath(String path)",
				"documentation": ""
			}
		],
		"interfaces": []
	},
	{
		"documentation": "",
		"name": "org.elasticsearch.gradle.internal.util.JavaUtil",
		"extends": "",
		"Methods": [
			{
				"signature": "public static String getJavaHome(final int version)",
				"documentation": "/** A convenience method for getting java home for a version of java and requiring that version for the given task to execute */"
			}
		],
		"interfaces": []
	},
	{
		"documentation": "",
		"name": "org.elasticsearch.gradle.internal.util.ports.AvailablePortAllocator",
		"extends": "",
		"Methods": [
			{
				"signature": "protected Pair\u003cInteger, Integer\u003e getNextPortRange(int rangeNumber)",
				"documentation": ""
			},
			{
				"signature": "public ReservedPortRange reservePortRange()",
				"documentation": ""
			}
		],
		"interfaces": []
	},
	{
		"documentation": "",
		"name": "org.elasticsearch.gradle.internal.util.ports.DefaultPortDetector",
		"extends": "",
		"Methods": [
			{
				"signature": "public boolean isAvailable(int port)",
				"documentation": "/**\n     * Checks to see if a specific port is available.\n     *\n     * @param port the port to check for availability\n     * @return true if the port is available, false otherwise\n     */"
			}
		],
		"interfaces": [
			"PortDetector"
		]
	},
	{
		"documentation": "",
		"name": "org.elasticsearch.gradle.internal.util.ports.DefaultReservedPortRangeFactory",
		"extends": "",
		"Methods": [
			{
				"signature": "public ReservedPortRange getReservedPortRange(int startPort, int endPort)",
				"documentation": ""
			}
		],
		"interfaces": [
			"ReservedPortRangeFactory"
		]
	},
	{
		"documentation": "",
		"name": "org.elasticsearch.gradle.internal.util.ports.ReservedPortRange",
		"extends": "",
		"Methods": [
			{
				"signature": "public ReservedPortRange(int startPort, int endPort)",
				"documentation": ""
			},
			{
				"signature": "public List\u003cInteger\u003e getAllocated()",
				"documentation": ""
			},
			{
				"signature": "public final Integer getOrAllocate(String id)",
				"documentation": ""
			},
			{
				"signature": "public final Integer getAllocated(String id)",
				"documentation": ""
			},
			{
				"signature": "public int getCurrent()",
				"documentation": ""
			},
			{
				"signature": "public void setCurrent(int current)",
				"documentation": ""
			},
			{
				"signature": "int allocate()",
				"documentation": "/**\n     * Allocate an available port\n     *\n     * @return the port that was allocated\n     */"
			},
			{
				"signature": "public void deallocate(int port)",
				"documentation": "/**\n     * Deallocate the given port\n     *\n     * @param port The port to deallocate\n     */"
			},
			{
				"signature": "private int getAvailablePort()",
				"documentation": ""
			},
			{
				"signature": "public String toString()",
				"documentation": ""
			}
		],
		"interfaces": []
	},
	{
		"documentation": "",
		"name": "org.elasticsearch.gradle.internal.vagrant.VagrantBasePlugin",
		"extends": "",
		"Methods": [
			{
				"signature": "public void apply(Project project)",
				"documentation": ""
			}
		],
		"interfaces": [
			"org.gradle.api.Plugin"
		]
	},
	{
		"documentation": "/**\n     * Check vagrant and virtualbox versions, if any vagrant test tasks will be run.\n     */",
		"name": "org.elasticsearch.gradle.internal.vagrant.VagrantBasePlugin.VagrantSetupCheckerPlugin",
		"extends": "",
		"Methods": [
			{
				"signature": "public void apply(Project project)",
				"documentation": "/**\n     * Check vagrant and virtualbox versions, if any vagrant test tasks will be run.\n     */"
			},
			{
				"signature": "void checkVersion(Project project, String tool, Pattern versionRegex, int... minVersion)",
				"documentation": ""
			}
		],
		"interfaces": [
			"org.gradle.api.Plugin"
		]
	},
	{
		"documentation": "/**\n     * Adds global hooks to manage destroying, starting and updating VMs.\n     */",
		"name": "org.elasticsearch.gradle.internal.vagrant.VagrantBasePlugin.VagrantManagerPlugin",
		"extends": "",
		"Methods": [
			{
				"signature": "public void apply(Project project)",
				"documentation": "/**\n     * Adds global hooks to manage destroying, starting and updating VMs.\n     */"
			},
			{
				"signature": "private void callIfVagrantTask(Task task, Consumer\u003cVagrantMachine\u003e method)",
				"documentation": ""
			},
			{
				"signature": "public void beforeExecute(Task task)",
				"documentation": ""
			},
			{
				"signature": "public void afterActions(Task task)",
				"documentation": ""
			},
			{
				"signature": "public void beforeActions(Task task)",
				"documentation": ""
			},
			{
				"signature": "public void afterExecute(Task task, TaskState state)",
				"documentation": ""
			}
		],
		"interfaces": [
			"org.gradle.api.Plugin",
			"org.gradle.api.execution.TaskActionListener",
			"org.gradle.api.execution.TaskExecutionListener"
		]
	},
	{
		"documentation": "",
		"name": "org.elasticsearch.gradle.internal.vagrant.VagrantExtension",
		"extends": "",
		"Methods": [
			{
				"signature": "public VagrantExtension(Project project)",
				"documentation": ""
			},
			{
				"signature": "public String getBox()",
				"documentation": ""
			},
			{
				"signature": "public void setBox(String box)",
				"documentation": ""
			},
			{
				"signature": "public Map\u003cString, Object\u003e getHostEnv()",
				"documentation": ""
			},
			{
				"signature": "public void hostEnv(String name, Object value)",
				"documentation": ""
			},
			{
				"signature": "public Map\u003cString, Object\u003e getVmEnv()",
				"documentation": ""
			},
			{
				"signature": "public void vmEnv(String name, Object value)",
				"documentation": ""
			},
			{
				"signature": "public boolean isWindowsVM()",
				"documentation": ""
			},
			{
				"signature": "public void setIsWindowsVM(boolean isWindowsVM)",
				"documentation": ""
			},
			{
				"signature": "public File getVagrantfile()",
				"documentation": ""
			},
			{
				"signature": "public void setVagrantfile(File file)",
				"documentation": ""
			}
		],
		"interfaces": []
	},
	{
		"documentation": "/**\n * An helper to manage a vagrant box.\n *\n * This is created alongside a {@link VagrantExtension} for a project to manage starting and\n * stopping a single vagrant box.\n */",
		"name": "org.elasticsearch.gradle.internal.vagrant.VagrantMachine",
		"extends": "",
		"Methods": [
			{
				"signature": "public VagrantMachine(VagrantExtension extension, Provider\u003cReaperService\u003e reaperServiceProvider)",
				"documentation": "/**\n * An helper to manage a vagrant box.\n *\n * This is created alongside a {@link VagrantExtension} for a project to manage starting and\n * stopping a single vagrant box.\n */"
			},
			{
				"signature": "protected ProgressLoggerFactory getProgressLoggerFactory()",
				"documentation": ""
			},
			{
				"signature": "protected ExecOperations getExecOperations()",
				"documentation": ""
			},
			{
				"signature": "public void execute(Action\u003cVagrantExecSpec\u003e action)",
				"documentation": ""
			},
			{
				"signature": "void maybeStartVM()",
				"documentation": ""
			},
			{
				"signature": "void maybeStopVM(boolean force)",
				"documentation": ""
			},
			{
				"signature": "public static String convertLinuxPath(File rootDir, String path)",
				"documentation": ""
			},
			{
				"signature": "public static String convertWindowsPath(File rootDir, String path)",
				"documentation": ""
			}
		],
		"interfaces": []
	},
	{
		"documentation": "",
		"name": "org.elasticsearch.gradle.internal.vagrant.VagrantMachine.VagrantExecSpec",
		"extends": "",
		"Methods": [
			{
				"signature": "private VagrantExecSpec()",
				"documentation": ""
			},
			{
				"signature": "public void setCommand(String command)",
				"documentation": ""
			},
			{
				"signature": "public void setSubcommand(String subcommand)",
				"documentation": ""
			},
			{
				"signature": "public void setArgs(String... args)",
				"documentation": ""
			},
			{
				"signature": "public void setProgressHandler(UnaryOperator\u003cString\u003e progressHandler)",
				"documentation": "/**\n         * A function to translate output from the vagrant command execution to the progress line.\n         *\n         * The function takes the current line of output from vagrant, and returns a new\n         * progress line, or {@code null} if there is no update.\n         */"
			}
		],
		"interfaces": []
	},
	{
		"documentation": "",
		"name": "org.elasticsearch.gradle.internal.vagrant.ProgressOutputStream",
		"extends": "org.elasticsearch.gradle.internal.LoggingOutputStream",
		"Methods": [
			{
				"signature": "ProgressOutputStream(String command, UnaryOperator\u003cString\u003e progressHandler)",
				"documentation": ""
			},
			{
				"signature": "protected void logLine(String line)",
				"documentation": ""
			},
			{
				"signature": "public void close()",
				"documentation": ""
			}
		],
		"interfaces": []
	},
	{
		"documentation": "",
		"name": "org.elasticsearch.gradle.internal.vagrant.VagrantProgressLogger",
		"extends": "",
		"Methods": [
			{
				"signature": "public VagrantProgressLogger(String squashedPrefix)",
				"documentation": ""
			},
			{
				"signature": "public String apply(String line)",
				"documentation": ""
			}
		],
		"interfaces": [
			"java.util.function.UnaryOperator"
		]
	},
	{
		"documentation": "/**\n * A shell script to run within a vagrant VM.\n *\n * The script is run as root within the VM.\n */",
		"name": "org.elasticsearch.gradle.internal.vagrant.VagrantShellTask",
		"extends": "org.gradle.api.DefaultTask",
		"Methods": [
			{
				"signature": "public VagrantShellTask(BuildLayout buildLayout)",
				"documentation": "/**\n * A shell script to run within a vagrant VM.\n *\n * The script is run as root within the VM.\n */"
			},
			{
				"signature": "public UnaryOperator\u003cString\u003e getProgressHandler()",
				"documentation": ""
			},
			{
				"signature": "public void setProgressHandler(UnaryOperator\u003cString\u003e progressHandler)",
				"documentation": ""
			},
			{
				"signature": "public void setExtension(VagrantExtension extension)",
				"documentation": ""
			},
			{
				"signature": "public void setService(VagrantMachine service)",
				"documentation": ""
			},
			{
				"signature": "public void runScript()",
				"documentation": ""
			}
		],
		"interfaces": []
	},
	{
		"documentation": "",
		"name": "org.elasticsearch.gradle.AbstractDistributionDownloadPluginTests",
		"extends": "org.elasticsearch.gradle.internal.test.GradleUnitTestCase",
		"Methods": [
			{
				"signature": "protected static String projectName(String base, boolean bundledJdk)",
				"documentation": ""
			},
			{
				"signature": "protected void checkBwc(        String projectName,        String config,        Version version,        ElasticsearchDistributionType type,        ElasticsearchDistribution.Platform platform,        BwcVersions bwcVersions    )",
				"documentation": ""
			},
			{
				"signature": "protected ElasticsearchDistribution createDistro(        Project project,        String name,        String version,        ElasticsearchDistributionType type,        ElasticsearchDistribution.Platform platform,        Boolean bundledJdk    )",
				"documentation": ""
			},
			{
				"signature": "protected Project createProject(BwcVersions bwcVersions)",
				"documentation": ""
			}
		],
		"interfaces": []
	},
	{
		"documentation": "",
		"name": "org.elasticsearch.gradle.DistributionDownloadPluginTests",
		"extends": "AbstractDistributionDownloadPluginTests",
		"Methods": [
			{
				"signature": "public void testVersionDefault()",
				"documentation": ""
			},
			{
				"signature": "public void testBadVersionFormat()",
				"documentation": ""
			},
			{
				"signature": "public void testTypeDefault()",
				"documentation": ""
			},
			{
				"signature": "public void testPlatformDefault()",
				"documentation": ""
			},
			{
				"signature": "public void testPlatformForIntegTest()",
				"documentation": ""
			},
			{
				"signature": "public void testBundledJdkDefault()",
				"documentation": ""
			},
			{
				"signature": "public void testBundledJdkForIntegTest()",
				"documentation": ""
			},
			{
				"signature": "public void testLocalCurrentVersionIntegTestZip()",
				"documentation": ""
			},
			{
				"signature": "public void testLocalCurrentVersionArchives()",
				"documentation": ""
			},
			{
				"signature": ")",
				"documentation": ""
			},
			{
				"signature": "public void testLocalBwcArchives()",
				"documentation": ""
			},
			{
				"signature": "private void assertDistroError(        Project project,        String name,        String version,        ElasticsearchDistributionType type,        Platform platform,        Boolean bundledJdk,        String message    )",
				"documentation": ""
			},
			{
				"signature": "private ElasticsearchDistribution checkDistro(        Project project,        String name,        String version,        ElasticsearchDistributionType type,        Platform platform,        Boolean bundledJdk    )",
				"documentation": ""
			}
		],
		"interfaces": []
	},
	{
		"documentation": "",
		"name": "org.elasticsearch.gradle.internal.ConcatFilesTaskTests",
		"extends": "org.elasticsearch.gradle.internal.test.GradleUnitTestCase",
		"Methods": [
			{
				"signature": "public void testHeaderAdded() throws IOException",
				"documentation": ""
			},
			{
				"signature": "public void testConcatenationWithUnique() throws IOException",
				"documentation": ""
			},
			{
				"signature": "private Project createProject()",
				"documentation": ""
			},
			{
				"signature": "private ConcatFilesTask createTask(Project project)",
				"documentation": ""
			}
		],
		"interfaces": []
	},
	{
		"documentation": "",
		"name": "org.elasticsearch.gradle.internal.EmptyDirTaskTests",
		"extends": "org.elasticsearch.gradle.internal.test.GradleUnitTestCase",
		"Methods": [
			{
				"signature": "public void testCreateEmptyDir() throws Exception",
				"documentation": ""
			},
			{
				"signature": "public void testCreateEmptyDirNoPermissions() throws Exception",
				"documentation": ""
			},
			{
				"signature": "private File getNewNonExistingTempFolderFile(Project project) throws IOException",
				"documentation": ""
			}
		],
		"interfaces": []
	},
	{
		"documentation": "",
		"name": "org.elasticsearch.gradle.internal.InternalDistributionDownloadPluginTests",
		"extends": "org.elasticsearch.gradle.AbstractDistributionDownloadPluginTests",
		"Methods": [
			{
				"signature": "public void testLocalCurrentVersionPackages()",
				"documentation": ""
			},
			{
				"signature": ")",
				"documentation": ""
			},
			{
				"signature": "public void testLocalBwcPackages()",
				"documentation": ""
			}
		],
		"interfaces": []
	},
	{
		"documentation": "",
		"name": "org.elasticsearch.gradle.internal.JdkDownloadPluginTests",
		"extends": "org.elasticsearch.gradle.internal.test.GradleUnitTestCase",
		"Methods": [
			{
				"signature": "public static void setupRoot()",
				"documentation": ""
			},
			{
				"signature": "public void testMissingVendor()",
				"documentation": ""
			},
			{
				"signature": "public void testUnknownVendor()",
				"documentation": ""
			},
			{
				"signature": "public void testMissingVersion()",
				"documentation": ""
			},
			{
				"signature": "public void testBadVersionFormat()",
				"documentation": ""
			},
			{
				"signature": "public void testMissingPlatform()",
				"documentation": ""
			},
			{
				"signature": "public void testUnknownPlatform()",
				"documentation": ""
			},
			{
				"signature": "public void testMissingArchitecture()",
				"documentation": ""
			},
			{
				"signature": "public void testUnknownArchitecture()",
				"documentation": ""
			},
			{
				"signature": "private void assertJdkError(        final Project project,        final String name,        final String vendor,        final String version,        final String platform,        final String architecture,        final String message    )",
				"documentation": ""
			},
			{
				"signature": "private void createJdk(Project project, String name, String vendor, String version, String platform, String architecture)",
				"documentation": ""
			},
			{
				"signature": "private Project createProject()",
				"documentation": ""
			}
		],
		"interfaces": []
	},
	{
		"documentation": "",
		"name": "org.elasticsearch.gradle.internal.checkstyle.SnipptLengthCheckTests",
		"extends": "org.elasticsearch.gradle.internal.test.GradleUnitTestCase",
		"Methods": [
			{
				"signature": "public void testNoSnippets()",
				"documentation": ""
			},
			{
				"signature": "public void testEmptySnippet()",
				"documentation": ""
			},
			{
				"signature": "public void testSnippetWithSmallText()",
				"documentation": ""
			},
			{
				"signature": "public void testSnippetWithLeadingSpaces()",
				"documentation": ""
			},
			{
				"signature": "public void testSnippetWithEmptyLine()",
				"documentation": ""
			},
			{
				"signature": "public void testSnippetBrokenLeadingSpaces()",
				"documentation": ""
			},
			{
				"signature": "public void testSnippetTooLong()",
				"documentation": ""
			},
			{
				"signature": "public void testLotsOfErrors()",
				"documentation": ""
			},
			{
				"signature": "private BiConsumer\u003cInteger, String\u003e failOnError()",
				"documentation": ""
			},
			{
				"signature": "private BiConsumer\u003cInteger, String\u003e collect(List\u003cString\u003e collection)",
				"documentation": ""
			}
		],
		"interfaces": []
	},
	{
		"documentation": "",
		"name": "org.elasticsearch.gradle.internal.doc.RestTestFromSnippetsTaskTests",
		"extends": "org.elasticsearch.gradle.internal.test.GradleUnitTestCase",
		"Methods": [
			{
				"signature": "public void testInvalidBlockQuote()",
				"documentation": ""
			},
			{
				"signature": "public void testSimpleBlockQuote()",
				"documentation": ""
			},
			{
				"signature": "public void testMultipleBlockQuotes()",
				"documentation": ""
			},
			{
				"signature": "public void testEscapingInBlockQuote()",
				"documentation": ""
			},
			{
				"signature": "public void testIsDocWriteRequest()",
				"documentation": ""
			}
		],
		"interfaces": []
	},
	{
		"documentation": "",
		"name": "org.elasticsearch.gradle.internal.doc.SnippetsTaskTests",
		"extends": "org.elasticsearch.gradle.internal.test.GradleUnitTestCase",
		"Methods": [
			{
				"signature": "public void testMatchSource()",
				"documentation": ""
			}
		],
		"interfaces": []
	},
	{
		"documentation": "",
		"name": "org.elasticsearch.gradle.internal.docker.DockerSupportServiceTests",
		"extends": "org.elasticsearch.gradle.internal.test.GradleUnitTestCase",
		"Methods": [
			{
				"signature": "public void testParseOsReleaseOnOracle()",
				"documentation": ""
			},
			{
				"signature": "public void testRemoveTrailingWhitespace()",
				"documentation": "/**\n     * Trailing whitespace should be removed\n     */"
			},
			{
				"signature": "public void testRemoveComments()",
				"documentation": "/**\n     * Comments should be removed\n     */"
			},
			{
				"signature": "public void testDeriveIdOnOracle()",
				"documentation": ""
			}
		],
		"interfaces": []
	},
	{
		"documentation": "",
		"name": "org.elasticsearch.gradle.internal.docker.TransformLog4jConfigFilterTests",
		"extends": "org.elasticsearch.gradle.internal.test.GradleUnitTestCase",
		"Methods": [
			{
				"signature": "public void testTransformEmptyConfig()",
				"documentation": "/**\n     * Check that the transformer doesn't explode when given an empty file.\n     */"
			},
			{
				"signature": "public void testTransformEchoesNonAppenderLines()",
				"documentation": "/**\n     * Check that the transformer leaves non-appender lines alone.\n     */"
			},
			{
				"signature": "public void testTransformFiltersRootLogger()",
				"documentation": "/**\n     * Check that the root logger appenders are filtered to just the \"rolling\" appender\n     */"
			},
			{
				"signature": "public void testTransformRemoveExplicitConsoleAndRollingOldAppenders()",
				"documentation": "/**\n     * Check that any explicit 'console' or 'rolling_old' appenders are removed.\n     */"
			},
			{
				"signature": "public void testTransformConvertsRollingToConsole()",
				"documentation": "/**\n     * Check that rolling file appenders are converted to console appenders.\n     */"
			},
			{
				"signature": "public void testTransformRemovedRedundantProperties()",
				"documentation": "/**\n     * Check that rolling file appenders have redundant properties removed.\n     */"
			},
			{
				"signature": "public void testTransformSkipsPropertiesWithLineBreaks()",
				"documentation": "/**\n     * Check that rolling file appenders have redundant properties removed.\n     */"
			},
			{
				"signature": "public void testTransformSkipsOldAppenderRefs()",
				"documentation": "/**\n     * Check that as well as skipping old appenders, logger references to them are also skipped.\n     */"
			},
			{
				"signature": "public void testMultipleBlanksReducedToOne()",
				"documentation": "/**\n     * Check that multiple blank lines are reduced to a single line.\n     */"
			},
			{
				"signature": "private void runTest(List\u003cString\u003e input, List\u003cString\u003e expected)",
				"documentation": ""
			}
		],
		"interfaces": []
	},
	{
		"documentation": "",
		"name": "org.elasticsearch.gradle.internal.precommit.DependencyLicensesTaskTests",
		"extends": "org.elasticsearch.gradle.internal.test.GradleUnitTestCase",
		"Methods": [
			{
				"signature": "public void prepare()",
				"documentation": ""
			},
			{
				"signature": "public void execute(DependencyLicensesTask dependencyLicensesTask)",
				"documentation": ""
			},
			{
				"signature": "public void givenProjectWithLicensesDirButNoDependenciesThenShouldThrowException() throws Exception",
				"documentation": ""
			},
			{
				"signature": "public void givenProjectWithoutLicensesDirButWithDependenciesThenShouldThrowException() throws Exception",
				"documentation": ""
			},
			{
				"signature": "public void givenProjectWithoutLicensesDirNorDependenciesThenShouldReturnSilently() throws Exception",
				"documentation": ""
			},
			{
				"signature": "public void givenProjectWithDependencyButNoShaFileThenShouldReturnException() throws Exception",
				"documentation": ""
			},
			{
				"signature": "public void givenProjectWithDependencyButNoLicenseFileThenShouldReturnException() throws Exception",
				"documentation": ""
			},
			{
				"signature": "public void givenProjectWithDependencyButNoNoticeFileThenShouldReturnException() throws Exception",
				"documentation": ""
			},
			{
				"signature": "public void givenProjectWithStrictDependencyButNoSourcesFileThenShouldReturnException() throws Exception",
				"documentation": ""
			},
			{
				"signature": "public void givenProjectWithStrictDependencyAndEverythingInOrderThenShouldReturnSilently() throws Exception",
				"documentation": ""
			},
			{
				"signature": "public void givenProjectWithDependencyAndEverythingInOrderThenShouldReturnSilently() throws Exception",
				"documentation": ""
			},
			{
				"signature": "public void givenProjectWithALicenseButWithoutTheDependencyThenShouldThrowException() throws Exception",
				"documentation": ""
			},
			{
				"signature": "public void givenProjectWithANoticeButWithoutTheDependencyThenShouldThrowException() throws Exception",
				"documentation": ""
			},
			{
				"signature": "public void givenProjectWithAShaButWithoutTheDependencyThenShouldThrowException() throws Exception",
				"documentation": ""
			},
			{
				"signature": "public void givenProjectWithADependencyWithWrongShaThenShouldThrowException() throws Exception",
				"documentation": ""
			},
			{
				"signature": "public void givenProjectWithADependencyMappingThenShouldReturnSilently() throws Exception",
				"documentation": ""
			},
			{
				"signature": "public void givenProjectWithAIgnoreShaConfigurationAndNoShaFileThenShouldReturnSilently() throws Exception",
				"documentation": ""
			},
			{
				"signature": "public void givenProjectWithoutLicensesDirWhenAskingForShaFilesThenShouldThrowException()",
				"documentation": ""
			},
			{
				"signature": "private Project createProject()",
				"documentation": ""
			},
			{
				"signature": "private void createAllDefaultDependencyFiles(File licensesDir, String dependencyName) throws IOException, NoSuchAlgorithmException",
				"documentation": ""
			},
			{
				"signature": "private File getLicensesDir(Project project)",
				"documentation": ""
			},
			{
				"signature": "private File getFile(Project project, String fileName)",
				"documentation": ""
			},
			{
				"signature": "private void createFileIn(File parent, String name, String content) throws IOException",
				"documentation": ""
			},
			{
				"signature": "private UpdateShasTask createUpdateShasTask(Project project, TaskProvider\u003cDependencyLicensesTask\u003e dependencyLicensesTask)",
				"documentation": ""
			},
			{
				"signature": "private TaskProvider\u003cDependencyLicensesTask\u003e createDependencyLicensesTask(Project project)",
				"documentation": ""
			},
			{
				"signature": "public void execute(DependencyLicensesTask dependencyLicensesTask)",
				"documentation": ""
			},
			{
				"signature": "private FileCollection getDependencies(Project project)",
				"documentation": ""
			}
		],
		"interfaces": []
	},
	{
		"documentation": "",
		"name": "org.elasticsearch.gradle.internal.precommit.FilePermissionsTaskTests",
		"extends": "org.elasticsearch.gradle.internal.test.GradleUnitTestCase",
		"Methods": [
			{
				"signature": "public void testCheckPermissionsWhenAnExecutableFileExists() throws Exception",
				"documentation": ""
			},
			{
				"signature": "public void testCheckPermissionsWhenNoFileExists() throws Exception",
				"documentation": ""
			},
			{
				"signature": "public void testCheckPermissionsWhenNoExecutableFileExists() throws Exception",
				"documentation": ""
			},
			{
				"signature": "private Project createProject()",
				"documentation": ""
			},
			{
				"signature": "private FilePermissionsTask createTask(Project project)",
				"documentation": ""
			}
		],
		"interfaces": []
	},
	{
		"documentation": "",
		"name": "org.elasticsearch.gradle.internal.precommit.ForbiddenPatternsTaskTests",
		"extends": "org.elasticsearch.gradle.internal.test.GradleUnitTestCase",
		"Methods": [
			{
				"signature": "public void testCheckInvalidPatternsWhenNoSourceFilesExist() throws Exception",
				"documentation": ""
			},
			{
				"signature": "public void testCheckInvalidPatternsWhenSourceFilesExistNoViolation() throws Exception",
				"documentation": ""
			},
			{
				"signature": "public void testCheckInvalidPatternsWhenSourceFilesExistHavingTab() throws Exception",
				"documentation": ""
			},
			{
				"signature": "public void testCheckInvalidPatternsWithCustomRule() throws Exception",
				"documentation": ""
			},
			{
				"signature": "public void testCheckInvalidPatternsWhenExcludingFiles() throws Exception",
				"documentation": ""
			},
			{
				"signature": "private Project createProject()",
				"documentation": ""
			},
			{
				"signature": "private ForbiddenPatternsTask createTask(Project project, String taskName)",
				"documentation": ""
			},
			{
				"signature": "private ForbiddenPatternsTask createTask(Project project)",
				"documentation": ""
			},
			{
				"signature": "private void writeSourceFile(Project project, String name, String... lines) throws IOException",
				"documentation": ""
			},
			{
				"signature": "private void checkAndAssertTaskSuccessful(ForbiddenPatternsTask task) throws IOException",
				"documentation": ""
			},
			{
				"signature": "private void checkAndAssertTaskThrowsException(ForbiddenPatternsTask task) throws IOException",
				"documentation": ""
			},
			{
				"signature": "private void assertTaskSuccessful(Project project, String fileName) throws IOException",
				"documentation": ""
			}
		],
		"interfaces": []
	},
	{
		"documentation": "",
		"name": "org.elasticsearch.gradle.internal.precommit.UpdateShasTaskTests",
		"extends": "org.elasticsearch.gradle.internal.test.GradleUnitTestCase",
		"Methods": [
			{
				"signature": "public void prepare() throws IOException",
				"documentation": ""
			},
			{
				"signature": "public void whenDependencyDoesntExistThenShouldDeleteDependencySha() throws IOException, NoSuchAlgorithmException",
				"documentation": ""
			},
			{
				"signature": "public void whenDependencyExistsButShaNotThenShouldCreateNewShaFile() throws IOException, NoSuchAlgorithmException",
				"documentation": ""
			},
			{
				"signature": "public void whenDependencyAndWrongShaExistsThenShouldNotOverwriteShaFile() throws IOException, NoSuchAlgorithmException",
				"documentation": ""
			},
			{
				"signature": "public void whenLicensesDirDoesntExistThenShouldThrowException() throws IOException, NoSuchAlgorithmException",
				"documentation": ""
			},
			{
				"signature": "private Project createProject()",
				"documentation": ""
			},
			{
				"signature": "private File getLicensesDir(Project project)",
				"documentation": ""
			},
			{
				"signature": "private File getFile(Project project, String fileName)",
				"documentation": ""
			},
			{
				"signature": "private File createFileIn(File parent, String name, String content) throws IOException",
				"documentation": ""
			},
			{
				"signature": "private UpdateShasTask createUpdateShasTask(Project project)",
				"documentation": ""
			},
			{
				"signature": "private TaskProvider\u003cDependencyLicensesTask\u003e createDependencyLicensesTask(Project project)",
				"documentation": ""
			},
			{
				"signature": "private FileCollection getDependencies(Project project)",
				"documentation": ""
			}
		],
		"interfaces": []
	},
	{
		"documentation": "",
		"name": "org.elasticsearch.gradle.internal.release.BreakingChangesGeneratorTest",
		"extends": "",
		"Methods": [
			{
				"signature": "public void generateIndexFile_rendersCorrectMarkup() throws Exception",
				"documentation": "/**\n     * Check that the breaking changes can be correctly generated.\n     */"
			},
			{
				"signature": "private List\u003cChangelogEntry\u003e getEntries()",
				"documentation": ""
			},
			{
				"signature": "private String getResource(String name) throws Exception",
				"documentation": ""
			}
		],
		"interfaces": []
	},
	{
		"documentation": "",
		"name": "org.elasticsearch.gradle.internal.release.GenerateReleaseNotesTaskTest",
		"extends": "org.elasticsearch.gradle.internal.test.GradleUnitTestCase",
		"Methods": [
			{
				"signature": "public void setup()",
				"documentation": ""
			},
			{
				"signature": "public void needsGitTags_withFirstSnapshot_returnsFalse()",
				"documentation": "/**\n     * Check that the task does not update git tags if the current version is a snapshot of the first patch release.\n     */"
			},
			{
				"signature": "public void needsGitTags_withLaterSnapshot_returnsTrue()",
				"documentation": "/**\n     * Check that the task does update git tags if the current version is a snapshot after the first patch release.\n     */"
			},
			{
				"signature": "public void needsGitTags_withFirstPatchRelease_returnsFalse()",
				"documentation": "/**\n     * Check that the task does not update git tags if the current version is the first patch release in a minor series.\n     */"
			},
			{
				"signature": "public void needsGitTags_withLaterPatchRelease_returnsTrue()",
				"documentation": "/**\n     * Check that the task does update git tags if the current version is later than the first patch release in a minor series.\n     */"
			},
			{
				"signature": "public void needsGitTags_withFirsAlphaRelease_returnsFalse()",
				"documentation": "/**\n     * Check that the task does not update git tags if the current version is a first alpha prerelease.\n     */"
			},
			{
				"signature": "public void needsGitTags_withLaterAlphaRelease_returnsFalse()",
				"documentation": "/**\n     * Check that the task does update git tags if the current version is a prerelease after the first alpha.\n     */"
			},
			{
				"signature": "public void partitionFiles_withSnapshot_returnsSingleMapping()",
				"documentation": "/**\n     * Check that partitioning changelog files when the current version is a snapshot returns a map with a single entry.\n     */"
			},
			{
				"signature": "public void partitionFiles_withFirstRevision_returnsSingleMapping()",
				"documentation": "/**\n     * Check that partitioning changelog files when the current version is the first release\n     * in a minor series returns a map with a single entry.\n     */"
			},
			{
				"signature": "public void partitionFiles_withFirstAlpha_returnsSingleMapping()",
				"documentation": "/**\n     * Check that partitioning changelog files when the current version is the first alpha prerelease returns a map with a single entry.\n     */"
			},
			{
				"signature": "public void getVersions_includesCurrentVersion()",
				"documentation": "/**\n     * Check that when deriving a lit of versions from git tags, the current unreleased version is included.\n     */"
			},
			{
				"signature": "public void partitionFiles_withPrerelease_correctlyGroupsByPrereleaseVersion()",
				"documentation": "/**\n     * Check that the task partitions the list of files correctly by version for a prerelease.\n     */"
			},
			{
				"signature": "public void partitionFiles_withPatchRelease_correctlyGroupsByPatchVersion()",
				"documentation": "/**\n     * Check that the task partitions the list of files correctly by version for a patch release.\n     */"
			}
		],
		"interfaces": []
	},
	{
		"documentation": "",
		"name": "org.elasticsearch.gradle.internal.release.PruneChangelogsTaskTests",
		"extends": "org.elasticsearch.gradle.internal.test.GradleUnitTestCase",
		"Methods": [
			{
				"signature": "public void setup()",
				"documentation": ""
			},
			{
				"signature": "public void findAndDeleteFiles_withNoFiles_doesNothing()",
				"documentation": "/**\n    * Check that if there are no files in the current checkout, then the task does nothing.\n    */"
			},
			{
				"signature": "public void findAndDeleteFiles_withNoPriorVersions_deletesNothing()",
				"documentation": "/**\n     * Check that if there are files in the checkout, but no prior versions in the git\n     * history, the task deletes nothing.\n     */"
			},
			{
				"signature": "public void findAndDeleteFiles_withFilesButNoHistoricalFiles_deletesNothing()",
				"documentation": "/**\n     * Check that if there are files in the checkout, but no files in the git history, then\n     * the task deletes nothing.\n     */"
			},
			{
				"signature": "public void findAndDeleteFiles_withFilesToDelete_deletesFiles()",
				"documentation": "/**\n     * Check that if there are files to delete, then the files are deleted.\n     */"
			},
			{
				"signature": "public void findAndDeleteFiles_withFilesToDeleteButDeleteFails_throwsException()",
				"documentation": "/**\n     * Check that if there are files to delete, but some deletes fail, then the task throws an exception.\n     */"
			},
			{
				"signature": "public void findPreviousVersion_afterStartOfMajorSeries_inspectsCurrentMajorSeries()",
				"documentation": "/**\n     * Check that when list versions and the current version is at the start of a major series, then the versions for\n     * the previous major series are returned.\n     */"
			}
		],
		"interfaces": []
	},
	{
		"documentation": "",
		"name": "org.elasticsearch.gradle.internal.release.ReleaseHighlightsGeneratorTest",
		"extends": "",
		"Methods": [
			{
				"signature": "public void generateFile_withNoHighlights_rendersCorrectMarkup() throws Exception",
				"documentation": "/**\n     * Check that the release highlights can be correctly generated when there are no highlights.\n     */"
			},
			{
				"signature": "public void generateFile_rendersCorrectMarkup() throws Exception",
				"documentation": "/**\n     * Check that the release highlights can be correctly generated.\n     */"
			},
			{
				"signature": "private List\u003cChangelogEntry\u003e getEntries()",
				"documentation": ""
			},
			{
				"signature": "private String getResource(String name) throws Exception",
				"documentation": ""
			}
		],
		"interfaces": []
	},
	{
		"documentation": "",
		"name": "org.elasticsearch.gradle.internal.release.ReleaseNotesGeneratorTest",
		"extends": "",
		"Methods": [
			{
				"signature": "public void generateFile_rendersCorrectMarkup() throws Exception",
				"documentation": "/**\n     * Check that the release notes can be correctly generated.\n     */"
			},
			{
				"signature": "private Set\u003cChangelogEntry\u003e getEntries()",
				"documentation": ""
			},
			{
				"signature": "private List\u003cChangelogEntry\u003e buildEntries(int seed, int count)",
				"documentation": ""
			},
			{
				"signature": "private String getResource(String name) throws Exception",
				"documentation": ""
			}
		],
		"interfaces": []
	},
	{
		"documentation": "",
		"name": "org.elasticsearch.gradle.internal.release.ReleaseNotesIndexGeneratorTest",
		"extends": "",
		"Methods": [
			{
				"signature": "public void generateFile_rendersCorrectMarkup() throws Exception",
				"documentation": "/**\n     * Check that a release notes index can be generated.\n     */"
			},
			{
				"signature": "private String getResource(String name) throws Exception",
				"documentation": ""
			}
		],
		"interfaces": []
	},
	{
		"documentation": "",
		"name": "org.elasticsearch.gradle.internal.test.rest.transform.AssertObjectNodes",
		"extends": "",
		"Methods": [
			{
				"signature": "public static void areEqual(List\u003cObjectNode\u003e actualTests, List\u003cObjectNode\u003e expectedTests)",
				"documentation": ""
			},
			{
				"signature": "private static String toString(List\u003cObjectNode\u003e tests)",
				"documentation": ""
			}
		],
		"interfaces": []
	},
	{
		"documentation": "",
		"name": "org.elasticsearch.gradle.internal.test.rest.transform.TransformTests",
		"extends": "org.elasticsearch.gradle.internal.test.GradleUnitTestCase",
		"Methods": [
			{
				"signature": "public void setup()",
				"documentation": ""
			},
			{
				"signature": "protected void validateSetupAndTearDown(List\u003cObjectNode\u003e transformedTests)",
				"documentation": ""
			},
			{
				"signature": "protected ObjectNode validateSkipNodesExist(List\u003cObjectNode\u003e tests)",
				"documentation": ""
			},
			{
				"signature": "protected void validateSkipNodesDoesNotExist(List\u003cObjectNode\u003e tests)",
				"documentation": ""
			},
			{
				"signature": "protected void validatePreExistingFeatureExist(List\u003cObjectNode\u003e tests)",
				"documentation": ""
			},
			{
				"signature": "protected void validateSetupDoesNotExist(List\u003cObjectNode\u003e tests)",
				"documentation": ""
			},
			{
				"signature": "protected void validateFeatureNameExists(List\u003cObjectNode\u003e tests, String featureName)",
				"documentation": ""
			},
			{
				"signature": "protected void validateSetupExist(List\u003cObjectNode\u003e tests)",
				"documentation": ""
			},
			{
				"signature": "protected List\u003cObjectNode\u003e transformTests(List\u003cObjectNode\u003e tests)",
				"documentation": ""
			},
			{
				"signature": "protected List\u003cObjectNode\u003e transformTests(List\u003cObjectNode\u003e tests, List\u003cRestTestTransform\u003c?\u003e\u003e transforms)",
				"documentation": ""
			},
			{
				"signature": "protected List\u003cString\u003e getKnownFeatures()",
				"documentation": ""
			},
			{
				"signature": "protected List\u003cRestTestTransform\u003c?\u003e\u003e getTransformations()",
				"documentation": ""
			},
			{
				"signature": "protected List\u003cObjectNode\u003e getTests(String relativePath) throws Exception",
				"documentation": ""
			},
			{
				"signature": "protected void assertTeardown(ObjectNode teardownNode)",
				"documentation": ""
			},
			{
				"signature": "protected void assertSetup(ObjectNode setupNode)",
				"documentation": ""
			},
			{
				"signature": "protected void assertSkipNode(ObjectNode skipNode)",
				"documentation": ""
			},
			{
				"signature": "protected ObjectNode getSkipNode(ArrayNode setupNodeValue)",
				"documentation": ""
			},
			{
				"signature": "protected void validateBodyHasWarnings(String featureName, List\u003cObjectNode\u003e tests, Collection\u003cString\u003e expectedWarnings)",
				"documentation": ""
			},
			{
				"signature": "protected void validateBodyHasWarnings(        String featureName,        String testName,        List\u003cObjectNode\u003e tests,        Collection\u003cString\u003e expectedWarnings    )",
				"documentation": ""
			},
			{
				"signature": "protected void validateBodyHasNoWarnings(String featureName, List\u003cObjectNode\u003e tests)",
				"documentation": ""
			},
			{
				"signature": "protected void validateBodyHasNoWarnings(String featureName, String testName, List\u003cObjectNode\u003e tests)",
				"documentation": ""
			},
			{
				"signature": "protected void validateBodyHasEmptyNoWarnings(String featureName, List\u003cObjectNode\u003e tests)",
				"documentation": ""
			},
			{
				"signature": "protected void validateBodyHasHeaders(List\u003cObjectNode\u003e tests, Map\u003cString, String\u003e expectedHeaders)",
				"documentation": ""
			},
			{
				"signature": "protected void validateSetupAndTearDownForMatchTests(List\u003cObjectNode\u003e tests)",
				"documentation": ""
			},
			{
				"signature": "protected boolean getHumanDebug()",
				"documentation": ""
			},
			{
				"signature": "protected void printTest(String testName, List\u003cObjectNode\u003e tests)",
				"documentation": ""
			}
		],
		"interfaces": []
	},
	{
		"documentation": "",
		"name": "org.elasticsearch.gradle.internal.test.rest.transform.do_.ReplaceKeyInDoTests",
		"extends": "org.elasticsearch.gradle.internal.test.rest.transform.TransformTests",
		"Methods": [
			{
				"signature": "public void testReplaceKeyInDo() throws Exception",
				"documentation": ""
			}
		],
		"interfaces": []
	},
	{
		"documentation": "",
		"name": "org.elasticsearch.gradle.internal.test.rest.transform.feature.InjectFeatureTests",
		"extends": "org.elasticsearch.gradle.internal.test.rest.transform.TransformTests",
		"Methods": [
			{
				"signature": "public void testInjectFeatureWithoutSetup() throws Exception",
				"documentation": "/**\n     * test file does not have a setup\n     */"
			},
			{
				"signature": "public void testInjectFeatureWithSinglePreexistingFeature() throws Exception",
				"documentation": "/**\n     * test file has a single feature\n     */"
			},
			{
				"signature": "public void testInjectFeatureWithMultiplePreexistingFeature() throws Exception",
				"documentation": "/**\n     * test file has multiple feature\n     */"
			},
			{
				"signature": "public void testInjectFeatureWithSetupNoSkip() throws Exception",
				"documentation": "/**\n     * test file has a setup, but no skip (and by inference no feature)\n     */"
			},
			{
				"signature": "public void testInjectFeatureWithSetupWithSkipNoFeature() throws Exception",
				"documentation": "/**\n     * test file has a setup, a skip section, but no features\n     */"
			},
			{
				"signature": "public void testInjectFeatureWithFeatureAlreadyDefined() throws Exception",
				"documentation": "/**\n     * test file has a single feature\n     */"
			}
		],
		"interfaces": []
	},
	{
		"documentation": "",
		"name": "org.elasticsearch.gradle.internal.test.rest.transform.header.InjectHeaderTests",
		"extends": "org.elasticsearch.gradle.internal.test.rest.transform.feature.InjectFeatureTests",
		"Methods": [
			{
				"signature": "public void testInjectHeadersNoPreExisting() throws Exception",
				"documentation": "/**\n     * test file does not any headers defined\n     */"
			},
			{
				"signature": "public void testInjectHeadersWithPreExisting() throws Exception",
				"documentation": "/**\n     * test file has preexisting headers\n     */"
			},
			{
				"signature": "public void testNotInjectingHeaders() throws Exception",
				"documentation": ""
			},
			{
				"signature": "private static boolean applyCondition(ObjectNode doNodeValue)",
				"documentation": ""
			},
			{
				"signature": "protected List\u003cString\u003e getKnownFeatures()",
				"documentation": ""
			},
			{
				"signature": "protected List\u003cRestTestTransform\u003c?\u003e\u003e getTransformations()",
				"documentation": ""
			},
			{
				"signature": "protected boolean getHumanDebug()",
				"documentation": ""
			}
		],
		"interfaces": []
	},
	{
		"documentation": "",
		"name": "org.elasticsearch.gradle.internal.test.rest.transform.length.ReplaceKeyInLengthTests",
		"extends": "org.elasticsearch.gradle.internal.test.rest.transform.TransformTests",
		"Methods": [
			{
				"signature": "public void testLengthKeyChange() throws Exception",
				"documentation": ""
			}
		],
		"interfaces": []
	},
	{
		"documentation": "",
		"name": "org.elasticsearch.gradle.internal.test.rest.transform.length.ReplaceValueInLengthTests",
		"extends": "org.elasticsearch.gradle.internal.test.rest.transform.TransformTests",
		"Methods": [
			{
				"signature": "public void testReplaceMatch() throws Exception",
				"documentation": ""
			}
		],
		"interfaces": []
	},
	{
		"documentation": "",
		"name": "org.elasticsearch.gradle.internal.test.rest.transform.match.AddMatchTests",
		"extends": "org.elasticsearch.gradle.internal.test.rest.transform.TransformTests",
		"Methods": [
			{
				"signature": "public void testAddAllNotSupported() throws Exception",
				"documentation": ""
			},
			{
				"signature": "public void testAddByTest() throws Exception",
				"documentation": ""
			},
			{
				"signature": "private void validateTest(List\u003cObjectNode\u003e tests, boolean beforeTransformation)",
				"documentation": ""
			},
			{
				"signature": "protected boolean getHumanDebug()",
				"documentation": ""
			}
		],
		"interfaces": []
	},
	{
		"documentation": "",
		"name": "org.elasticsearch.gradle.internal.test.rest.transform.match.RemoveMatchTests",
		"extends": "org.elasticsearch.gradle.internal.test.rest.transform.TransformTests",
		"Methods": [
			{
				"signature": "public void testRemoveAll() throws Exception",
				"documentation": ""
			},
			{
				"signature": "public void testRemoveByTest() throws Exception",
				"documentation": ""
			},
			{
				"signature": "private void validateTest(List\u003cObjectNode\u003e tests, boolean beforeTransformation, boolean allTests)",
				"documentation": ""
			},
			{
				"signature": "protected boolean getHumanDebug()",
				"documentation": ""
			}
		],
		"interfaces": []
	},
	{
		"documentation": "",
		"name": "org.elasticsearch.gradle.internal.test.rest.transform.match.ReplaceKeyInMatchTests",
		"extends": "org.elasticsearch.gradle.internal.test.rest.transform.TransformTests",
		"Methods": [
			{
				"signature": "public void testReplaceKeyInMatch() throws Exception",
				"documentation": ""
			}
		],
		"interfaces": []
	},
	{
		"documentation": "",
		"name": "org.elasticsearch.gradle.internal.test.rest.transform.match.ReplaceValueInMatchTests",
		"extends": "org.elasticsearch.gradle.internal.test.rest.transform.TransformTests",
		"Methods": [
			{
				"signature": "public void testReplaceMatch() throws Exception",
				"documentation": ""
			}
		],
		"interfaces": []
	},
	{
		"documentation": "",
		"name": "org.elasticsearch.gradle.internal.test.rest.transform.skip.SkipTests",
		"extends": "org.elasticsearch.gradle.internal.test.rest.transform.TransformTests",
		"Methods": [
			{
				"signature": "public void testAddGlobalSetup() throws Exception",
				"documentation": ""
			},
			{
				"signature": "public void testModifyGlobalSetupWithSkip() throws Exception",
				"documentation": ""
			},
			{
				"signature": "public void testModifyGlobalSetupWithoutSkip() throws Exception",
				"documentation": ""
			},
			{
				"signature": "public void testModifyGlobalSetupWithFeatures() throws Exception",
				"documentation": ""
			},
			{
				"signature": "public void testModifyPerTestSetup() throws Exception",
				"documentation": ""
			}
		],
		"interfaces": []
	},
	{
		"documentation": "",
		"name": "org.elasticsearch.gradle.internal.test.rest.transform.text.ReplaceTextualTests",
		"extends": "org.elasticsearch.gradle.internal.test.rest.transform.TransformTests",
		"Methods": [
			{
				"signature": "public void testReplaceAll() throws Exception",
				"documentation": ""
			}
		],
		"interfaces": []
	},
	{
		"documentation": "",
		"name": "org.elasticsearch.gradle.internal.test.rest.transform.warnings.InjectAllowedWarningsRegexTests",
		"extends": "org.elasticsearch.gradle.internal.test.rest.transform.feature.InjectFeatureTests",
		"Methods": [
			{
				"signature": "public void testInjectAllowedWarningsNoPreExisting() throws Exception",
				"documentation": "/**\n     * test file does not any allowed warnings defined\n     */"
			},
			{
				"signature": "public void testInjectAllowedWarningsWithPreExisting() throws Exception",
				"documentation": "/**\n     * test file has preexisting allowed warnings\n     */"
			},
			{
				"signature": "protected List\u003cString\u003e getKnownFeatures()",
				"documentation": ""
			},
			{
				"signature": "protected List\u003cRestTestTransform\u003c?\u003e\u003e getTransformations()",
				"documentation": ""
			},
			{
				"signature": "protected boolean getHumanDebug()",
				"documentation": ""
			}
		],
		"interfaces": []
	},
	{
		"documentation": "",
		"name": "org.elasticsearch.gradle.internal.test.rest.transform.warnings.InjectAllowedWarningsTests",
		"extends": "org.elasticsearch.gradle.internal.test.rest.transform.feature.InjectFeatureTests",
		"Methods": [
			{
				"signature": "public void testInjectAllowedWarningsNoPreExisting() throws Exception",
				"documentation": "/**\n     * test file does not any allowed warnings defined\n     */"
			},
			{
				"signature": "public void testInjectAllowedWarningsWithPreExisting() throws Exception",
				"documentation": "/**\n     * test file has preexisting allowed warnings\n     */"
			},
			{
				"signature": "public void testInjectAllowedWarningsWithPreExistingForSingleTest() throws Exception",
				"documentation": ""
			},
			{
				"signature": "private List\u003cRestTestTransform\u003c?\u003e\u003e getTransformationsForTest(String testName)",
				"documentation": ""
			},
			{
				"signature": "protected List\u003cString\u003e getKnownFeatures()",
				"documentation": ""
			},
			{
				"signature": "protected List\u003cRestTestTransform\u003c?\u003e\u003e getTransformations()",
				"documentation": ""
			},
			{
				"signature": "protected boolean getHumanDebug()",
				"documentation": ""
			}
		],
		"interfaces": []
	},
	{
		"documentation": "",
		"name": "org.elasticsearch.gradle.internal.test.rest.transform.warnings.InjectWarningsRegexTests",
		"extends": "org.elasticsearch.gradle.internal.test.rest.transform.feature.InjectFeatureTests",
		"Methods": [
			{
				"signature": "public void testInjectWarningsRequiresTestName() throws Exception",
				"documentation": "/**\n     * inject warning requires a test name to insert\n     */"
			},
			{
				"signature": "public void testInjectWarningsNoPreExisting() throws Exception",
				"documentation": "/**\n     * test file does not any warnings defined\n     */"
			},
			{
				"signature": "public void testInjectWarningsWithPreExisting() throws Exception",
				"documentation": "/**\n     * test file has preexisting warnings\n     */"
			},
			{
				"signature": "protected List\u003cString\u003e getKnownFeatures()",
				"documentation": ""
			},
			{
				"signature": "protected List\u003cRestTestTransform\u003c?\u003e\u003e getTransformations()",
				"documentation": ""
			},
			{
				"signature": "protected boolean getHumanDebug()",
				"documentation": ""
			}
		],
		"interfaces": []
	},
	{
		"documentation": "",
		"name": "org.elasticsearch.gradle.internal.test.rest.transform.warnings.InjectWarningsTests",
		"extends": "org.elasticsearch.gradle.internal.test.rest.transform.feature.InjectFeatureTests",
		"Methods": [
			{
				"signature": "public void testInjectWarningsRequiresTestName() throws Exception",
				"documentation": "/**\n     * inject warning requires a test name to insert\n     */"
			},
			{
				"signature": "public void testInjectWarningsNoPreExisting() throws Exception",
				"documentation": "/**\n     * test file does not any warnings defined\n     */"
			},
			{
				"signature": "public void testInjectWarningsWithPreExisting() throws Exception",
				"documentation": "/**\n     * test file has preexisting warnings\n     */"
			},
			{
				"signature": "protected List\u003cString\u003e getKnownFeatures()",
				"documentation": ""
			},
			{
				"signature": "protected List\u003cRestTestTransform\u003c?\u003e\u003e getTransformations()",
				"documentation": ""
			},
			{
				"signature": "protected boolean getHumanDebug()",
				"documentation": ""
			}
		],
		"interfaces": []
	},
	{
		"documentation": "",
		"name": "org.elasticsearch.gradle.internal.test.rest.transform.warnings.RemoveWarningsTests",
		"extends": "org.elasticsearch.gradle.internal.test.rest.transform.TransformTests",
		"Methods": [
			{
				"signature": "public void testRemoveWarningsNoPreExisting() throws Exception",
				"documentation": "/**\n     * test file does not any warnings defined\n     */"
			},
			{
				"signature": "public void testRemoveWarningWithPreExisting() throws Exception",
				"documentation": "/**\n     * test file has preexisting multiple warnings\n     */"
			},
			{
				"signature": "public void testRemoveWarningWithPreExistingFromSingleTest() throws Exception",
				"documentation": ""
			},
			{
				"signature": "private List\u003cRestTestTransform\u003c?\u003e\u003e getTransformationsForTest(String testName)",
				"documentation": ""
			},
			{
				"signature": "public void testRemoveWarningWithSinglePreExisting() throws Exception",
				"documentation": "/**\n     * test file has preexisting single warning\n     */"
			},
			{
				"signature": "protected List\u003cRestTestTransform\u003c?\u003e\u003e getTransformations()",
				"documentation": ""
			},
			{
				"signature": "protected boolean getHumanDebug()",
				"documentation": ""
			}
		],
		"interfaces": []
	},
	{
		"documentation": "",
		"name": "org.elasticsearch.gradle.plugin.PluginPropertiesExtensionTests",
		"extends": "org.elasticsearch.gradle.internal.test.GradleUnitTestCase",
		"Methods": [
			{
				"signature": "public void testCreatingPluginPropertiesExtensionWithNameAndVersion()",
				"documentation": ""
			},
			{
				"signature": "public void testCreatingPluginPropertiesExtensionWithNameWithoutVersion()",
				"documentation": ""
			},
			{
				"signature": "private Project createProject(String projectName, String version)",
				"documentation": ""
			}
		],
		"interfaces": []
	},
	{
		"documentation": "",
		"name": "org.elasticsearch.gradle.testclusters.WaitForHttpResourceTests",
		"extends": "org.elasticsearch.gradle.internal.test.GradleUnitTestCase",
		"Methods": [
			{
				"signature": "public void testBuildTrustStoreFromFile() throws Exception",
				"documentation": ""
			},
			{
				"signature": "public void testBuildTrustStoreFromCA() throws Exception",
				"documentation": ""
			}
		],
		"interfaces": []
	},
	{
		"documentation": "/**\n * This is just a test class\n */",
		"name": "org.elasticsearch.SampleClass",
		"extends": "",
		"Methods": [],
		"interfaces": []
	},
	{
		"documentation": "",
		"name": "org.elasticsearch.gradle.testkit.NamingConventionIT",
		"extends": "",
		"Methods": [],
		"interfaces": []
	},
	{
		"documentation": "",
		"name": "org.elasticsearch.gradle.testkit.NamingConventionTests",
		"extends": "",
		"Methods": [],
		"interfaces": []
	},
	{
		"documentation": "",
		"name": "org.elasticsearch.gradle.testkit.LooksLikeATestWithoutNamingConvention1",
		"extends": "",
		"Methods": [
			{
				"signature": "public void annotatedTestMethod()",
				"documentation": ""
			}
		],
		"interfaces": []
	},
	{
		"documentation": "",
		"name": "org.elasticsearch.gradle.testkit.LooksLikeATestWithoutNamingConvention2",
		"extends": "org.junit.Assert",
		"Methods": [],
		"interfaces": []
	},
	{
		"documentation": "",
		"name": "org.elasticsearch.gradle.testkit.LooksLikeATestWithoutNamingConvention3",
		"extends": "",
		"Methods": [
			{
				"signature": "public void testMethod()",
				"documentation": ""
			}
		],
		"interfaces": []
	},
	{
		"documentation": "",
		"name": "org.elasticsearch.gradle.testkit.LooksLikeTestsButAbstract",
		"extends": "",
		"Methods": [
			{
				"signature": "public void testMethod()",
				"documentation": ""
			}
		],
		"interfaces": []
	},
	{
		"documentation": "",
		"name": "org.elasticsearch.gradle.testkit.NamingConventionIT",
		"extends": "",
		"Methods": [],
		"interfaces": []
	},
	{
		"documentation": "",
		"name": "org.elasticsearch.gradle.testkit.NamingConventionTests",
		"extends": "",
		"Methods": [],
		"interfaces": []
	},
	{
		"documentation": "",
		"name": "org.elasticsearch.gradle.testkit.NastyInnerClasses",
		"extends": "",
		"Methods": [],
		"interfaces": []
	},
	{
		"documentation": "",
		"name": "org.elasticsearch.gradle.testkit.NastyInnerClasses.NamingConventionTests",
		"extends": "",
		"Methods": [],
		"interfaces": []
	},
	{
		"documentation": "",
		"name": "org.elasticsearch.gradle.testkit.NastyInnerClasses.NamingConventionIT",
		"extends": "",
		"Methods": [],
		"interfaces": []
	},
	{
		"documentation": "",
		"name": "org.elasticsearch.gradle.testkit.NastyInnerClasses.LooksLikeATestWithoutNamingConvention1",
		"extends": "",
		"Methods": [
			{
				"signature": "public void annotatedTestMethod()",
				"documentation": ""
			}
		],
		"interfaces": []
	},
	{
		"documentation": "",
		"name": "org.elasticsearch.gradle.testkit.NastyInnerClasses.LooksLikeATestWithoutNamingConvention2",
		"extends": "org.junit.Assert",
		"Methods": [],
		"interfaces": []
	},
	{
		"documentation": "",
		"name": "org.elasticsearch.gradle.testkit.NastyInnerClasses.LooksLikeATestWithoutNamingConvention3",
		"extends": "",
		"Methods": [
			{
				"signature": "public void testMethod()",
				"documentation": ""
			}
		],
		"interfaces": []
	},
	{
		"documentation": "",
		"name": "org.elasticsearch.gradle.testkit.NastyInnerClasses.NonOffendingAbstractTests",
		"extends": "",
		"Methods": [],
		"interfaces": []
	},
	{
		"documentation": "",
		"name": "org.elasticsearch.gradle.testkit.NastyInnerClasses.NonOffendingPrivateTests",
		"extends": "",
		"Methods": [],
		"interfaces": []
	},
	{
		"documentation": "",
		"name": "org.elasticsearch.gradle.testkit.NastyInnerClasses.NonOffendingPackageTests",
		"extends": "",
		"Methods": [],
		"interfaces": []
	},
	{
		"documentation": "",
		"name": "org.elasticsearch.gradle.testkit.AbstractIT",
		"extends": "",
		"Methods": [],
		"interfaces": []
	},
	{
		"documentation": "",
		"name": "org.elasticsearch.gradle.testkit.Integration",
		"extends": "",
		"Methods": [],
		"interfaces": []
	},
	{
		"documentation": "",
		"name": "org.elasticsearch.gradle.testkit.NamingConventionIT",
		"extends": "",
		"Methods": [],
		"interfaces": []
	},
	{
		"documentation": "",
		"name": "org.elasticsearch.gradle.testkit.NamingConventionMissmatchIT",
		"extends": "Unit",
		"Methods": [],
		"interfaces": []
	},
	{
		"documentation": "",
		"name": "org.elasticsearch.gradle.testkit.NamingConventionMissmatchTests",
		"extends": "Integration",
		"Methods": [],
		"interfaces": []
	},
	{
		"documentation": "",
		"name": "org.elasticsearch.gradle.testkit.NamingConventionTests",
		"extends": "",
		"Methods": [],
		"interfaces": []
	},
	{
		"documentation": "",
		"name": "org.elasticsearch.gradle.testkit.Unit",
		"extends": "",
		"Methods": [],
		"interfaces": []
	},
	{
		"documentation": "",
		"name": "org.elasticsearch.gradle.testkit.NamingConventionIT",
		"extends": "",
		"Methods": [],
		"interfaces": []
	},
	{
		"documentation": "",
		"name": "org.elasticsearch.gradle.testkit.NamingConventionTests",
		"extends": "",
		"Methods": [],
		"interfaces": []
	},
	{
		"documentation": "",
		"name": "org.elasticsearch.gradle.testkit.NamingConventionIT",
		"extends": "",
		"Methods": [],
		"interfaces": []
	},
	{
		"documentation": "",
		"name": "org.elasticsearch.gradle.testkit.NamingConventionTests",
		"extends": "",
		"Methods": [],
		"interfaces": []
	},
	{
		"documentation": "",
		"name": "org.elasticsearch.gradle.testkit.Integration",
		"extends": "",
		"Methods": [],
		"interfaces": []
	},
	{
		"documentation": "",
		"name": "org.elasticsearch.gradle.testkit.NamingConventionIT",
		"extends": "Integration",
		"Methods": [],
		"interfaces": []
	},
	{
		"documentation": "",
		"name": "org.elasticsearch.gradle.testkit.NamingConventionTests",
		"extends": "Unit",
		"Methods": [],
		"interfaces": []
	},
	{
		"documentation": "",
		"name": "org.elasticsearch.gradle.testkit.Unit",
		"extends": "",
		"Methods": [],
		"interfaces": []
	},
	{
		"documentation": "",
		"name": "String",
		"extends": "",
		"Methods": [],
		"interfaces": []
	},
	{
		"documentation": "",
		"name": "TestingIO",
		"extends": "",
		"Methods": [
			{
				"signature": "public TestingIO()",
				"documentation": ""
			}
		],
		"interfaces": []
	},
	{
		"documentation": "",
		"name": "TestingLog4j",
		"extends": "",
		"Methods": [
			{
				"signature": "public TestingLog4j()",
				"documentation": ""
			}
		],
		"interfaces": []
	},
	{
		"documentation": "",
		"name": "org.elasticsearch.client.benchmark.AbstractBenchmark",
		"extends": "",
		"Methods": [
			{
				"signature": "public final void run(String[] args) throws Exception",
				"documentation": ""
			},
			{
				"signature": "private void runBulkIndexBenchmark(String[] args) throws Exception",
				"documentation": ""
			},
			{
				"signature": "private void runSearchBenchmark(String[] args) throws Exception",
				"documentation": ""
			},
			{
				"signature": "private void runTrials(Runnable runner)",
				"documentation": ""
			},
			{
				"signature": "private void runGc()",
				"documentation": "/**\n     * Requests a full GC and checks whether the GC did actually run after a request. It retries up to 5 times in case the GC did not\n     * run in time.\n     */"
			},
			{
				"signature": "do",
				"documentation": "/**\n     * Requests a full GC and checks whether the GC did actually run after a request. It retries up to 5 times in case the GC did not\n     * run in time.\n     */"
			},
			{
				"signature": "private long getTotalGcCount()",
				"documentation": ""
			}
		],
		"interfaces": []
	},
	{
		"documentation": "",
		"name": "org.elasticsearch.client.benchmark.BenchmarkMain",
		"extends": "",
		"Methods": [
			{
				"signature": "public static void main(String[] args) throws Exception",
				"documentation": ""
			}
		],
		"interfaces": []
	},
	{
		"documentation": "",
		"name": "org.elasticsearch.client.benchmark.BenchmarkRunner",
		"extends": "",
		"Methods": [
			{
				"signature": "public BenchmarkRunner(int warmupIterations, int iterations, BenchmarkTask task)",
				"documentation": ""
			},
			{
				"signature": "public void run()",
				"documentation": ""
			},
			{
				"signature": "private String repeat(int times, char character)",
				"documentation": ""
			}
		],
		"interfaces": []
	},
	{
		"documentation": "",
		"name": "org.elasticsearch.client.benchmark.metrics.public",
		"extends": "",
		"Methods": [],
		"interfaces": []
	},
	{
		"documentation": "",
		"name": "org.elasticsearch.client.benchmark.metrics.MetricsCalculator",
		"extends": "",
		"Methods": [
			{
				"signature": "public static List\u003cMetrics\u003e calculate(Collection\u003cSample\u003e samples)",
				"documentation": ""
			},
			{
				"signature": "private static Map\u003cString, List\u003cSample\u003e\u003e groupByOperation(Collection\u003cSample\u003e samples)",
				"documentation": ""
			},
			{
				"signature": "private static List\u003cMetrics\u003e calculateMetricsPerOperation(Map\u003cString, List\u003cSample\u003e\u003e samplesPerOperation)",
				"documentation": ""
			},
			{
				"signature": "private static double calculateThroughput(int sampleSize, double duration)",
				"documentation": ""
			}
		],
		"interfaces": []
	},
	{
		"documentation": "",
		"name": "org.elasticsearch.client.benchmark.metrics.public",
		"extends": "",
		"Methods": [
			{
				"signature": "public String getOperation()",
				"documentation": ""
			},
			{
				"signature": "public boolean isSuccess()",
				"documentation": ""
			},
			{
				"signature": "public long getStartTimestamp()",
				"documentation": ""
			},
			{
				"signature": "public long getStopTimestamp()",
				"documentation": ""
			},
			{
				"signature": "public long getServiceTime()",
				"documentation": ""
			},
			{
				"signature": "public long getLatency()",
				"documentation": ""
			}
		],
		"interfaces": []
	},
	{
		"documentation": "/**\n * Stores measurement samples.\n *\n * This class is NOT threadsafe.\n */",
		"name": "org.elasticsearch.client.benchmark.metrics.SampleRecorder",
		"extends": "",
		"Methods": [
			{
				"signature": "public SampleRecorder(int iterations)",
				"documentation": "/**\n * Stores measurement samples.\n *\n * This class is NOT threadsafe.\n */"
			},
			{
				"signature": "public void addSample(Sample sample)",
				"documentation": ""
			},
			{
				"signature": "public List\u003cSample\u003e getSamples()",
				"documentation": ""
			}
		],
		"interfaces": []
	},
	{
		"documentation": "",
		"name": "org.elasticsearch.client.benchmark.ops.bulk.BulkBenchmarkTask",
		"extends": "",
		"Methods": [
			{
				"signature": "public BulkBenchmarkTask(        BulkRequestExecutor requestExecutor,        String indexFilePath,        int warmupIterations,        int measurementIterations,        int bulkSize    )",
				"documentation": ""
			},
			{
				"signature": "public void setUp(SampleRecorder sampleRecorder)",
				"documentation": ""
			},
			{
				"signature": "public void run() throws Exception",
				"documentation": ""
			},
			{
				"signature": "public void tearDown()",
				"documentation": ""
			}
		],
		"interfaces": [
			"org.elasticsearch.client.benchmark.BenchmarkTask"
		]
	},
	{
		"documentation": "",
		"name": "org.elasticsearch.client.benchmark.ops.bulk.BulkBenchmarkTask.LoadGenerator",
		"extends": "",
		"Methods": [
			{
				"signature": "LoadGenerator(Path bulkDataFile, BlockingQueue\u003cList\u003cString\u003e\u003e bulkQueue, int bulkSize)",
				"documentation": ""
			},
			{
				"signature": "public void execute()",
				"documentation": ""
			},
			{
				"signature": "private void sendBulk(List\u003cString\u003e bulkData) throws InterruptedException",
				"documentation": ""
			}
		],
		"interfaces": []
	},
	{
		"documentation": "",
		"name": "org.elasticsearch.client.benchmark.ops.bulk.BulkBenchmarkTask.BulkIndexer",
		"extends": "",
		"Methods": [
			{
				"signature": "BulkIndexer(            BlockingQueue\u003cList\u003cString\u003e\u003e bulkData,            int warmupIterations,            int measurementIterations,            SampleRecorder sampleRecorder,            BulkRequestExecutor bulkRequestExecutor        )",
				"documentation": ""
			},
			{
				"signature": "public void run()",
				"documentation": ""
			}
		],
		"interfaces": [
			"Runnable"
		]
	},
	{
		"documentation": "",
		"name": "org.elasticsearch.client.benchmark.ops.search.SearchBenchmarkTask",
		"extends": "",
		"Methods": [
			{
				"signature": "public SearchBenchmarkTask(        SearchRequestExecutor searchRequestExecutor,        String body,        int warmupIterations,        int measurementIterations,        int targetThroughput    )",
				"documentation": ""
			},
			{
				"signature": "public void setUp(SampleRecorder recorder) throws Exception",
				"documentation": ""
			},
			{
				"signature": "public void run() throws Exception",
				"documentation": ""
			},
			{
				"signature": "private void runIterations(int iterations, boolean addSample)",
				"documentation": ""
			},
			{
				"signature": "public void tearDown() throws Exception",
				"documentation": ""
			}
		],
		"interfaces": [
			"org.elasticsearch.client.benchmark.BenchmarkTask"
		]
	},
	{
		"documentation": "",
		"name": "org.elasticsearch.client.benchmark.rest.RestClientBenchmark",
		"extends": "org.elasticsearch.client.benchmark.AbstractBenchmark",
		"Methods": [
			{
				"signature": "public static void main(String[] args) throws Exception",
				"documentation": ""
			},
			{
				"signature": "protected RestClient client(String benchmarkTargetHost)",
				"documentation": ""
			},
			{
				"signature": "protected BulkRequestExecutor bulkRequestExecutor(RestClient client, String indexName, String typeName)",
				"documentation": ""
			},
			{
				"signature": "protected SearchRequestExecutor searchRequestExecutor(RestClient client, String indexName)",
				"documentation": ""
			}
		],
		"interfaces": []
	},
	{
		"documentation": "",
		"name": "org.elasticsearch.client.benchmark.rest.RestClientBenchmark.RestBulkRequestExecutor",
		"extends": "",
		"Methods": [
			{
				"signature": "RestBulkRequestExecutor(RestClient client, String index, String type)",
				"documentation": ""
			},
			{
				"signature": "public boolean bulkIndex(List\u003cString\u003e bulkData)",
				"documentation": ""
			}
		],
		"interfaces": [
			"org.elasticsearch.client.benchmark.ops.bulk.BulkRequestExecutor"
		]
	},
	{
		"documentation": "",
		"name": "org.elasticsearch.client.benchmark.rest.RestClientBenchmark.RestSearchRequestExecutor",
		"extends": "",
		"Methods": [
			{
				"signature": "private RestSearchRequestExecutor(RestClient client, String indexName)",
				"documentation": ""
			},
			{
				"signature": "public boolean search(String source)",
				"documentation": ""
			}
		],
		"interfaces": [
			"org.elasticsearch.client.benchmark.ops.search.SearchRequestExecutor"
		]
	},
	{
		"documentation": "",
		"name": "org.elasticsearch.plugin.noop.NoopPlugin",
		"extends": "org.elasticsearch.plugins.Plugin",
		"Methods": [
			{
				"signature": "public List\u003cActionHandler\u003c? extends ActionRequest, ? extends ActionResponse\u003e\u003e getActions()",
				"documentation": ""
			},
			{
				"signature": "public List\u003cRestHandler\u003e getRestHandlers(        Settings settings,        RestController restController,        ClusterSettings clusterSettings,        IndexScopedSettings indexScopedSettings,        SettingsFilter settingsFilter,        IndexNameExpressionResolver indexNameExpressionResolver,        Supplier\u003cDiscoveryNodes\u003e nodesInCluster    )",
				"documentation": ""
			}
		],
		"interfaces": [
			"org.elasticsearch.plugins.ActionPlugin"
		]
	},
	{
		"documentation": "",
		"name": "org.elasticsearch.plugin.noop.action.bulk.NoopBulkAction",
		"extends": "org.elasticsearch.action.ActionType",
		"Methods": [
			{
				"signature": "private NoopBulkAction()",
				"documentation": ""
			}
		],
		"interfaces": []
	},
	{
		"documentation": "",
		"name": "org.elasticsearch.plugin.noop.action.bulk.RestNoopBulkAction",
		"extends": "org.elasticsearch.rest.BaseRestHandler",
		"Methods": [
			{
				"signature": "public List\u003cRoute\u003e routes()",
				"documentation": ""
			},
			{
				"signature": "public String getName()",
				"documentation": ""
			},
			{
				"signature": "public RestChannelConsumer prepareRequest(final RestRequest request, final NodeClient client) throws IOException",
				"documentation": ""
			}
		],
		"interfaces": []
	},
	{
		"documentation": "",
		"name": "org.elasticsearch.plugin.noop.action.bulk.RestNoopBulkAction.BulkRestBuilderListener",
		"extends": "org.elasticsearch.rest.action.RestBuilderListener",
		"Methods": [
			{
				"signature": "BulkRestBuilderListener(RestChannel channel, RestRequest request)",
				"documentation": ""
			},
			{
				"signature": "public RestResponse buildResponse(BulkRequest bulkRequest, XContentBuilder builder) throws Exception",
				"documentation": ""
			}
		],
		"interfaces": []
	},
	{
		"documentation": "",
		"name": "org.elasticsearch.plugin.noop.action.bulk.RestNoopBulkAction.Fields",
		"extends": "",
		"Methods": [],
		"interfaces": []
	},
	{
		"documentation": "",
		"name": "org.elasticsearch.plugin.noop.action.bulk.TransportNoopBulkAction",
		"extends": "org.elasticsearch.action.support.HandledTransportAction",
		"Methods": [
			{
				"signature": "public TransportNoopBulkAction(TransportService transportService, ActionFilters actionFilters)",
				"documentation": ""
			},
			{
				"signature": "protected void doExecute(Task task, BulkRequest request, ActionListener\u003cBulkResponse\u003e listener)",
				"documentation": ""
			}
		],
		"interfaces": []
	},
	{
		"documentation": "",
		"name": "org.elasticsearch.plugin.noop.action.search.NoopSearchAction",
		"extends": "org.elasticsearch.action.ActionType",
		"Methods": [
			{
				"signature": "private NoopSearchAction()",
				"documentation": ""
			}
		],
		"interfaces": []
	},
	{
		"documentation": "",
		"name": "org.elasticsearch.plugin.noop.action.search.RestNoopSearchAction",
		"extends": "org.elasticsearch.rest.BaseRestHandler",
		"Methods": [
			{
				"signature": "public List\u003cRoute\u003e routes()",
				"documentation": ""
			},
			{
				"signature": "public String getName()",
				"documentation": ""
			},
			{
				"signature": "public RestChannelConsumer prepareRequest(final RestRequest request, final NodeClient client)",
				"documentation": ""
			}
		],
		"interfaces": []
	},
	{
		"documentation": "",
		"name": "org.elasticsearch.plugin.noop.action.search.TransportNoopSearchAction",
		"extends": "org.elasticsearch.action.support.HandledTransportAction",
		"Methods": [
			{
				"signature": "public TransportNoopSearchAction(TransportService transportService, ActionFilters actionFilters)",
				"documentation": ""
			},
			{
				"signature": "protected void doExecute(Task task, SearchRequest request, ActionListener\u003cSearchResponse\u003e listener)",
				"documentation": ""
			}
		],
		"interfaces": []
	},
	{
		"documentation": "/**\n * Represents an operation that can be cancelled.\n * Returned when executing async requests through {@link RestClient#performRequestAsync(Request, ResponseListener)}, so that the request\n * can be cancelled if needed. Cancelling a request will result in calling {@link AbstractExecutionAwareRequest#abort()} on the underlying\n * request object, which will in turn cancel its corresponding {@link java.util.concurrent.Future}.\n * Note that cancelling a request does not automatically translate to aborting its execution on the server side, which needs to be\n * specifically implemented in each API.\n */",
		"name": "org.elasticsearch.client.Cancellable",
		"extends": "",
		"Methods": [
			{
				"signature": "public void cancel()",
				"documentation": "/**\n     * Executes some arbitrary code iff the on-going request has not been cancelled, otherwise throws {@link CancellationException}.\n     */"
			},
			{
				"signature": "void runIfNotCancelled(Runnable runnable)",
				"documentation": ""
			},
			{
				"signature": "static Cancellable fromRequest(HttpRequestBase httpRequest)",
				"documentation": ""
			},
			{
				"signature": "static CancellationException newCancellationException()",
				"documentation": ""
			}
		],
		"interfaces": []
	},
	{
		"documentation": "",
		"name": "org.elasticsearch.client.Cancellable.RequestCancellable",
		"extends": "Cancellable",
		"Methods": [
			{
				"signature": "private RequestCancellable(HttpRequestBase httpRequest)",
				"documentation": ""
			}
		],
		"interfaces": []
	},
	{
		"documentation": "/**\n * Holds the state of a dead connection to a host. Keeps track of how many failed attempts were performed and\n * when the host should be retried (based on number of previous failed attempts).\n * Class is immutable, a new copy of it should be created each time the state has to be changed.\n */",
		"name": "org.elasticsearch.client.DeadHostState",
		"extends": "",
		"Methods": [
			{
				"signature": "DeadHostState(Supplier\u003cLong\u003e timeSupplier)",
				"documentation": "/**\n     * Build the initial dead state of a host. Useful when a working host stops functioning\n     * and needs to be marked dead after its first failure. In such case the host will be retried after a minute or so.\n     *\n     * @param timeSupplier a way to supply the current time and allow for unit testing\n     */"
			},
			{
				"signature": "DeadHostState(DeadHostState previousDeadHostState)",
				"documentation": "/**\n     * Build the dead state of a host given its previous dead state. Useful when a host has been failing before, hence\n     * it already failed for one or more consecutive times. The more failed attempts we register the longer we wait\n     * to retry that same host again. Minimum is 1 minute (for a node the only failed once created\n     * through {@link #DeadHostState(Supplier)}), maximum is 30 minutes (for a node that failed more than 10 consecutive times)\n     *\n     * @param previousDeadHostState the previous state of the host which allows us to increase the wait till the next retry attempt\n     */"
			},
			{
				"signature": "boolean shallBeRetried()",
				"documentation": "/**\n     * Indicates whether it's time to retry to failed host or not.\n     *\n     * @return true if the host should be retried, false otherwise\n     */"
			},
			{
				"signature": "long getDeadUntilNanos()",
				"documentation": "/**\n     * Returns the timestamp (nanos) till the host is supposed to stay dead without being retried.\n     * After that the host should be retried.\n     */"
			},
			{
				"signature": "int getFailedAttempts()",
				"documentation": ""
			},
			{
				"signature": "public int compareTo(DeadHostState other)",
				"documentation": ""
			},
			{
				"signature": "public String toString()",
				"documentation": ""
			}
		],
		"interfaces": [
			"Comparable"
		]
	},
	{
		"documentation": "/**\n * A {@link NodeSelector} that selects nodes that have a particular value\n * for an attribute.\n */",
		"name": "org.elasticsearch.client.HasAttributeNodeSelector",
		"extends": "",
		"Methods": [
			{
				"signature": "public HasAttributeNodeSelector(String key, String value)",
				"documentation": "/**\n * A {@link NodeSelector} that selects nodes that have a particular value\n * for an attribute.\n */"
			},
			{
				"signature": "public void select(Iterable\u003cNode\u003e nodes)",
				"documentation": ""
			},
			{
				"signature": "public boolean equals(Object o)",
				"documentation": ""
			},
			{
				"signature": "public int hashCode()",
				"documentation": ""
			},
			{
				"signature": "public String toString()",
				"documentation": ""
			}
		],
		"interfaces": [
			"NodeSelector"
		]
	},
	{
		"documentation": "/**\n * Default implementation of {@link org.apache.http.nio.protocol.HttpAsyncResponseConsumer}. Buffers the whole\n * response content in heap memory, meaning that the size of the buffer is equal to the content-length of the response.\n * Limits the size of responses that can be read based on a configurable argument. Throws an exception in case the entity is longer\n * than the configured buffer limit.\n */",
		"name": "org.elasticsearch.client.HeapBufferedAsyncResponseConsumer",
		"extends": "org.apache.http.nio.protocol.AbstractAsyncResponseConsumer",
		"Methods": [
			{
				"signature": "public HeapBufferedAsyncResponseConsumer(int bufferLimit)",
				"documentation": "/**\n     * Creates a new instance of this consumer with the provided buffer limit\n     */"
			},
			{
				"signature": "public int getBufferLimit()",
				"documentation": "/**\n     * Get the limit of the buffer.\n     */"
			},
			{
				"signature": "protected void onResponseReceived(HttpResponse httpResponse) throws HttpException, IOException",
				"documentation": ""
			},
			{
				"signature": "protected void onEntityEnclosed(HttpEntity entity, ContentType contentType) throws IOException",
				"documentation": ""
			},
			{
				"signature": "protected ByteBufferAllocator getByteBufferAllocator()",
				"documentation": "/**\n     * Returns the instance of {@link ByteBufferAllocator} to use for content buffering.\n     * Allows to plug in any {@link ByteBufferAllocator} implementation.\n     */"
			},
			{
				"signature": "protected void onContentReceived(ContentDecoder decoder, IOControl ioctrl) throws IOException",
				"documentation": ""
			},
			{
				"signature": "protected HttpResponse buildResult(HttpContext context) throws Exception",
				"documentation": ""
			},
			{
				"signature": "protected void releaseResources()",
				"documentation": ""
			}
		],
		"interfaces": []
	},
	{
		"documentation": "/**\n     * Default factory used to create instances of {@link HttpAsyncResponseConsumer}.\n     * Creates one instance of {@link HeapBufferedAsyncResponseConsumer} for each request attempt, with a configurable\n     * buffer limit which defaults to 100MB.\n     */",
		"name": "org.elasticsearch.client.HttpAsyncResponseConsumerFactory.HeapBufferedResponseConsumerFactory",
		"extends": "",
		"Methods": [
			{
				"signature": "public HeapBufferedResponseConsumerFactory(int bufferLimitBytes)",
				"documentation": "/**\n     * Default factory used to create instances of {@link HttpAsyncResponseConsumer}.\n     * Creates one instance of {@link HeapBufferedAsyncResponseConsumer} for each request attempt, with a configurable\n     * buffer limit which defaults to 100MB.\n     */"
			},
			{
				"signature": "public HttpAsyncResponseConsumer\u003cHttpResponse\u003e createHttpAsyncResponseConsumer()",
				"documentation": ""
			}
		],
		"interfaces": [
			"HttpAsyncResponseConsumerFactory"
		]
	},
	{
		"documentation": "/**\n * Allows to send DELETE requests providing a body (not supported out of the box)\n */",
		"name": "org.elasticsearch.client.HttpDeleteWithEntity",
		"extends": "org.apache.http.client.methods.HttpEntityEnclosingRequestBase",
		"Methods": [
			{
				"signature": "HttpDeleteWithEntity(final URI uri)",
				"documentation": "/**\n * Allows to send DELETE requests providing a body (not supported out of the box)\n */"
			},
			{
				"signature": "public String getMethod()",
				"documentation": ""
			}
		],
		"interfaces": []
	},
	{
		"documentation": "/**\n * Allows to send GET requests providing a body (not supported out of the box)\n */",
		"name": "org.elasticsearch.client.HttpGetWithEntity",
		"extends": "org.apache.http.client.methods.HttpEntityEnclosingRequestBase",
		"Methods": [
			{
				"signature": "HttpGetWithEntity(final URI uri)",
				"documentation": "/**\n * Allows to send GET requests providing a body (not supported out of the box)\n */"
			},
			{
				"signature": "public String getMethod()",
				"documentation": ""
			}
		],
		"interfaces": []
	},
	{
		"documentation": "",
		"name": "org.elasticsearch.client.LanguageRuntimeVersions",
		"extends": "",
		"Methods": [
			{
				"signature": "public static String getRuntimeMetadata()",
				"documentation": "/**\n     * Returns runtime information by looking up classes identifying non-Java JVM\n     * languages and appending a key with their name and their major.minor version, if available\n     */"
			},
			{
				"signature": "public static String kotlinVersion()",
				"documentation": ""
			},
			{
				"signature": "public static String scalaVersion()",
				"documentation": ""
			},
			{
				"signature": "public static String clojureVersion()",
				"documentation": ""
			},
			{
				"signature": "public static String groovyVersion()",
				"documentation": ""
			},
			{
				"signature": "public static String jRubyVersion()",
				"documentation": ""
			},
			{
				"signature": "private static String getStaticField(String className, String fieldName)",
				"documentation": ""
			},
			{
				"signature": "private static String callStaticMethod(String className, String methodName)",
				"documentation": ""
			},
			{
				"signature": "static String keepMajorMinor(String version)",
				"documentation": ""
			}
		],
		"interfaces": []
	},
	{
		"documentation": "/**\n * Metadata about an {@link HttpHost} running Elasticsearch.\n */",
		"name": "org.elasticsearch.client.Node",
		"extends": "",
		"Methods": [
			{
				"signature": "public Node(HttpHost host, Set\u003cHttpHost\u003e boundHosts, String name, String version, Roles roles, Map\u003cString, List\u003cString\u003e\u003e attributes)",
				"documentation": "/**\n     * Create a {@linkplain Node} with metadata. All parameters except\n     * {@code host} are nullable and implementations of {@link NodeSelector}\n     * need to decide what to do in their absence.\n     */"
			},
			{
				"signature": "public Node(HttpHost host)",
				"documentation": "/**\n     * Create a {@linkplain Node} without any metadata.\n     */"
			},
			{
				"signature": "public HttpHost getHost()",
				"documentation": "/**\n     * Contact information for the host.\n     */"
			},
			{
				"signature": "public Set\u003cHttpHost\u003e getBoundHosts()",
				"documentation": "/**\n     * Addresses on which the host is listening. These are useful to have\n     * around because they allow you to find a host based on any address it\n     * is listening on.\n     */"
			},
			{
				"signature": "public String getName()",
				"documentation": "/**\n     * The {@code node.name} of the node.\n     */"
			},
			{
				"signature": "public String getVersion()",
				"documentation": "/**\n     * Version of Elasticsearch that the node is running or {@code null}\n     * if we don't know the version.\n     */"
			},
			{
				"signature": "public Roles getRoles()",
				"documentation": "/**\n     * Roles that the Elasticsearch process on the host has or {@code null}\n     * if we don't know what roles the node has.\n     */"
			},
			{
				"signature": "public Map\u003cString, List\u003cString\u003e\u003e getAttributes()",
				"documentation": "/**\n     * Attributes declared on the node.\n     */"
			},
			{
				"signature": "public String toString()",
				"documentation": ""
			},
			{
				"signature": "public boolean equals(Object obj)",
				"documentation": ""
			},
			{
				"signature": "public int hashCode()",
				"documentation": ""
			}
		],
		"interfaces": []
	},
	{
		"documentation": "/**\n     * Role information about an Elasticsearch process.\n     */",
		"name": "org.elasticsearch.client.Node.Roles",
		"extends": "",
		"Methods": [
			{
				"signature": "public Roles(final Set\u003cString\u003e roles)",
				"documentation": "/**\n     * Role information about an Elasticsearch process.\n     */"
			},
			{
				"signature": "public boolean isMasterEligible()",
				"documentation": "/**\n         * Returns whether or not the node \u003cstrong\u003ecould\u003c/strong\u003e be elected master.\n         */"
			},
			{
				"signature": "public boolean isData()",
				"documentation": "/**\n         * Returns whether or not the node stores data.\n         * @deprecated use {@link #hasDataRole()} or {@link #canContainData()}\n         */"
			},
			{
				"signature": "public boolean hasDataRole()",
				"documentation": "/**\n         * @return true if node has the \"data\" role\n         */"
			},
			{
				"signature": "public boolean hasDataContentRole()",
				"documentation": "/**\n         * @return true if node has the \"data_content\" role\n         */"
			},
			{
				"signature": "public boolean hasDataHotRole()",
				"documentation": "/**\n         * @return true if node has the \"data_hot\" role\n         */"
			},
			{
				"signature": "public boolean hasDataWarmRole()",
				"documentation": "/**\n         * @return true if node has the \"data_warm\" role\n         */"
			},
			{
				"signature": "public boolean hasDataColdRole()",
				"documentation": "/**\n         * @return true if node has the \"data_cold\" role\n         */"
			},
			{
				"signature": "public boolean hasDataFrozenRole()",
				"documentation": "/**\n         * @return true if node has the \"data_frozen\" role\n         */"
			},
			{
				"signature": "public boolean canContainData()",
				"documentation": "/**\n         * @return true if node stores any type of data\n         */"
			},
			{
				"signature": "public boolean isIngest()",
				"documentation": "/**\n         * Returns whether or not the node runs ingest pipelines.\n         */"
			},
			{
				"signature": "public String toString()",
				"documentation": ""
			},
			{
				"signature": "public boolean equals(Object obj)",
				"documentation": ""
			},
			{
				"signature": "public int hashCode()",
				"documentation": ""
			}
		],
		"interfaces": []
	},
	{
		"documentation": "/**\n * An {@link org.apache.http.client.AuthenticationStrategy} implementation that does \u003cem\u003enot\u003c/em\u003e perform\n * any special handling if authentication fails.\n * The default handler in Apache HTTP client mimics standard browser behaviour of clearing authentication\n * credentials if it receives a 401 response from the server. While this can be useful for browser, it is\n * rarely the desired behaviour with the Elasticsearch REST API.\n * If the code using the REST client has configured credentials for the REST API, then we can and should\n * assume that this is intentional, and those credentials represent the best possible authentication\n * mechanism to the Elasticsearch node.\n * If we receive a 401 status, a probably cause is that the authentication mechanism in place was unable\n * to perform the requisite password checks (the node has not yet recovered its state, or an external\n * authentication provider was unavailable).\n * If this occurs, then the desired behaviour is for the Rest client to retry with the same credentials\n * (rather than trying with no credentials, or expecting the calling code to provide alternate credentials).\n */",
		"name": "org.elasticsearch.client.PersistentCredentialsAuthenticationStrategy",
		"extends": "org.apache.http.impl.client.TargetAuthenticationStrategy",
		"Methods": [
			{
				"signature": "public void authFailed(HttpHost host, AuthScheme authScheme, HttpContext context)",
				"documentation": "/**\n * An {@link org.apache.http.client.AuthenticationStrategy} implementation that does \u003cem\u003enot\u003c/em\u003e perform\n * any special handling if authentication fails.\n * The default handler in Apache HTTP client mimics standard browser behaviour of clearing authentication\n * credentials if it receives a 401 response from the server. While this can be useful for browser, it is\n * rarely the desired behaviour with the Elasticsearch REST API.\n * If the code using the REST client has configured credentials for the REST API, then we can and should\n * assume that this is intentional, and those credentials represent the best possible authentication\n * mechanism to the Elasticsearch node.\n * If we receive a 401 status, a probably cause is that the authentication mechanism in place was unable\n * to perform the requisite password checks (the node has not yet recovered its state, or an external\n * authentication provider was unavailable).\n * If this occurs, then the desired behaviour is for the Rest client to retry with the same credentials\n * (rather than trying with no credentials, or expecting the calling code to provide alternate credentials).\n */"
			}
		],
		"interfaces": []
	},
	{
		"documentation": "/**\n * Both {@link PreferHasAttributeNodeSelector} and {@link HasAttributeNodeSelector} will work the same\n * if there is a {@link Node} with particular attribute in the attributes,\n * but {@link PreferHasAttributeNodeSelector} will select another {@link Node}s even if there is no {@link Node}\n * with particular attribute in the attributes.\n */",
		"name": "org.elasticsearch.client.PreferHasAttributeNodeSelector",
		"extends": "",
		"Methods": [
			{
				"signature": "public PreferHasAttributeNodeSelector(String key, String value)",
				"documentation": "/**\n * Both {@link PreferHasAttributeNodeSelector} and {@link HasAttributeNodeSelector} will work the same\n * if there is a {@link Node} with particular attribute in the attributes,\n * but {@link PreferHasAttributeNodeSelector} will select another {@link Node}s even if there is no {@link Node}\n * with particular attribute in the attributes.\n */"
			},
			{
				"signature": "public void select(Iterable\u003cNode\u003e nodes)",
				"documentation": ""
			},
			{
				"signature": "public boolean equals(Object o)",
				"documentation": ""
			},
			{
				"signature": "public int hashCode()",
				"documentation": ""
			},
			{
				"signature": "public String toString()",
				"documentation": ""
			}
		],
		"interfaces": [
			"NodeSelector"
		]
	},
	{
		"documentation": "/**\n * HTTP Request to Elasticsearch.\n */",
		"name": "org.elasticsearch.client.Request",
		"extends": "",
		"Methods": [
			{
				"signature": "public Request(String method, String endpoint)",
				"documentation": "/**\n     * Create the {@linkplain Request}.\n     * @param method the HTTP method\n     * @param endpoint the path of the request (without scheme, host, port, or prefix)\n     */"
			},
			{
				"signature": "public String getMethod()",
				"documentation": "/**\n     * The HTTP method.\n     */"
			},
			{
				"signature": "public String getEndpoint()",
				"documentation": "/**\n     * The path of the request (without scheme, host, port, or prefix).\n     */"
			},
			{
				"signature": "public void addParameter(String name, String value)",
				"documentation": "/**\n     * Add a query string parameter.\n     * @param name the name of the url parameter. Must not be null.\n     * @param value the value of the url url parameter. If {@code null} then\n     *      the parameter is sent as {@code name} rather than {@code name=value}\n     * @throws IllegalArgumentException if a parameter with that name has\n     *      already been set\n     */"
			},
			{
				"signature": "public void addParameters(Map\u003cString, String\u003e paramSource)",
				"documentation": ""
			},
			{
				"signature": "public Map\u003cString, String\u003e getParameters()",
				"documentation": "/**\n     * Query string parameters. The returned map is an unmodifiable view of the\n     * map in the request so calls to {@link #addParameter(String, String)}\n     * will change it.\n     */"
			},
			{
				"signature": "public void setEntity(HttpEntity entity)",
				"documentation": "/**\n     * Set the body of the request. If not set or set to {@code null} then no\n     * body is sent with the request.\n     */"
			},
			{
				"signature": "public void setJsonEntity(String body)",
				"documentation": "/**\n     * Set the body of the request to a string. If not set or set to\n     * {@code null} then no body is sent with the request. The\n     * {@code Content-Type} will be sent as {@code application/json}.\n     * If you need a different content type then use\n     * {@link #setEntity(HttpEntity)}.\n     */"
			},
			{
				"signature": "public HttpEntity getEntity()",
				"documentation": "/**\n     * The body of the request. If {@code null} then no body\n     * is sent with the request.\n     */"
			},
			{
				"signature": "public void setOptions(RequestOptions options)",
				"documentation": "/**\n     * Set the portion of an HTTP request to Elasticsearch that can be\n     * manipulated without changing Elasticsearch's behavior.\n     */"
			},
			{
				"signature": "public void setOptions(RequestOptions.Builder options)",
				"documentation": "/**\n     * Set the portion of an HTTP request to Elasticsearch that can be\n     * manipulated without changing Elasticsearch's behavior.\n     */"
			},
			{
				"signature": "public RequestOptions getOptions()",
				"documentation": "/**\n     * Get the portion of an HTTP request to Elasticsearch that can be\n     * manipulated without changing Elasticsearch's behavior.\n     */"
			},
			{
				"signature": "public String toString()",
				"documentation": ""
			}
		],
		"interfaces": []
	},
	{
		"documentation": "/**\n * Helper class that exposes static methods to unify the way requests are logged.\n * Includes trace logging to log complete requests and responses in curl format.\n * Useful for debugging, manually sending logged requests via curl and checking their responses.\n * Trace logging is a feature that all the language clients provide.\n */",
		"name": "org.elasticsearch.client.RequestLogger",
		"extends": "",
		"Methods": [
			{
				"signature": "private RequestLogger()",
				"documentation": "/**\n * Helper class that exposes static methods to unify the way requests are logged.\n * Includes trace logging to log complete requests and responses in curl format.\n * Useful for debugging, manually sending logged requests via curl and checking their responses.\n * Trace logging is a feature that all the language clients provide.\n */"
			},
			{
				"signature": "static void logResponse(Log logger, HttpUriRequest request, HttpHost host, HttpResponse httpResponse)",
				"documentation": "/**\n     * Logs a request that yielded a response\n     */"
			},
			{
				"signature": "static void logFailedRequest(Log logger, HttpUriRequest request, Node node, Exception e)",
				"documentation": "/**\n     * Logs a request that failed\n     */"
			},
			{
				"signature": "static String buildWarningMessage(HttpUriRequest request, HttpHost host, Header[] warnings)",
				"documentation": ""
			},
			{
				"signature": "static String buildTraceRequest(HttpUriRequest request, HttpHost host) throws IOException",
				"documentation": "/**\n     * Creates curl output for given request\n     */"
			},
			{
				"signature": "static String buildTraceResponse(HttpResponse httpResponse) throws IOException",
				"documentation": "/**\n     * Creates curl output for given response\n     */"
			},
			{
				"signature": "private static String getUri(RequestLine requestLine)",
				"documentation": ""
			}
		],
		"interfaces": []
	},
	{
		"documentation": "/**\n * The portion of an HTTP request to Elasticsearch that can be\n * manipulated without changing Elasticsearch's behavior.\n */",
		"name": "org.elasticsearch.client.RequestOptions",
		"extends": "",
		"Methods": [
			{
				"signature": "private RequestOptions(Builder builder)",
				"documentation": "/**\n     * Default request options.\n     */"
			},
			{
				"signature": "public Builder toBuilder()",
				"documentation": "/**\n     * Create a builder that contains these options but can be modified.\n     */"
			},
			{
				"signature": "public List\u003cHeader\u003e getHeaders()",
				"documentation": "/**\n     * Headers to attach to the request.\n     */"
			},
			{
				"signature": "public boolean containsHeader(String name)",
				"documentation": "/**\n     * Return true if the options contain the given header\n     */"
			},
			{
				"signature": "public Map\u003cString, String\u003e getParameters()",
				"documentation": ""
			},
			{
				"signature": "public HttpAsyncResponseConsumerFactory getHttpAsyncResponseConsumerFactory()",
				"documentation": "/**\n     * The {@link HttpAsyncResponseConsumerFactory} used to create one\n     * {@link HttpAsyncResponseConsumer} callback per retry. Controls how the\n     * response body gets streamed from a non-blocking HTTP connection on the\n     * client side.\n     */"
			},
			{
				"signature": "public WarningsHandler getWarningsHandler()",
				"documentation": "/**\n     * How this request should handle warnings. If null (the default) then\n     * this request will default to the behavior dictacted by\n     * {@link RestClientBuilder#setStrictDeprecationMode}.\n     * \u003cp\u003e\n     * This can be set to {@link WarningsHandler#PERMISSIVE} if the client\n     * should ignore all warnings which is the same behavior as setting\n     * strictDeprecationMode to true. It can be set to\n     * {@link WarningsHandler#STRICT} if the client should fail if there are\n     * any warnings which is the same behavior as settings\n     * strictDeprecationMode to false.\n     * \u003cp\u003e\n     * It can also be set to a custom implementation of\n     * {@linkplain WarningsHandler} to permit only certain warnings or to\n     * fail the request if the warnings returned don't\n     * \u003cstrong\u003eexactly\u003c/strong\u003e match some set.\n     */"
			},
			{
				"signature": "public RequestConfig getRequestConfig()",
				"documentation": "/**\n     * get RequestConfig, which can set socketTimeout, connectTimeout\n     * and so on by request\n     * @return RequestConfig\n     */"
			},
			{
				"signature": "public String toString()",
				"documentation": ""
			},
			{
				"signature": "public boolean equals(Object obj)",
				"documentation": ""
			},
			{
				"signature": "public int hashCode()",
				"documentation": ""
			}
		],
		"interfaces": []
	},
	{
		"documentation": "/**\n     * Builds {@link RequestOptions}. Get one by calling\n     * {@link RequestOptions#toBuilder} on {@link RequestOptions#DEFAULT} or\n     * any other {@linkplain RequestOptions}.\n     */",
		"name": "org.elasticsearch.client.RequestOptions.Builder",
		"extends": "",
		"Methods": [
			{
				"signature": "private Builder(            List\u003cHeader\u003e headers,            Map\u003cString, String\u003e parameters,            HttpAsyncResponseConsumerFactory httpAsyncResponseConsumerFactory,            WarningsHandler warningsHandler,            RequestConfig requestConfig        )",
				"documentation": "/**\n     * Builds {@link RequestOptions}. Get one by calling\n     * {@link RequestOptions#toBuilder} on {@link RequestOptions#DEFAULT} or\n     * any other {@linkplain RequestOptions}.\n     */"
			},
			{
				"signature": "public RequestOptions build()",
				"documentation": "/**\n         * Build the {@linkplain RequestOptions}.\n         */"
			},
			{
				"signature": "public Builder addHeader(String name, String value)",
				"documentation": "/**\n         * Add the provided header to the request.\n         */"
			},
			{
				"signature": "public Builder removeHeader(String name)",
				"documentation": "/**\n         * Remove all headers with the given name.\n         */"
			},
			{
				"signature": "public List\u003cHeader\u003e getHeaders()",
				"documentation": "/**\n         * Return all headers for the request\n         */"
			},
			{
				"signature": "public Builder addParameter(String key, String value)",
				"documentation": "/**\n         * Add the provided parameter to the request.\n         */"
			},
			{
				"signature": "public Builder setHttpAsyncResponseConsumerFactory(HttpAsyncResponseConsumerFactory httpAsyncResponseConsumerFactory)",
				"documentation": "/**\n         * Set the {@link HttpAsyncResponseConsumerFactory} used to create one\n         * {@link HttpAsyncResponseConsumer} callback per retry. Controls how the\n         * response body gets streamed from a non-blocking HTTP connection on the\n         * client side.\n         */"
			},
			{
				"signature": "public Builder setWarningsHandler(WarningsHandler warningsHandler)",
				"documentation": "/**\n         * How this request should handle warnings. If null (the default) then\n         * this request will default to the behavior dictacted by\n         * {@link RestClientBuilder#setStrictDeprecationMode}.\n         * \u003cp\u003e\n         * This can be set to {@link WarningsHandler#PERMISSIVE} if the client\n         * should ignore all warnings which is the same behavior as setting\n         * strictDeprecationMode to true. It can be set to\n         * {@link WarningsHandler#STRICT} if the client should fail if there are\n         * any warnings which is the same behavior as settings\n         * strictDeprecationMode to false.\n         * \u003cp\u003e\n         * It can also be set to a custom implementation of\n         * {@linkplain WarningsHandler} to permit only certain warnings or to\n         * fail the request if the warnings returned don't\n         * \u003cstrong\u003eexactly\u003c/strong\u003e match some set.\n         */"
			},
			{
				"signature": "public Builder setRequestConfig(RequestConfig requestConfig)",
				"documentation": "/**\n         * set RequestConfig, which can set socketTimeout, connectTimeout\n         * and so on by request\n         * @param requestConfig http client RequestConfig\n         * @return Builder\n         */"
			}
		],
		"interfaces": []
	},
	{
		"documentation": "/**\n     * Custom implementation of {@link BasicHeader} that overrides equals and\n     * hashCode so it is easier to test equality of {@link RequestOptions}.\n     */",
		"name": "org.elasticsearch.client.RequestOptions.ReqHeader",
		"extends": "org.apache.http.message.BasicHeader",
		"Methods": [
			{
				"signature": "ReqHeader(String name, String value)",
				"documentation": "/**\n     * Custom implementation of {@link BasicHeader} that overrides equals and\n     * hashCode so it is easier to test equality of {@link RequestOptions}.\n     */"
			},
			{
				"signature": "public boolean equals(Object other)",
				"documentation": ""
			},
			{
				"signature": "public int hashCode()",
				"documentation": ""
			}
		],
		"interfaces": []
	},
	{
		"documentation": "/**\n * Holds an elasticsearch response. It wraps the {@link HttpResponse} returned and associates it with\n * its corresponding {@link RequestLine} and {@link HttpHost}.\n */",
		"name": "org.elasticsearch.client.Response",
		"extends": "",
		"Methods": [
			{
				"signature": "Response(RequestLine requestLine, HttpHost host, HttpResponse response)",
				"documentation": "/**\n * Holds an elasticsearch response. It wraps the {@link HttpResponse} returned and associates it with\n * its corresponding {@link RequestLine} and {@link HttpHost}.\n */"
			},
			{
				"signature": "public RequestLine getRequestLine()",
				"documentation": "/**\n     * Returns the request line that generated this response\n     */"
			},
			{
				"signature": "public HttpHost getHost()",
				"documentation": "/**\n     * Returns the node that returned this response\n     */"
			},
			{
				"signature": "public StatusLine getStatusLine()",
				"documentation": "/**\n     * Returns the status line of the current response\n     */"
			},
			{
				"signature": "public Header[] getHeaders()",
				"documentation": "/**\n     * Returns all the response headers\n     */"
			},
			{
				"signature": "public String getHeader(String name)",
				"documentation": "/**\n     * Returns the value of the first header with a specified name of this message.\n     * If there is more than one matching header in the message the first element is returned.\n     * If there is no matching header in the message \u003ccode\u003enull\u003c/code\u003e is returned.\n     */"
			},
			{
				"signature": "public HttpEntity getEntity()",
				"documentation": "/**\n     * Returns the response body available, null otherwise\n     * @see HttpEntity\n     */"
			},
			{
				"signature": "day of week, atomic group to prevent backtracking        \"\\\\",
				"documentation": "/**\n     * Optimized regular expression to test if a string matches the RFC 1123 date\n     * format (with quotes and leading space). Start/end of line characters and\n     * atomic groups are used to prevent backtracking.\n     */"
			},
			{
				"signature": "month, atomic group to prevent backtracking        \"\\\\",
				"documentation": ""
			},
			{
				"signature": "4-digit year        \"\\\\",
				"documentation": ""
			},
			{
				"signature": ":\\\\",
				"documentation": ""
			},
			{
				"signature": ":\\\\",
				"documentation": ""
			},
			{
				"signature": "private static boolean matchWarningHeaderPatternByPrefix(final String s)",
				"documentation": "/**\n     * Tests if a string matches the RFC 7234 specification for warning headers.\n     * This assumes that the warn code is always 299 or 300 and the warn agent is\n     * always Elasticsearch.\n     *\n     * @param s the value of a warning header formatted according to RFC 7234\n     * @return {@code true} if the input string matches the specification\n     */"
			},
			{
				"signature": "private static String extractWarningValueFromWarningHeader(final String s)",
				"documentation": "/**\n     * Refer to org.elasticsearch.common.logging.DeprecationLogger\n     */"
			},
			{
				"signature": "public List\u003cString\u003e getWarnings()",
				"documentation": "/**\n     * Returns a list of all warning headers returned in the response.\n     */"
			},
			{
				"signature": "public boolean hasWarnings()",
				"documentation": "/**\n     * Returns true if there is at least one warning header returned in the\n     * response.\n     */"
			},
			{
				"signature": "HttpResponse getHttpResponse()",
				"documentation": ""
			},
			{
				"signature": "public String toString()",
				"documentation": ""
			}
		],
		"interfaces": []
	},
	{
		"documentation": "/**\n * Exception thrown when an elasticsearch node responds to a request with a status code that indicates an error.\n * Holds the response that was returned.\n */",
		"name": "org.elasticsearch.client.ResponseException",
		"extends": "java.io.IOException",
		"Methods": [
			{
				"signature": "public ResponseException(Response response) throws IOException",
				"documentation": "/**\n * Exception thrown when an elasticsearch node responds to a request with a status code that indicates an error.\n * Holds the response that was returned.\n */"
			},
			{
				"signature": "static String buildMessage(Response response) throws IOException",
				"documentation": ""
			},
			{
				"signature": "public Response getResponse()",
				"documentation": "/**\n     * Returns the {@link Response} that caused this exception to be thrown.\n     */"
			}
		],
		"interfaces": []
	},
	{
		"documentation": "/**\n * Client that connects to an Elasticsearch cluster through HTTP.\n * \u003cp\u003e\n * Must be created using {@link RestClientBuilder}, which allows to set all the different options or just rely on defaults.\n * The hosts that are part of the cluster need to be provided at creation time, but can also be replaced later\n * by calling {@link #setNodes(Collection)}.\n * \u003cp\u003e\n * The method {@link #performRequest(Request)} allows to send a request to the cluster. When\n * sending a request, a host gets selected out of the provided ones in a round-robin fashion. Failing hosts are marked dead and\n * retried after a certain amount of time (minimum 1 minute, maximum 30 minutes), depending on how many times they previously\n * failed (the more failures, the later they will be retried). In case of failures all of the alive nodes (or dead nodes that\n * deserve a retry) are retried until one responds or none of them does, in which case an {@link IOException} will be thrown.\n * \u003cp\u003e\n * Requests can be either synchronous or asynchronous. The asynchronous variants all end with {@code Async}.\n * \u003cp\u003e\n * Requests can be traced by enabling trace logging for \"tracer\". The trace logger outputs requests and responses in curl format.\n */",
		"name": "org.elasticsearch.client.RestClient",
		"extends": "",
		"Methods": [
			{
				"signature": "RestClient(        CloseableHttpAsyncClient client,        Header[] defaultHeaders,        List\u003cNode\u003e nodes,        String pathPrefix,        FailureListener failureListener,        NodeSelector nodeSelector,        boolean strictDeprecationMode,        boolean compressionEnabled,        boolean metaHeaderEnabled    )",
				"documentation": "/**\n * Client that connects to an Elasticsearch cluster through HTTP.\n * \u003cp\u003e\n * Must be created using {@link RestClientBuilder}, which allows to set all the different options or just rely on defaults.\n * The hosts that are part of the cluster need to be provided at creation time, but can also be replaced later\n * by calling {@link #setNodes(Collection)}.\n * \u003cp\u003e\n * The method {@link #performRequest(Request)} allows to send a request to the cluster. When\n * sending a request, a host gets selected out of the provided ones in a round-robin fashion. Failing hosts are marked dead and\n * retried after a certain amount of time (minimum 1 minute, maximum 30 minutes), depending on how many times they previously\n * failed (the more failures, the later they will be retried). In case of failures all of the alive nodes (or dead nodes that\n * deserve a retry) are retried until one responds or none of them does, in which case an {@link IOException} will be thrown.\n * \u003cp\u003e\n * Requests can be either synchronous or asynchronous. The asynchronous variants all end with {@code Async}.\n * \u003cp\u003e\n * Requests can be traced by enabling trace logging for \"tracer\". The trace logger outputs requests and responses in curl format.\n */"
			},
			{
				"signature": "public static RestClientBuilder builder(String cloudId)",
				"documentation": "/**\n     * Returns a new {@link RestClientBuilder} to help with {@link RestClient} creation.\n     * Creates a new builder instance and sets the nodes that the client will send requests to.\n     *\n     * @param cloudId a valid elastic cloud cloudId that will route to a cluster. The cloudId is located in\n     *                the user console https://cloud.elastic.co and will resemble a string like the following\n     *                optionalHumanReadableName:dXMtZWFzdC0xLmF3cy5mb3VuZC5pbyRlbGFzdGljc2VhcmNoJGtpYmFuYQ==\n     */"
			},
			{
				"signature": "public static RestClientBuilder builder(Node... nodes)",
				"documentation": "/**\n     * Returns a new {@link RestClientBuilder} to help with {@link RestClient} creation.\n     * Creates a new builder instance and sets the hosts that the client will send requests to.\n     * \u003cp\u003e\n     * Prefer this to {@link #builder(HttpHost...)} if you have metadata up front about the nodes.\n     * If you don't either one is fine.\n     */"
			},
			{
				"signature": "public static RestClientBuilder builder(HttpHost... hosts)",
				"documentation": "/**\n     * Returns a new {@link RestClientBuilder} to help with {@link RestClient} creation.\n     * Creates a new builder instance and sets the nodes that the client will send requests to.\n     * \u003cp\u003e\n     * You can use this if you do not have metadata up front about the nodes. If you do, prefer\n     * {@link #builder(Node...)}.\n     * @see Node#Node(HttpHost)\n     */"
			},
			{
				"signature": "public HttpAsyncClient getHttpClient()",
				"documentation": "/**\n     * Get the underlying HTTP client.\n     */"
			},
			{
				"signature": "public List\u003cNode\u003e getNodes()",
				"documentation": "/**\n     * Get the list of nodes that the client knows about. The list is\n     * unmodifiable.\n     */"
			},
			{
				"signature": "public boolean isRunning()",
				"documentation": "/**\n     * check client running status\n     * @return client running status\n     */"
			},
			{
				"signature": "public Response performRequest(Request request) throws IOException",
				"documentation": "/**\n     * Sends a request to the Elasticsearch cluster that the client points to.\n     * Blocks until the request is completed and returns its response or fails\n     * by throwing an exception. Selects a host out of the provided ones in a\n     * round-robin fashion. Failing hosts are marked dead and retried after a\n     * certain amount of time (minimum 1 minute, maximum 30 minutes), depending\n     * on how many times they previously failed (the more failures, the later\n     * they will be retried). In case of failures all of the alive nodes (or\n     * dead nodes that deserve a retry) are retried until one responds or none\n     * of them does, in which case an {@link IOException} will be thrown.\n     *\n     * This method works by performing an asynchronous call and waiting\n     * for the result. If the asynchronous call throws an exception we wrap\n     * it and rethrow it so that the stack trace attached to the exception\n     * contains the call site. While we attempt to preserve the original\n     * exception this isn't always possible and likely haven't covered all of\n     * the cases. You can get the original exception from\n     * {@link Exception#getCause()}.\n     *\n     * @param request the request to perform\n     * @return the response returned by Elasticsearch\n     * @throws IOException in case of a problem or the connection was aborted\n     * @throws ClientProtocolException in case of an http protocol error\n     * @throws ResponseException in case Elasticsearch responded with a status code that indicated an error\n     */"
			},
			{
				"signature": "private Response performRequest(final NodeTuple\u003cIterator\u003cNode\u003e\u003e tuple, final InternalRequest request, Exception previousException)        throws IOException",
				"documentation": ""
			},
			{
				"signature": "private ResponseOrResponseException convertResponse(InternalRequest request, Node node, HttpResponse httpResponse) throws IOException",
				"documentation": ""
			},
			{
				"signature": "public Cancellable performRequestAsync(Request request, ResponseListener responseListener)",
				"documentation": "/**\n     * Sends a request to the Elasticsearch cluster that the client points to.\n     * The request is executed asynchronously and the provided\n     * {@link ResponseListener} gets notified upon request completion or\n     * failure. Selects a host out of the provided ones in a round-robin\n     * fashion. Failing hosts are marked dead and retried after a certain\n     * amount of time (minimum 1 minute, maximum 30 minutes), depending on how\n     * many times they previously failed (the more failures, the later they\n     * will be retried). In case of failures all of the alive nodes (or dead\n     * nodes that deserve a retry) are retried until one responds or none of\n     * them does, in which case an {@link IOException} will be thrown.\n     *\n     * @param request the request to perform\n     * @param responseListener the {@link ResponseListener} to notify when the\n     *      request is completed or fails\n     */"
			},
			{
				"signature": "private void performRequestAsync(        final NodeTuple\u003cIterator\u003cNode\u003e\u003e tuple,        final InternalRequest request,        final FailureTrackingResponseListener listener    )",
				"documentation": ""
			},
			{
				"signature": "public void completed(HttpResponse httpResponse)",
				"documentation": ""
			},
			{
				"signature": "public void failed(Exception failure)",
				"documentation": ""
			},
			{
				"signature": "public void cancelled()",
				"documentation": ""
			},
			{
				"signature": "private NodeTuple\u003cIterator\u003cNode\u003e\u003e nextNodes() throws IOException",
				"documentation": "/**\n     * Returns a non-empty {@link Iterator} of nodes to be used for a request\n     * that match the {@link NodeSelector}.\n     * \u003cp\u003e\n     * If there are no living nodes that match the {@link NodeSelector}\n     * this will return the dead node that matches the {@link NodeSelector}\n     * that is closest to being revived.\n     * @throws IOException if no nodes are available\n     */"
			},
			{
				"signature": "static Iterable\u003cNode\u003e selectNodes(        NodeTuple\u003cList\u003cNode\u003e\u003e nodeTuple,        Map\u003cHttpHost, DeadHostState\u003e blacklist,        AtomicInteger lastNodeIndex,        NodeSelector nodeSelector    ) throws IOException",
				"documentation": "/**\n     * Select nodes to try and sorts them so that the first one will be tried initially, then the following ones\n     * if the previous attempt failed and so on. Package private for testing.\n     */"
			},
			{
				"signature": "private void onResponse(Node node)",
				"documentation": "/**\n     * Called after each successful request call.\n     * Receives as an argument the host that was used for the successful request.\n     */"
			},
			{
				"signature": "private void onFailure(Node node)",
				"documentation": "/**\n     * Called after each failed attempt.\n     * Receives as an argument the host that was used for the failed attempt.\n     */"
			},
			{
				"signature": "public void close() throws IOException",
				"documentation": ""
			},
			{
				"signature": "private static boolean isSuccessfulResponse(int statusCode)",
				"documentation": ""
			},
			{
				"signature": "private static boolean isRetryStatus(int statusCode)",
				"documentation": ""
			},
			{
				"signature": "private static void addSuppressedException(Exception suppressedException, Exception currentException)",
				"documentation": ""
			},
			{
				"signature": "private static HttpRequestBase createHttpRequest(String method, URI uri, HttpEntity entity, boolean compressionEnabled)",
				"documentation": ""
			},
			{
				"signature": "private static HttpRequestBase addRequestBody(HttpRequestBase httpRequest, HttpEntity entity, boolean compressionEnabled)",
				"documentation": ""
			},
			{
				"signature": "static URI buildUri(String pathPrefix, String path, Map\u003cString, String\u003e params)",
				"documentation": ""
			},
			{
				"signature": "private static Set\u003cInteger\u003e getIgnoreErrorCodes(String ignoreString, String requestMethod)",
				"documentation": ""
			},
			{
				"signature": "private static Exception extractAndWrapCause(Exception exception)",
				"documentation": "/**\n     * Wrap the exception so the caller's signature shows up in the stack trace, taking care to copy the original type and message\n     * where possible so async and sync code don't have to check different exceptions.\n     */"
			}
		],
		"interfaces": [
			"java.io.Closeable"
		]
	},
	{
		"documentation": "/**\n     * Listener used in any async call to wrap the provided user listener (or SyncResponseListener in sync calls).\n     * Allows to track potential failures coming from the different retry attempts and returning to the original listener\n     * only when we got a response (successful or not to be retried) or there are no hosts to retry against.\n     */",
		"name": "org.elasticsearch.client.RestClient.FailureTrackingResponseListener",
		"extends": "",
		"Methods": [
			{
				"signature": "FailureTrackingResponseListener(ResponseListener responseListener)",
				"documentation": "/**\n     * Listener used in any async call to wrap the provided user listener (or SyncResponseListener in sync calls).\n     * Allows to track potential failures coming from the different retry attempts and returning to the original listener\n     * only when we got a response (successful or not to be retried) or there are no hosts to retry against.\n     */"
			},
			{
				"signature": "void onSuccess(Response response)",
				"documentation": "/**\n         * Notifies the caller of a response through the wrapped listener\n         */"
			},
			{
				"signature": "void onDefinitiveFailure(Exception e)",
				"documentation": "/**\n         * Tracks one last definitive failure and returns to the caller by notifying the wrapped listener\n         */"
			},
			{
				"signature": "void trackFailure(Exception e)",
				"documentation": "/**\n         * Tracks an exception, which caused a retry hence we should not return yet to the caller\n         */"
			}
		],
		"interfaces": []
	},
	{
		"documentation": "/**\n     * Listener that allows to be notified whenever a failure happens. Useful when sniffing is enabled, so that we can sniff on failure.\n     * The default implementation is a no-op.\n     */",
		"name": "org.elasticsearch.client.RestClient.FailureListener",
		"extends": "",
		"Methods": [
			{
				"signature": "public void onFailure(Node node)",
				"documentation": "/**\n         * Notifies that the node provided as argument has just failed\n         */"
			}
		],
		"interfaces": []
	},
	{
		"documentation": "/**\n     * {@link NodeTuple} enables the {@linkplain Node}s and {@linkplain AuthCache}\n     * to be set together in a thread safe, volatile way.\n     */",
		"name": "org.elasticsearch.client.RestClient.NodeTuple",
		"extends": "",
		"Methods": [
			{
				"signature": "NodeTuple(final T nodes, final AuthCache authCache)",
				"documentation": "/**\n     * {@link NodeTuple} enables the {@linkplain Node}s and {@linkplain AuthCache}\n     * to be set together in a thread safe, volatile way.\n     */"
			}
		],
		"interfaces": []
	},
	{
		"documentation": "/**\n     * Contains a reference to a blacklisted node and the time until it is\n     * revived. We use this so we can do a single pass over the blacklist.\n     */",
		"name": "org.elasticsearch.client.RestClient.DeadNode",
		"extends": "",
		"Methods": [
			{
				"signature": "DeadNode(Node node, DeadHostState deadness)",
				"documentation": "/**\n     * Contains a reference to a blacklisted node and the time until it is\n     * revived. We use this so we can do a single pass over the blacklist.\n     */"
			},
			{
				"signature": "public String toString()",
				"documentation": ""
			},
			{
				"signature": "public int compareTo(DeadNode rhs)",
				"documentation": ""
			}
		],
		"interfaces": [
			"Comparable"
		]
	},
	{
		"documentation": "/**\n     * Adapts an \u003ccode\u003eIterator\u0026lt;DeadNodeAndRevival\u0026gt;\u003c/code\u003e into an\n     * \u003ccode\u003eIterator\u0026lt;Node\u0026gt;\u003c/code\u003e.\n     */",
		"name": "org.elasticsearch.client.RestClient.DeadNodeIteratorAdapter",
		"extends": "",
		"Methods": [
			{
				"signature": "private DeadNodeIteratorAdapter(Iterator\u003cDeadNode\u003e itr)",
				"documentation": "/**\n     * Adapts an \u003ccode\u003eIterator\u0026lt;DeadNodeAndRevival\u0026gt;\u003c/code\u003e into an\n     * \u003ccode\u003eIterator\u0026lt;Node\u0026gt;\u003c/code\u003e.\n     */"
			},
			{
				"signature": "public boolean hasNext()",
				"documentation": ""
			},
			{
				"signature": "public Node next()",
				"documentation": ""
			},
			{
				"signature": "public void remove()",
				"documentation": ""
			}
		],
		"interfaces": [
			"java.util.Iterator"
		]
	},
	{
		"documentation": "",
		"name": "org.elasticsearch.client.InternalRequest",
		"extends": "",
		"Methods": [
			{
				"signature": "InternalRequest(Request request)",
				"documentation": ""
			},
			{
				"signature": "private void setHeaders(HttpRequest req, Collection\u003cHeader\u003e requestHeaders)",
				"documentation": ""
			},
			{
				"signature": "private void setRequestConfig(HttpRequestBase requestBase, RequestConfig requestConfig)",
				"documentation": ""
			},
			{
				"signature": "RequestContext createContextForNextAttempt(Node node, AuthCache authCache)",
				"documentation": ""
			}
		],
		"interfaces": []
	},
	{
		"documentation": "",
		"name": "org.elasticsearch.client.RestClient.RequestContext",
		"extends": "",
		"Methods": [
			{
				"signature": "RequestContext(InternalRequest request, Node node, AuthCache authCache)",
				"documentation": ""
			}
		],
		"interfaces": []
	},
	{
		"documentation": "",
		"name": "org.elasticsearch.client.RestClient.ResponseOrResponseException",
		"extends": "",
		"Methods": [
			{
				"signature": "ResponseOrResponseException(Response response)",
				"documentation": ""
			},
			{
				"signature": "ResponseOrResponseException(ResponseException responseException)",
				"documentation": ""
			}
		],
		"interfaces": []
	},
	{
		"documentation": "/**\n     * A gzip compressing entity that also implements {@code getContent()}.\n     */",
		"name": "org.elasticsearch.client.RestClient.ContentCompressingEntity",
		"extends": "org.apache.http.client.entity.GzipCompressingEntity",
		"Methods": [
			{
				"signature": "public ContentCompressingEntity(HttpEntity entity)",
				"documentation": "/**\n     * A gzip compressing entity that also implements {@code getContent()}.\n     */"
			},
			{
				"signature": "public InputStream getContent() throws IOException",
				"documentation": ""
			}
		],
		"interfaces": []
	},
	{
		"documentation": "/**\n     * A ByteArrayOutputStream that can be turned into an input stream without copying the underlying buffer.\n     */",
		"name": "org.elasticsearch.client.RestClient.ByteArrayInputOutputStream",
		"extends": "java.io.ByteArrayOutputStream",
		"Methods": [
			{
				"signature": "ByteArrayInputOutputStream(int size)",
				"documentation": "/**\n     * A ByteArrayOutputStream that can be turned into an input stream without copying the underlying buffer.\n     */"
			},
			{
				"signature": "public InputStream asInput()",
				"documentation": ""
			}
		],
		"interfaces": []
	},
	{
		"documentation": "/**\n * Helps creating a new {@link RestClient}. Allows to set the most common http client configuration options when internally\n * creating the underlying {@link org.apache.http.nio.client.HttpAsyncClient}. Also allows to provide an externally created\n * {@link org.apache.http.nio.client.HttpAsyncClient} in case additional customization is needed.\n */",
		"name": "org.elasticsearch.client.RestClientBuilder",
		"extends": "",
		"Methods": [
			{
				"signature": "static",
				"documentation": "/**\n * Helps creating a new {@link RestClient}. Allows to set the most common http client configuration options when internally\n * creating the underlying {@link org.apache.http.nio.client.HttpAsyncClient}. Also allows to provide an externally created\n * {@link org.apache.http.nio.client.HttpAsyncClient} in case additional customization is needed.\n */"
			},
			{
				"signature": "RestClientBuilder(List\u003cNode\u003e nodes)",
				"documentation": "/**\n     * Creates a new builder instance and sets the hosts that the client will send requests to.\n     *\n     * @throws IllegalArgumentException if {@code nodes} is {@code null} or empty.\n     */"
			},
			{
				"signature": "public RestClientBuilder setDefaultHeaders(Header[] defaultHeaders)",
				"documentation": "/**\n     * Sets the default request headers, which will be sent along with each request.\n     * \u003cp\u003e\n     * Request-time headers will always overwrite any default headers.\n     *\n     * @throws NullPointerException if {@code defaultHeaders} or any header is {@code null}.\n     */"
			},
			{
				"signature": "public RestClientBuilder setFailureListener(RestClient.FailureListener failureListener)",
				"documentation": "/**\n     * Sets the {@link RestClient.FailureListener} to be notified for each request failure\n     *\n     * @throws NullPointerException if {@code failureListener} is {@code null}.\n     */"
			},
			{
				"signature": "public RestClientBuilder setHttpClientConfigCallback(HttpClientConfigCallback httpClientConfigCallback)",
				"documentation": "/**\n     * Sets the {@link HttpClientConfigCallback} to be used to customize http client configuration\n     *\n     * @throws NullPointerException if {@code httpClientConfigCallback} is {@code null}.\n     */"
			},
			{
				"signature": "public RestClientBuilder setRequestConfigCallback(RequestConfigCallback requestConfigCallback)",
				"documentation": "/**\n     * Sets the {@link RequestConfigCallback} to be used to customize http client configuration\n     *\n     * @throws NullPointerException if {@code requestConfigCallback} is {@code null}.\n     */"
			},
			{
				"signature": "public RestClientBuilder setPathPrefix(String pathPrefix)",
				"documentation": "/**\n     * Sets the path's prefix for every request used by the http client.\n     * \u003cp\u003e\n     * For example, if this is set to \"/my/path\", then any client request will become \u003ccode\u003e\"/my/path/\" + endpoint\u003c/code\u003e.\n     * \u003cp\u003e\n     * In essence, every request's {@code endpoint} is prefixed by this {@code pathPrefix}. The path prefix is useful for when\n     * Elasticsearch is behind a proxy that provides a base path or a proxy that requires all paths to start with '/';\n     * it is not intended for other purposes and it should not be supplied in other scenarios.\n     *\n     * @throws NullPointerException if {@code pathPrefix} is {@code null}.\n     * @throws IllegalArgumentException if {@code pathPrefix} is empty, or ends with more than one '/'.\n     */"
			},
			{
				"signature": "public static String cleanPathPrefix(String pathPrefix)",
				"documentation": ""
			},
			{
				"signature": "public RestClientBuilder setNodeSelector(NodeSelector nodeSelector)",
				"documentation": "/**\n     * Sets the {@link NodeSelector} to be used for all requests.\n     * @throws NullPointerException if the provided nodeSelector is null\n     */"
			},
			{
				"signature": "public RestClientBuilder setStrictDeprecationMode(boolean strictDeprecationMode)",
				"documentation": "/**\n     * Whether the REST client should return any response containing at least\n     * one warning header as a failure.\n     */"
			},
			{
				"signature": "public RestClientBuilder setCompressionEnabled(boolean compressionEnabled)",
				"documentation": "/**\n     * Whether the REST client should compress requests using gzip content encoding and add the \"Accept-Encoding: gzip\"\n     * header to receive compressed responses.\n     */"
			},
			{
				"signature": "public RestClientBuilder setMetaHeaderEnabled(boolean metadataEnabled)",
				"documentation": "/**\n     * Whether to send a {@code X-Elastic-Client-Meta} header that describes the runtime environment. It contains\n     * information that is similar to what could be found in {@code User-Agent}. Using a separate header allows\n     * applications to use {@code User-Agent} for their own needs, e.g. to identify application version or other\n     * environment information. Defaults to {@code true}.\n     */"
			},
			{
				"signature": "public RestClient build()",
				"documentation": "/**\n     * Creates a new {@link RestClient} based on the provided configuration.\n     */"
			},
			{
				"signature": "private CloseableHttpAsyncClient createHttpClient()",
				"documentation": ""
			}
		],
		"interfaces": []
	},
	{
		"documentation": "/**\n * This exception is used to indicate that one or more {@link Response#getWarnings()} exist\n * and is typically used when the {@link RestClient} is set to fail by setting\n * {@link RestClientBuilder#setStrictDeprecationMode(boolean)} to `true`.\n */",
		"name": "org.elasticsearch.client.WarningFailureException",
		"extends": "RuntimeException",
		"Methods": [
			{
				"signature": "public WarningFailureException(Response response) throws IOException",
				"documentation": "/**\n * This exception is used to indicate that one or more {@link Response#getWarnings()} exist\n * and is typically used when the {@link RestClient} is set to fail by setting\n * {@link RestClientBuilder#setStrictDeprecationMode(boolean)} to `true`.\n */"
			},
			{
				"signature": "WarningFailureException(WarningFailureException e)",
				"documentation": "/**\n     * Wrap a {@linkplain WarningFailureException} with another one with the current\n     * stack trace. This is used during synchronous calls so that the caller\n     * ends up in the stack trace of the exception thrown.\n     */"
			},
			{
				"signature": "public Response getResponse()",
				"documentation": "/**\n     * Returns the {@link Response} that caused this exception to be thrown.\n     */"
			}
		],
		"interfaces": []
	},
	{
		"documentation": "",
		"name": "org.elasticsearch.client.DeadHostStateTests",
		"extends": "RestClientTestCase",
		"Methods": [
			{
				"signature": "public void testInitialDeadHostStateDefaultTimeSupplier()",
				"documentation": ""
			},
			{
				"signature": "public void testDeadHostStateFromPreviousDefaultTimeSupplier()",
				"documentation": ""
			},
			{
				"signature": "public void testCompareToTimeSupplier()",
				"documentation": ""
			},
			{
				"signature": "public void testCompareToDifferingTimeSupplier()",
				"documentation": ""
			},
			{
				"signature": "public void testShallBeRetried()",
				"documentation": ""
			},
			{
				"signature": "public void testDeadHostStateTimeouts()",
				"documentation": ""
			}
		],
		"interfaces": []
	},
	{
		"documentation": "",
		"name": "org.elasticsearch.client.FailureTrackingResponseListenerTests",
		"extends": "RestClientTestCase",
		"Methods": [
			{
				"signature": "public void testOnSuccess()",
				"documentation": ""
			},
			{
				"signature": "public void testOnFailure()",
				"documentation": ""
			},
			{
				"signature": "do",
				"documentation": ""
			},
			{
				"signature": "private static Response mockResponse()",
				"documentation": ""
			}
		],
		"interfaces": []
	},
	{
		"documentation": "",
		"name": "org.elasticsearch.client.FailureTrackingResponseListenerTests.MockResponseListener",
		"extends": "",
		"Methods": [
			{
				"signature": "public void onSuccess(Response response)",
				"documentation": ""
			},
			{
				"signature": "public void onFailure(Exception exception)",
				"documentation": ""
			}
		],
		"interfaces": [
			"ResponseListener"
		]
	},
	{
		"documentation": "",
		"name": "org.elasticsearch.client.HasAttributeNodeSelectorTests",
		"extends": "RestClientTestCase",
		"Methods": [
			{
				"signature": "public void testHasAttribute()",
				"documentation": ""
			},
			{
				"signature": "private static Node dummyNode(Map\u003cString, List\u003cString\u003e\u003e attributes)",
				"documentation": ""
			}
		],
		"interfaces": []
	},
	{
		"documentation": "",
		"name": "org.elasticsearch.client.HeapBufferedAsyncResponseConsumerTests",
		"extends": "RestClientTestCase",
		"Methods": [
			{
				"signature": "public void testResponseProcessing() throws Exception",
				"documentation": ""
			},
			{
				"signature": "public void testDefaultBufferLimit() throws Exception",
				"documentation": ""
			},
			{
				"signature": "public void testConfiguredBufferLimit() throws Exception",
				"documentation": ""
			},
			{
				"signature": "public void testCanConfigureHeapBufferLimitFromOutsidePackage() throws ClassNotFoundException, NoSuchMethodException,        IllegalAccessException, InvocationTargetException, InstantiationException",
				"documentation": ""
			},
			{
				"signature": "public void testHttpAsyncResponseConsumerFactoryVisibility() throws ClassNotFoundException",
				"documentation": ""
			},
			{
				"signature": "private static void bufferLimitTest(HeapBufferedAsyncResponseConsumer consumer, int bufferLimit) throws Exception",
				"documentation": ""
			},
			{
				"signature": "public long getContentLength()",
				"documentation": ""
			}
		],
		"interfaces": []
	},
	{
		"documentation": "/**\n * {@link RestClient.FailureListener} impl that allows to track when it gets called for which host.\n */",
		"name": "org.elasticsearch.client.HostsTrackingFailureListener",
		"extends": "RestClient.FailureListener",
		"Methods": [
			{
				"signature": "public void onFailure(Node node)",
				"documentation": "/**\n * {@link RestClient.FailureListener} impl that allows to track when it gets called for which host.\n */"
			},
			{
				"signature": "void assertCalled(List\u003cNode\u003e nodes)",
				"documentation": ""
			},
			{
				"signature": "void assertCalled(HttpHost... hosts)",
				"documentation": ""
			},
			{
				"signature": "void assertNotCalled()",
				"documentation": ""
			}
		],
		"interfaces": []
	},
	{
		"documentation": "",
		"name": "org.elasticsearch.client.NodeSelectorTests",
		"extends": "RestClientTestCase",
		"Methods": [
			{
				"signature": "public void testAny()",
				"documentation": ""
			},
			{
				"signature": "public void testNotMasterOnly()",
				"documentation": ""
			},
			{
				"signature": "private static Node dummyNode(boolean master, boolean data, boolean ingest)",
				"documentation": ""
			},
			{
				"signature": "private static Node dummyNode(        boolean master,        boolean data,        boolean ingest,        boolean dataContent,        boolean dataHot,        boolean dataWarm,        boolean dataCold,        boolean dataFrozen    )",
				"documentation": ""
			}
		],
		"interfaces": []
	},
	{
		"documentation": "",
		"name": "org.elasticsearch.client.NodeTests",
		"extends": "RestClientTestCase",
		"Methods": [
			{
				"signature": "public void testToString()",
				"documentation": ""
			},
			{
				"signature": "public void testEqualsAndHashCode()",
				"documentation": ""
			},
			{
				"signature": "public void testDataRole()",
				"documentation": ""
			}
		],
		"interfaces": []
	},
	{
		"documentation": "",
		"name": "org.elasticsearch.client.PreferHasAttributeNodeSelectorTests",
		"extends": "RestClientTestCase",
		"Methods": [
			{
				"signature": "public void testFoundPreferHasAttribute()",
				"documentation": ""
			},
			{
				"signature": "public void testNotFoundPreferHasAttribute()",
				"documentation": ""
			},
			{
				"signature": "private static Node dummyNode(Map\u003cString, List\u003cString\u003e\u003e attributes)",
				"documentation": ""
			}
		],
		"interfaces": []
	},
	{
		"documentation": "",
		"name": "org.elasticsearch.client.RequestLoggerTests",
		"extends": "RestClientTestCase",
		"Methods": [
			{
				"signature": "public void testTraceRequest() throws IOException, URISyntaxException",
				"documentation": ""
			},
			{
				"signature": "public void testTraceResponse() throws IOException",
				"documentation": ""
			},
			{
				"signature": "public void testResponseWarnings() throws Exception",
				"documentation": ""
			},
			{
				"signature": "private static HttpUriRequest randomHttpRequest(URI uri)",
				"documentation": ""
			}
		],
		"interfaces": []
	},
	{
		"documentation": "",
		"name": "org.elasticsearch.client.RequestOptionsTests",
		"extends": "RestClientTestCase",
		"Methods": [
			{
				"signature": "public void testDefault()",
				"documentation": ""
			},
			{
				"signature": "public void testAddHeader()",
				"documentation": ""
			},
			{
				"signature": "public void testSetHttpAsyncResponseConsumerFactory()",
				"documentation": ""
			},
			{
				"signature": "public void testAddParameters()",
				"documentation": ""
			},
			{
				"signature": "public void testSetRequestBuilder()",
				"documentation": ""
			},
			{
				"signature": "public void testEqualsAndHashCode()",
				"documentation": ""
			},
			{
				"signature": "static RequestOptions.Builder randomBuilder()",
				"documentation": ""
			},
			{
				"signature": "private static RequestOptions copy(RequestOptions options)",
				"documentation": ""
			},
			{
				"signature": "private static RequestOptions mutate(RequestOptions options)",
				"documentation": ""
			},
			{
				"signature": "public boolean warningsShouldFailRequest(List\u003cString\u003e warnings)",
				"documentation": ""
			}
		],
		"interfaces": []
	},
	{
		"documentation": "",
		"name": "org.elasticsearch.client.RequestTests",
		"extends": "RestClientTestCase",
		"Methods": [
			{
				"signature": "public void testConstructor()",
				"documentation": ""
			},
			{
				"signature": "public void testAddParameters()",
				"documentation": ""
			},
			{
				"signature": "public void testSetEntity()",
				"documentation": ""
			},
			{
				"signature": "public void testSetJsonEntity() throws IOException",
				"documentation": ""
			},
			{
				"signature": "public void testSetOptions()",
				"documentation": ""
			},
			{
				"signature": "public void testEqualsAndHashCode()",
				"documentation": ""
			},
			{
				"signature": "private static Request randomRequest()",
				"documentation": ""
			},
			{
				"signature": "private static Request copy(Request request)",
				"documentation": ""
			},
			{
				"signature": "private static Request mutate(Request request)",
				"documentation": ""
			},
			{
				"signature": "private static void copyMutables(Request from, Request to)",
				"documentation": ""
			}
		],
		"interfaces": []
	},
	{
		"documentation": "",
		"name": "org.elasticsearch.client.ResponseExceptionTests",
		"extends": "RestClientTestCase",
		"Methods": [
			{
				"signature": "public void testResponseException() throws IOException",
				"documentation": ""
			}
		],
		"interfaces": []
	},
	{
		"documentation": "/**\n * Integration test to validate the builder builds a client with the correct configuration\n */",
		"name": "org.elasticsearch.client.RestClientBuilderIntegTests",
		"extends": "RestClientTestCase",
		"Methods": [
			{
				"signature": "public static void startHttpServer() throws Exception",
				"documentation": "/**\n * Integration test to validate the builder builds a client with the correct configuration\n */"
			},
			{
				"signature": "public static void stopHttpServers() throws IOException",
				"documentation": ""
			},
			{
				"signature": "public void testBuilderUsesDefaultSSLContext() throws Exception",
				"documentation": ""
			},
			{
				"signature": "private RestClient buildRestClient()",
				"documentation": ""
			},
			{
				"signature": "private static SSLContext getSslContext() throws Exception",
				"documentation": ""
			},
			{
				"signature": "private static String getProtocol()",
				"documentation": "/**\n     * The {@link HttpsServer} in the JDK has issues with TLSv1.3 when running in a JDK prior to\n     * 12.0.1 so we pin to TLSv1.2 when running on an earlier JDK\n     */"
			}
		],
		"interfaces": []
	},
	{
		"documentation": "",
		"name": "org.elasticsearch.client.RestClientBuilderIntegTests.ResponseHandler",
		"extends": "",
		"Methods": [
			{
				"signature": "public void handle(HttpExchange httpExchange) throws IOException",
				"documentation": ""
			}
		],
		"interfaces": [
			"com.sun.net.httpserver.HttpHandler"
		]
	},
	{
		"documentation": "",
		"name": "org.elasticsearch.client.RestClientBuilderTests",
		"extends": "RestClientTestCase",
		"Methods": [
			{
				"signature": "public void testBuild() throws IOException",
				"documentation": ""
			},
			{
				"signature": "public HttpAsyncClientBuilder customizeHttpClient(HttpAsyncClientBuilder httpClientBuilder)",
				"documentation": ""
			},
			{
				"signature": "public RequestConfig.Builder customizeRequestConfig(RequestConfig.Builder requestConfigBuilder)",
				"documentation": ""
			},
			{
				"signature": "public void testBuildCloudId() throws IOException",
				"documentation": ""
			},
			{
				"signature": "public void testBuildCloudIdWithPort() throws IOException",
				"documentation": ""
			},
			{
				"signature": "public void testSetPathPrefixNull()",
				"documentation": ""
			},
			{
				"signature": "public void testSetPathPrefixEmpty()",
				"documentation": ""
			},
			{
				"signature": "public void testSetPathPrefixMalformed()",
				"documentation": ""
			},
			{
				"signature": "private static void assertSetPathPrefixThrows(final String pathPrefix)",
				"documentation": ""
			},
			{
				"signature": "public void testDefaultConnectionRequestTimeout() throws IOException",
				"documentation": "/**\n     * This test verifies that we don't change the default value for the connection request timeout as that causes problems.\n     * See https://github.com/elastic/elasticsearch/issues/24069\n     */"
			},
			{
				"signature": "public RequestConfig.Builder customizeRequestConfig(RequestConfig.Builder requestConfigBuilder)",
				"documentation": "/**\n     * This test verifies that we don't change the default value for the connection request timeout as that causes problems.\n     * See https://github.com/elastic/elasticsearch/issues/24069\n     */"
			}
		],
		"interfaces": []
	},
	{
		"documentation": "",
		"name": "org.elasticsearch.client.RestClientGzipCompressionTests",
		"extends": "RestClientTestCase",
		"Methods": [
			{
				"signature": "public static void startHttpServer() throws Exception",
				"documentation": ""
			},
			{
				"signature": "public static void stopHttpServers() throws IOException",
				"documentation": ""
			},
			{
				"signature": "private static byte[] readAll(InputStream in) throws IOException",
				"documentation": "/** Read all bytes of an input stream and close it. */"
			},
			{
				"signature": "private RestClient createClient(boolean enableCompression)",
				"documentation": ""
			},
			{
				"signature": "public void testUncompressedSync() throws Exception",
				"documentation": ""
			},
			{
				"signature": "public void testGzipHeaderSync() throws Exception",
				"documentation": ""
			},
			{
				"signature": "public void testGzipHeaderAsync() throws Exception",
				"documentation": ""
			},
			{
				"signature": "public void testCompressingClientSync() throws Exception",
				"documentation": ""
			},
			{
				"signature": "public void testCompressingClientAsync() throws Exception",
				"documentation": ""
			},
			{
				"signature": "private static void checkResponse(String expected, Response response) throws Exception",
				"documentation": ""
			}
		],
		"interfaces": []
	},
	{
		"documentation": "/**\n     * A response handler that accepts gzip-encoded data and replies request and response encoding values\n     * followed by the request body. The response is compressed if \"Accept-Encoding\" is \"gzip\".\n     */",
		"name": "org.elasticsearch.client.RestClientGzipCompressionTests.GzipResponseHandler",
		"extends": "",
		"Methods": [
			{
				"signature": "public void handle(HttpExchange exchange) throws IOException",
				"documentation": "/**\n     * A response handler that accepts gzip-encoded data and replies request and response encoding values\n     * followed by the request body. The response is compressed if \"Accept-Encoding\" is \"gzip\".\n     */"
			}
		],
		"interfaces": [
			"com.sun.net.httpserver.HttpHandler"
		]
	},
	{
		"documentation": "",
		"name": "org.elasticsearch.client.RestClientGzipCompressionTests.FutureResponse",
		"extends": "java.util.concurrent.CompletableFuture",
		"Methods": [
			{
				"signature": "public void onSuccess(Response response)",
				"documentation": ""
			},
			{
				"signature": "public void onFailure(Exception exception)",
				"documentation": ""
			}
		],
		"interfaces": [
			"ResponseListener"
		]
	},
	{
		"documentation": "/**\n * Integration test to check interaction between {@link RestClient} and {@link org.apache.http.client.HttpClient}.\n * Works against real http servers, multiple hosts. Also tests failover by randomly shutting down hosts.\n */",
		"name": "org.elasticsearch.client.RestClientMultipleHostsIntegTests",
		"extends": "RestClientTestCase",
		"Methods": [
			{
				"signature": "public static void startHttpServer() throws Exception",
				"documentation": "/**\n * Integration test to check interaction between {@link RestClient} and {@link org.apache.http.client.HttpClient}.\n * Works against real http servers, multiple hosts. Also tests failover by randomly shutting down hosts.\n */"
			},
			{
				"signature": "private static RestClient buildRestClient(NodeSelector nodeSelector)",
				"documentation": ""
			},
			{
				"signature": "private static HttpServer createHttpServer() throws Exception",
				"documentation": ""
			},
			{
				"signature": "private static WaitForCancelHandler resetWaitHandlers()",
				"documentation": ""
			},
			{
				"signature": "public static void stopHttpServers() throws IOException",
				"documentation": ""
			},
			{
				"signature": "public void stopRandomHost()",
				"documentation": ""
			},
			{
				"signature": "public void testSyncRequests() throws IOException",
				"documentation": ""
			},
			{
				"signature": "public void testAsyncRequests() throws Exception",
				"documentation": ""
			},
			{
				"signature": "public void onSuccess(Response response)",
				"documentation": ""
			},
			{
				"signature": "public void onFailure(Exception exception)",
				"documentation": ""
			},
			{
				"signature": "public void testCancelAsyncRequests() throws Exception",
				"documentation": ""
			},
			{
				"signature": "public void onSuccess(Response response)",
				"documentation": ""
			},
			{
				"signature": "public void onFailure(Exception exception)",
				"documentation": ""
			},
			{
				"signature": "public void testNodeSelector() throws Exception",
				"documentation": "/**\n     * Test host selector against a real server \u003cstrong\u003eand\u003c/strong\u003e\n     * test what happens after calling\n     */"
			},
			{
				"signature": "private NodeSelector firstPositionNodeSelector()",
				"documentation": ""
			}
		],
		"interfaces": []
	},
	{
		"documentation": "",
		"name": "org.elasticsearch.client.RestClientMultipleHostsIntegTests.WaitForCancelHandler",
		"extends": "",
		"Methods": [
			{
				"signature": "void cancelDone()",
				"documentation": ""
			},
			{
				"signature": "void awaitRequest() throws InterruptedException",
				"documentation": ""
			},
			{
				"signature": "public void handle(HttpExchange exchange) throws IOException",
				"documentation": ""
			}
		],
		"interfaces": [
			"com.sun.net.httpserver.HttpHandler"
		]
	},
	{
		"documentation": "",
		"name": "org.elasticsearch.client.RestClientMultipleHostsIntegTests.ResponseHandler",
		"extends": "",
		"Methods": [
			{
				"signature": "ResponseHandler(int statusCode)",
				"documentation": ""
			},
			{
				"signature": "public void handle(HttpExchange httpExchange) throws IOException",
				"documentation": ""
			}
		],
		"interfaces": [
			"com.sun.net.httpserver.HttpHandler"
		]
	},
	{
		"documentation": "",
		"name": "org.elasticsearch.client.RestClientMultipleHostsIntegTests.TestResponse",
		"extends": "",
		"Methods": [
			{
				"signature": "TestResponse(String method, int statusCode, Object response)",
				"documentation": ""
			},
			{
				"signature": "Response getResponse()",
				"documentation": ""
			}
		],
		"interfaces": []
	},
	{
		"documentation": "/**\n * Tests for {@link RestClient} behaviour against multiple hosts: fail-over, blacklisting etc.\n * Relies on a mock http client to intercept requests and return desired responses based on request path.\n */",
		"name": "org.elasticsearch.client.RestClientMultipleHostsTests",
		"extends": "RestClientTestCase",
		"Methods": [
			{
				"signature": "public RestClient createRestClient(NodeSelector nodeSelector)",
				"documentation": "/**\n * Tests for {@link RestClient} behaviour against multiple hosts: fail-over, blacklisting etc.\n * Relies on a mock http client to intercept requests and return desired responses based on request path.\n */"
			},
			{
				"signature": "public void shutdownExec()",
				"documentation": "/**\n     * Shutdown the executor so we don't leak threads into other test runs.\n     */"
			},
			{
				"signature": "public void testRoundRobinOkStatusCodes() throws Exception",
				"documentation": ""
			},
			{
				"signature": "public void testRoundRobinNoRetryErrors() throws Exception",
				"documentation": ""
			},
			{
				"signature": "public void testRoundRobinRetryErrors() throws Exception",
				"documentation": ""
			},
			{
				"signature": "do",
				"documentation": ""
			},
			{
				"signature": "do",
				"documentation": ""
			},
			{
				"signature": "public void testNodeSelector() throws Exception",
				"documentation": ""
			},
			{
				"signature": "public void testSetNodes() throws Exception",
				"documentation": ""
			},
			{
				"signature": "private static String randomErrorRetryEndpoint()",
				"documentation": ""
			},
			{
				"signature": "private Set\u003cHttpHost\u003e hostsSet()",
				"documentation": "/**\n     * Build a mutable {@link Set} containing all the {@link Node#getHost() hosts}\n     * in use by the test.\n     */"
			}
		],
		"interfaces": []
	},
	{
		"documentation": "/**\n * Integration test to check interaction between {@link RestClient} and {@link org.apache.http.client.HttpClient}.\n * Works against a real http server, one single host.\n */",
		"name": "org.elasticsearch.client.RestClientSingleHostIntegTests",
		"extends": "RestClientTestCase",
		"Methods": [
			{
				"signature": "public void startHttpServer() throws Exception",
				"documentation": "/**\n * Integration test to check interaction between {@link RestClient} and {@link org.apache.http.client.HttpClient}.\n * Works against a real http server, one single host.\n */"
			},
			{
				"signature": "private HttpServer createHttpServer() throws Exception",
				"documentation": ""
			},
			{
				"signature": "private RestClient createRestClient(final boolean useAuth, final boolean usePreemptiveAuth, final boolean enableMetaHeader)",
				"documentation": ""
			},
			{
				"signature": "public HttpAsyncClientBuilder customizeHttpClient(final HttpAsyncClientBuilder httpClientBuilder)",
				"documentation": ""
			},
			{
				"signature": "public void stopHttpServers() throws IOException",
				"documentation": ""
			},
			{
				"signature": "public void testManyAsyncRequests() throws Exception",
				"documentation": "/**\n     * Tests sending a bunch of async requests works well (e.g. no TimeoutException from the leased pool)\n     * See https://github.com/elastic/elasticsearch/issues/24069\n     */"
			},
			{
				"signature": "public void onSuccess(Response response)",
				"documentation": "/**\n     * Tests sending a bunch of async requests works well (e.g. no TimeoutException from the leased pool)\n     * See https://github.com/elastic/elasticsearch/issues/24069\n     */"
			},
			{
				"signature": "public void onFailure(Exception exception)",
				"documentation": ""
			},
			{
				"signature": "public void testCancelAsyncRequest() throws Exception",
				"documentation": ""
			},
			{
				"signature": "public void onSuccess(Response response)",
				"documentation": ""
			},
			{
				"signature": "public void onFailure(Exception exception)",
				"documentation": ""
			},
			{
				"signature": "public void testRequestResetAndAbort() throws Exception",
				"documentation": "/**\n     * This test verifies some assumptions that we rely upon around the way the async http client works when reusing the same request\n     * throughout multiple retries, and the use of the {@link HttpRequestBase#abort()} method.\n     * In fact the low-level REST client reuses the same request instance throughout multiple retries, and relies on the http client\n     * to set the future ref to the request properly so that when abort is called, the proper future gets cancelled.\n     */"
			},
			{
				"signature": "public void testHeaders() throws Exception",
				"documentation": "/**\n     * End to end test for headers. We test it explicitly against a real http client as there are different ways\n     * to set/add headers to the {@link org.apache.http.client.HttpClient}.\n     * Exercises the test http server ability to send back whatever headers it received.\n     */"
			},
			{
				"signature": "public void testClientVersion()",
				"documentation": "/** Test that we read the version from the version.properties resource */"
			},
			{
				"signature": "public void testAgentAndMetaHeader() throws Exception",
				"documentation": ""
			},
			{
				"signature": "public void testDeleteWithBody() throws Exception",
				"documentation": "/**\n     * End to end test for delete with body. We test it explicitly as it is not supported\n     * out of the box by {@link org.apache.http.client.HttpClient}.\n     * Exercises the test http server ability to send back whatever body it received.\n     */"
			},
			{
				"signature": "public void testGetWithBody() throws Exception",
				"documentation": "/**\n     * End to end test for get with body. We test it explicitly as it is not supported\n     * out of the box by {@link org.apache.http.client.HttpClient}.\n     * Exercises the test http server ability to send back whatever body it received.\n     */"
			},
			{
				"signature": "public void testEncodeParams() throws Exception",
				"documentation": ""
			},
			{
				"signature": "public void testPreemptiveAuthEnabled() throws Exception",
				"documentation": "/**\n     * Verify that credentials are sent on the first request with preemptive auth enabled (default when provided with credentials).\n     */"
			},
			{
				"signature": "public void testPreemptiveAuthDisabled() throws Exception",
				"documentation": "/**\n     * Verify that credentials are \u003cem\u003enot\u003c/em\u003e sent on the first request with preemptive auth disabled.\n     */"
			},
			{
				"signature": "public void testAuthCredentialsAreNotClearedOnAuthChallenge() throws Exception",
				"documentation": "/**\n     * Verify that credentials continue to be sent even if a 401 (Unauthorized) response is received\n     */"
			},
			{
				"signature": "public void testUrlWithoutLeadingSlash() throws Exception",
				"documentation": ""
			},
			{
				"signature": "private Response bodyTest(final String method) throws Exception",
				"documentation": ""
			},
			{
				"signature": "private Response bodyTest(final RestClient client, final String method) throws Exception",
				"documentation": ""
			},
			{
				"signature": "private Response bodyTest(RestClient client, String method, int statusCode, Header[] headers) throws Exception",
				"documentation": ""
			}
		],
		"interfaces": []
	},
	{
		"documentation": "",
		"name": "org.elasticsearch.client.RestClientSingleHostIntegTests.WaitForCancelHandler",
		"extends": "",
		"Methods": [
			{
				"signature": "void cancelDone()",
				"documentation": ""
			},
			{
				"signature": "public void handle(HttpExchange exchange) throws IOException",
				"documentation": ""
			}
		],
		"interfaces": [
			"com.sun.net.httpserver.HttpHandler"
		]
	},
	{
		"documentation": "",
		"name": "org.elasticsearch.client.RestClientSingleHostIntegTests.ResponseHandler",
		"extends": "",
		"Methods": [
			{
				"signature": "ResponseHandler(int statusCode)",
				"documentation": ""
			},
			{
				"signature": "public void handle(HttpExchange httpExchange) throws IOException",
				"documentation": ""
			}
		],
		"interfaces": [
			"com.sun.net.httpserver.HttpHandler"
		]
	},
	{
		"documentation": "/**\n * Tests for basic functionality of {@link RestClient} against one single host: tests http requests being sent, headers,\n * body, different status codes and corresponding responses/exceptions.\n * Relies on a mock http client to intercept requests and return desired responses based on request path.\n */",
		"name": "org.elasticsearch.client.RestClientSingleHostTests",
		"extends": "RestClientTestCase",
		"Methods": [
			{
				"signature": "public void createRestClient()",
				"documentation": "/**\n * Tests for basic functionality of {@link RestClient} against one single host: tests http requests being sent, headers,\n * body, different status codes and corresponding responses/exceptions.\n * Relies on a mock http client to intercept requests and return desired responses based on request path.\n */"
			},
			{
				"signature": "static CloseableHttpAsyncClient mockHttpClient(final ExecutorService exec)",
				"documentation": ""
			},
			{
				"signature": "private static HttpResponse responseOrException(HttpAsyncRequestProducer requestProducer) throws Exception",
				"documentation": ""
			},
			{
				"signature": "public void shutdownExec()",
				"documentation": "/**\n     * Shutdown the executor so we don't leak threads into other test runs.\n     */"
			},
			{
				"signature": "public void testInternalHttpRequest() throws Exception",
				"documentation": "/**\n     * Verifies the content of the {@link HttpRequest} that's internally created and passed through to the http client\n     */"
			},
			{
				"signature": "public void testOkStatusCodes() throws Exception",
				"documentation": "/**\n     * End to end test for ok status codes\n     */"
			},
			{
				"signature": "public void testErrorStatusCodes() throws Exception",
				"documentation": "/**\n     * End to end test for error status codes: they should cause an exception to be thrown, apart from 404 with HEAD requests\n     */"
			},
			{
				"signature": "public void testPerformRequestIOExceptions() throws Exception",
				"documentation": ""
			},
			{
				"signature": "public void testPerformRequestRuntimeExceptions() throws Exception",
				"documentation": ""
			},
			{
				"signature": "public void testPerformRequestExceptions() throws Exception",
				"documentation": ""
			},
			{
				"signature": "public void testBody() throws Exception",
				"documentation": "/**\n     * End to end test for request and response body. Exercises the mock http client ability to send back\n     * whatever body it has received.\n     */"
			},
			{
				"signature": "public void testHeaders() throws Exception",
				"documentation": "/**\n     * End to end test for request and response headers. Exercises the mock http client ability to send back\n     * whatever headers it has received.\n     */"
			},
			{
				"signature": "public void testDeprecationWarnings() throws Exception",
				"documentation": ""
			},
			{
				"signature": "private void assertDeprecationWarnings(List\u003cString\u003e warningHeaderTexts, List\u003cString\u003e warningBodyTexts) throws Exception",
				"documentation": ""
			},
			{
				"signature": "private static String formatWarningWithoutDate(String warningBody)",
				"documentation": "/**\n     * Emulates Elasticsearch's HeaderWarningLogger.formatWarning in simple\n     * cases. We don't have that available because we're testing against 1.7.\n     */"
			},
			{
				"signature": "private static String formatWarning(String warningBody)",
				"documentation": ""
			},
			{
				"signature": "private HttpUriRequest performRandomRequest(String method) throws Exception",
				"documentation": ""
			},
			{
				"signature": "static Response performRequestSyncOrAsync(RestClient restClient, Request request) throws Exception",
				"documentation": ""
			},
			{
				"signature": "public void onSuccess(Response response)",
				"documentation": ""
			},
			{
				"signature": "public void onFailure(Exception exception)",
				"documentation": ""
			},
			{
				"signature": "private static void assertExceptionStackContainsCallingMethod(Throwable t)",
				"documentation": "/**\n     * Asserts that the provided {@linkplain Exception} contains the method\n     * that called this \u003cstrong\u003esomewhere\u003c/strong\u003e on its stack. This is\n     * normally the case for synchronous calls but {@link RestClient} performs\n     * synchronous calls by performing asynchronous calls and blocking the\n     * current thread until the call returns so it has to take special care\n     * to make sure that the caller shows up in the exception. We use this\n     * assertion to make sure that we don't break that \"special care\".\n     */"
			}
		],
		"interfaces": []
	},
	{
		"documentation": "",
		"name": "org.elasticsearch.client.private",
		"extends": "",
		"Methods": [
			{
				"signature": "PERMISSIVE",
				"documentation": ""
			},
			{
				"signature": "protected WarningsHandler warningsHandler()",
				"documentation": ""
			},
			{
				"signature": ",        STRICT",
				"documentation": ""
			},
			{
				"signature": "protected WarningsHandler warningsHandler()",
				"documentation": ""
			},
			{
				"signature": ",        FILTERED",
				"documentation": ""
			},
			{
				"signature": "protected WarningsHandler warningsHandler()",
				"documentation": ""
			},
			{
				"signature": "public boolean warningsShouldFailRequest(List\u003cString\u003e warnings)",
				"documentation": ""
			},
			{
				"signature": ",        EXACT",
				"documentation": ""
			},
			{
				"signature": "protected WarningsHandler warningsHandler()",
				"documentation": ""
			},
			{
				"signature": "public boolean warningsShouldFailRequest(List\u003cString\u003e warnings)",
				"documentation": ""
			}
		],
		"interfaces": []
	},
	{
		"documentation": "",
		"name": "org.elasticsearch.client.RestClientTests",
		"extends": "RestClientTestCase",
		"Methods": [
			{
				"signature": "public void testCloseIsIdempotent() throws IOException",
				"documentation": ""
			},
			{
				"signature": "public void testPerformAsyncWithUnsupportedMethod() throws Exception",
				"documentation": ""
			},
			{
				"signature": "public void onSuccess(Response response)",
				"documentation": ""
			},
			{
				"signature": "public void onFailure(Exception exception)",
				"documentation": ""
			},
			{
				"signature": "public void testPerformAsyncWithWrongEndpoint() throws Exception",
				"documentation": ""
			},
			{
				"signature": "public void onSuccess(Response response)",
				"documentation": ""
			},
			{
				"signature": "public void onFailure(Exception exception)",
				"documentation": ""
			},
			{
				"signature": "public void testBuildUriLeavesPathUntouched()",
				"documentation": ""
			},
			{
				"signature": "public void testSetNodesWrongArguments() throws IOException",
				"documentation": ""
			},
			{
				"signature": "public void testSetNodesPreservesOrdering() throws Exception",
				"documentation": ""
			},
			{
				"signature": "private static List\u003cNode\u003e randomNodes()",
				"documentation": ""
			},
			{
				"signature": "public void testSetNodesDuplicatedHosts() throws Exception",
				"documentation": ""
			},
			{
				"signature": "public void testSelectHosts() throws IOException",
				"documentation": ""
			},
			{
				"signature": "public void select(Iterable\u003cNode\u003e nodes)",
				"documentation": ""
			},
			{
				"signature": "public String toString()",
				"documentation": ""
			},
			{
				"signature": "public void select(Iterable\u003cNode\u003e nodes)",
				"documentation": ""
			},
			{
				"signature": "public String toString()",
				"documentation": ""
			},
			{
				"signature": "private void assertSelectLivingHosts(        List\u003cNode\u003e expectedNodes,        NodeTuple\u003cList\u003cNode\u003e\u003e nodeTuple,        Map\u003cHttpHost, DeadHostState\u003e blacklist,        NodeSelector nodeSelector    ) throws IOException",
				"documentation": ""
			},
			{
				"signature": "private static String assertSelectAllRejected(        NodeTuple\u003cList\u003cNode\u003e\u003e nodeTuple,        Map\u003cHttpHost, DeadHostState\u003e blacklist,        NodeSelector nodeSelector    )",
				"documentation": "/**\n     * Assert that {@link RestClient#selectNodes} fails on the provided arguments.\n     * @return the message in the exception thrown by the failure\n     */"
			},
			{
				"signature": "private static RestClient createRestClient()",
				"documentation": ""
			},
			{
				"signature": "public void testRoundRobin() throws IOException",
				"documentation": ""
			},
			{
				"signature": "public void testIsRunning()",
				"documentation": ""
			},
			{
				"signature": "private static void assertNodes(NodeTuple\u003cList\u003cNode\u003e\u003e nodeTuple, AtomicInteger lastNodeIndex, int runs) throws IOException",
				"documentation": ""
			}
		],
		"interfaces": []
	},
	{
		"documentation": "/**\n * This class is used to generate the Java low-level REST client documentation.\n * You need to wrap your code between two tags like:\n * // tag::example[]\n * // end::example[]\n *\n * Where example is your tag name.\n *\n * Then in the documentation, you can extract what is between tag and end tags with\n * [\"source\",\"java\",subs=\"attributes,callouts,macros\"]\n * --------------------------------------------------\n * include-tagged::{doc-tests}/RestClientDocumentation.java[example]\n * --------------------------------------------------\n *\n * Note that this is not a test class as we are only interested in testing that docs snippets compile. We don't want\n * to send requests to a node and we don't even have the tools to do it.\n */",
		"name": "org.elasticsearch.client.documentation.RestClientDocumentation",
		"extends": "",
		"Methods": [
			{
				"signature": "static",
				"documentation": "/**\n * This class is used to generate the Java low-level REST client documentation.\n * You need to wrap your code between two tags like:\n * // tag::example[]\n * // end::example[]\n *\n * Where example is your tag name.\n *\n * Then in the documentation, you can extract what is between tag and end tags with\n * [\"source\",\"java\",subs=\"attributes,callouts,macros\"]\n * --------------------------------------------------\n * include-tagged::{doc-tests}/RestClientDocumentation.java[example]\n * --------------------------------------------------\n *\n * Note that this is not a test class as we are only interested in testing that docs snippets compile. We don't want\n * to send requests to a node and we don't even have the tools to do it.\n */"
			},
			{
				"signature": "public void usage() throws IOException, InterruptedException",
				"documentation": ""
			},
			{
				"signature": "public void select(Iterable\u003cNode\u003e nodes)",
				"documentation": ""
			},
			{
				"signature": "public void onFailure(Node node)",
				"documentation": ""
			},
			{
				"signature": "public RequestConfig.Builder customizeRequestConfig(                            RequestConfig.Builder requestConfigBuilder)",
				"documentation": ""
			},
			{
				"signature": "public HttpAsyncClientBuilder customizeHttpClient(                            HttpAsyncClientBuilder httpClientBuilder)",
				"documentation": ""
			},
			{
				"signature": "public void onSuccess(Response response)",
				"documentation": ""
			},
			{
				"signature": "public void onFailure(Exception exception)",
				"documentation": ""
			},
			{
				"signature": "public void onSuccess(Response response)",
				"documentation": ""
			},
			{
				"signature": "public void onFailure(Exception exception)",
				"documentation": ""
			},
			{
				"signature": "public void onSuccess(Response response)",
				"documentation": ""
			},
			{
				"signature": "public void onFailure(Exception exception)",
				"documentation": ""
			},
			{
				"signature": "public void commonConfiguration() throws Exception",
				"documentation": ""
			},
			{
				"signature": "public RequestConfig.Builder customizeRequestConfig(                                RequestConfig.Builder requestConfigBuilder)",
				"documentation": ""
			},
			{
				"signature": "public HttpAsyncClientBuilder customizeHttpClient(                            HttpAsyncClientBuilder httpClientBuilder)",
				"documentation": ""
			},
			{
				"signature": "public HttpAsyncClientBuilder customizeHttpClient(                            HttpAsyncClientBuilder httpClientBuilder)",
				"documentation": ""
			},
			{
				"signature": "public HttpAsyncClientBuilder customizeHttpClient(                            HttpAsyncClientBuilder httpClientBuilder)",
				"documentation": ""
			},
			{
				"signature": "public HttpAsyncClientBuilder customizeHttpClient(                            HttpAsyncClientBuilder httpClientBuilder)",
				"documentation": ""
			},
			{
				"signature": "public HttpAsyncClientBuilder customizeHttpClient(                        HttpAsyncClientBuilder httpClientBuilder)",
				"documentation": ""
			},
			{
				"signature": "public HttpAsyncClientBuilder customizeHttpClient(                        HttpAsyncClientBuilder httpClientBuilder)",
				"documentation": ""
			}
		],
		"interfaces": []
	},
	{
		"documentation": "/**\n * A wrapper for the {@link RestHighLevelClient} that provides methods for\n * accessing the Elastic EQL related functions\n * \u003cp\u003e\n * See the \u003ca href=\"https://www.elastic.co/guide/en/elasticsearch/reference/current/eql.html\"\u003e\n * EQL APIs on elastic.co\u003c/a\u003e for more information.\n *\n * @deprecated The High Level Rest Client is deprecated in favor of the\n * \u003ca href=\"https://www.elastic.co/guide/en/elasticsearch/client/java-api-client/current/introduction.html\"\u003e\n * Elasticsearch Java API Client\u003c/a\u003e\n */",
		"name": "org.elasticsearch.client.EqlClient",
		"extends": "",
		"Methods": [
			{
				"signature": "EqlClient(RestHighLevelClient restHighLevelClient)",
				"documentation": "/**\n * A wrapper for the {@link RestHighLevelClient} that provides methods for\n * accessing the Elastic EQL related functions\n * \u003cp\u003e\n * See the \u003ca href=\"https://www.elastic.co/guide/en/elasticsearch/reference/current/eql.html\"\u003e\n * EQL APIs on elastic.co\u003c/a\u003e for more information.\n *\n * @deprecated The High Level Rest Client is deprecated in favor of the\n * \u003ca href=\"https://www.elastic.co/guide/en/elasticsearch/client/java-api-client/current/introduction.html\"\u003e\n * Elasticsearch Java API Client\u003c/a\u003e\n */"
			},
			{
				"signature": "public EqlSearchResponse search(EqlSearchRequest request, RequestOptions options) throws IOException",
				"documentation": "/**\n     * Executes the eql search query.\n     * \u003cp\u003e\n     * See \u003ca href=\"https://www.elastic.co/guide/en/elasticsearch/reference/current/eql-search.html\"\u003e\n     * the docs\u003c/a\u003e for more.\n     *\n     * @param request the request\n     * @param options the request options (e.g. headers), use {@link RequestOptions#DEFAULT} if nothing needs to be customized\n     * @return the response\n     * @throws IOException in case there is a problem sending the request or parsing back the response\n     */"
			},
			{
				"signature": "public Cancellable searchAsync(EqlSearchRequest request, RequestOptions options, ActionListener\u003cEqlSearchResponse\u003e listener)",
				"documentation": "/**\n     * Asynchronously executes the eql search query.\n     * \u003cp\u003e\n     * See \u003ca href=\"https://www.elastic.co/guide/en/elasticsearch/reference/current/eql-search.html\"\u003e\n     * the docs\u003c/a\u003e for more.\n     *\n     * @param request  the request\n     * @param options  the request options (e.g. headers), use {@link RequestOptions#DEFAULT} if nothing needs to be customized\n     * @param listener the listener to be notified upon request completion\n     * @return cancellable that may be used to cancel the request\n     */"
			},
			{
				"signature": "public EqlStatsResponse stats(EqlStatsRequest request, RequestOptions options) throws IOException",
				"documentation": "/**\n     * Get the eql stats\n     * See \u003ca href=\"https://www.elastic.co/guide/en/elasticsearch/reference/current/eql-stats.html\"\u003e\n     * the docs\u003c/a\u003e for more.\n     * @param request the request\n     * @param options the request options (e.g. headers), use {@link RequestOptions#DEFAULT} if nothing needs to be customized\n     * @return the response\n     * @throws IOException in case there is a problem sending the request or parsing back the response\n     */"
			},
			{
				"signature": "public Cancellable statsAsync(EqlStatsRequest request, RequestOptions options, ActionListener\u003cEqlStatsResponse\u003e listener)",
				"documentation": "/**\n     * Asynchronously get the eql stats\n     * See \u003ca href=\"https://www.elastic.co/guide/en/elasticsearch/reference/current/eql-stats.html\"\u003e\n     * the docs\u003c/a\u003e for more.\n     * @param request the request\n     * @param options the request options (e.g. headers), use {@link RequestOptions#DEFAULT} if nothing needs to be customized\n     * @param listener the listener to be notified upon request completion\n     * @return cancellable that may be used to cancel the request\n     */"
			}
		],
		"interfaces": []
	},
	{
		"documentation": "",
		"name": "org.elasticsearch.client.EqlRequestConverters",
		"extends": "",
		"Methods": [
			{
				"signature": "static Request search(EqlSearchRequest eqlSearchRequest) throws IOException",
				"documentation": ""
			},
			{
				"signature": "static Request stats(EqlStatsRequest eqlStatsRequest) throws IOException",
				"documentation": ""
			}
		],
		"interfaces": []
	},
	{
		"documentation": "/**\n * Response obtained from the get aliases API.\n * The format is pretty horrible as it holds aliases, but at the same time errors can come back through the status and error fields.\n * Such errors are mostly 404 - NOT FOUND for aliases that were specified but not found. In such case the client won't throw exception\n * so it allows to retrieve the returned aliases, while at the same time checking if errors were returned.\n * There's also the case where an exception is returned, like for instance an {@link org.elasticsearch.index.IndexNotFoundException}.\n * We would usually throw such exception, but we configure the client to not throw for 404 to support the case above, hence we also not\n * throw in case an index is not found, although it is a hard error that doesn't come back with aliases.\n */",
		"name": "org.elasticsearch.client.GetAliasesResponse",
		"extends": "",
		"Methods": [
			{
				"signature": "GetAliasesResponse(RestStatus status, String error, Map\u003cString, Set\u003cAliasMetadata\u003e\u003e aliases)",
				"documentation": "/**\n * Response obtained from the get aliases API.\n * The format is pretty horrible as it holds aliases, but at the same time errors can come back through the status and error fields.\n * Such errors are mostly 404 - NOT FOUND for aliases that were specified but not found. In such case the client won't throw exception\n * so it allows to retrieve the returned aliases, while at the same time checking if errors were returned.\n * There's also the case where an exception is returned, like for instance an {@link org.elasticsearch.index.IndexNotFoundException}.\n * We would usually throw such exception, but we configure the client to not throw for 404 to support the case above, hence we also not\n * throw in case an index is not found, although it is a hard error that doesn't come back with aliases.\n */"
			},
			{
				"signature": "private GetAliasesResponse(RestStatus status, ElasticsearchException exception)",
				"documentation": ""
			},
			{
				"signature": "public RestStatus status()",
				"documentation": ""
			},
			{
				"signature": "public String getError()",
				"documentation": "/**\n     * Return the possibly returned error, null otherwise\n     */"
			},
			{
				"signature": "public ElasticsearchException getException()",
				"documentation": "/**\n     * Return the exception that may have been returned\n     */"
			},
			{
				"signature": "public Map\u003cString, Set\u003cAliasMetadata\u003e\u003e getAliases()",
				"documentation": "/**\n     * Return the requested aliases\n     */"
			},
			{
				"signature": "public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException",
				"documentation": ""
			},
			{
				"signature": "public static GetAliasesResponse fromXContent(XContentParser parser) throws IOException",
				"documentation": "/**\n     * Parse the get aliases response\n     */"
			},
			{
				"signature": "private static Set\u003cAliasMetadata\u003e parseAliases(XContentParser parser) throws IOException",
				"documentation": ""
			}
		],
		"interfaces": [
			"org.elasticsearch.common.xcontent.StatusToXContentObject"
		]
	},
	{
		"documentation": "",
		"name": "org.elasticsearch.client.IndexLifecycleRequestConverters",
		"extends": "",
		"Methods": [
			{
				"signature": "private IndexLifecycleRequestConverters()",
				"documentation": ""
			},
			{
				"signature": "static Request getLifecyclePolicy(GetLifecyclePolicyRequest getLifecyclePolicyRequest)",
				"documentation": ""
			},
			{
				"signature": "static Request putLifecyclePolicy(PutLifecyclePolicyRequest putLifecycleRequest) throws IOException",
				"documentation": ""
			},
			{
				"signature": "static Request deleteLifecyclePolicy(DeleteLifecyclePolicyRequest deleteLifecyclePolicyRequest)",
				"documentation": ""
			},
			{
				"signature": "static Request removeIndexLifecyclePolicy(RemoveIndexLifecyclePolicyRequest removePolicyRequest)",
				"documentation": ""
			},
			{
				"signature": "static Request startILM(StartILMRequest startILMRequest)",
				"documentation": ""
			},
			{
				"signature": "static Request stopILM(StopILMRequest stopILMRequest)",
				"documentation": ""
			},
			{
				"signature": "static Request lifecycleManagementStatus(LifecycleManagementStatusRequest lifecycleManagementStatusRequest)",
				"documentation": ""
			},
			{
				"signature": "static Request explainLifecycle(ExplainLifecycleRequest explainLifecycleRequest)",
				"documentation": ""
			},
			{
				"signature": "static Request retryLifecycle(RetryLifecyclePolicyRequest retryLifecyclePolicyRequest)",
				"documentation": ""
			},
			{
				"signature": "static Request getSnapshotLifecyclePolicy(GetSnapshotLifecyclePolicyRequest getSnapshotLifecyclePolicyRequest)",
				"documentation": ""
			},
			{
				"signature": "static Request putSnapshotLifecyclePolicy(PutSnapshotLifecyclePolicyRequest putSnapshotLifecyclePolicyRequest) throws IOException",
				"documentation": ""
			},
			{
				"signature": "static Request deleteSnapshotLifecyclePolicy(DeleteSnapshotLifecyclePolicyRequest deleteSnapshotLifecyclePolicyRequest)",
				"documentation": ""
			},
			{
				"signature": "static Request executeSnapshotLifecyclePolicy(ExecuteSnapshotLifecyclePolicyRequest executeSnapshotLifecyclePolicyRequest)",
				"documentation": ""
			},
			{
				"signature": "static Request executeSnapshotLifecycleRetention(ExecuteSnapshotLifecycleRetentionRequest executeSnapshotLifecycleRetentionRequest)",
				"documentation": ""
			},
			{
				"signature": "static Request getSnapshotLifecycleStats(GetSnapshotLifecycleStatsRequest getSnapshotLifecycleStatsRequest)",
				"documentation": ""
			},
			{
				"signature": "static Request snapshotLifecycleManagementStatus(SnapshotLifecycleManagementStatusRequest snapshotLifecycleManagementStatusRequest)",
				"documentation": ""
			},
			{
				"signature": "static Request startSLM(StartSLMRequest startSLMRequest)",
				"documentation": ""
			},
			{
				"signature": "static Request stopSLM(StopSLMRequest stopSLMRequest)",
				"documentation": ""
			}
		],
		"interfaces": []
	},
	{
		"documentation": "/**\n * A wrapper for the {@link RestHighLevelClient} that provides methods for\n * accessing the Elastic License-related methods\n * \u003cp\u003e\n * See the \u003ca href=\"https://www.elastic.co/guide/en/elasticsearch/reference/current/migration-api.html\"\u003e\n * X-Pack Migration APIs on elastic.co\u003c/a\u003e for more information.\n *\n * @deprecated The High Level Rest Client is deprecated in favor of the\n * \u003ca href=\"https://www.elastic.co/guide/en/elasticsearch/client/java-api-client/current/introduction.html\"\u003e\n * Elasticsearch Java API Client\u003c/a\u003e\n */",
		"name": "org.elasticsearch.client.MigrationClient",
		"extends": "",
		"Methods": [
			{
				"signature": "MigrationClient(RestHighLevelClient restHighLevelClient)",
				"documentation": "/**\n * A wrapper for the {@link RestHighLevelClient} that provides methods for\n * accessing the Elastic License-related methods\n * \u003cp\u003e\n * See the \u003ca href=\"https://www.elastic.co/guide/en/elasticsearch/reference/current/migration-api.html\"\u003e\n * X-Pack Migration APIs on elastic.co\u003c/a\u003e for more information.\n *\n * @deprecated The High Level Rest Client is deprecated in favor of the\n * \u003ca href=\"https://www.elastic.co/guide/en/elasticsearch/client/java-api-client/current/introduction.html\"\u003e\n * Elasticsearch Java API Client\u003c/a\u003e\n */"
			},
			{
				"signature": "public DeprecationInfoResponse getDeprecationInfo(DeprecationInfoRequest request, RequestOptions options) throws IOException",
				"documentation": "/**\n     * Get deprecation info for one or more indices\n     * @param request the request\n     * @param options the request options (e.g. headers), use {@link RequestOptions#DEFAULT} if nothing needs to be customized\n     * @return the response\n     * @throws IOException in case there is a problem sending the request or parsing back the response\n     */"
			},
			{
				"signature": "public Cancellable getDeprecationInfoAsync(        DeprecationInfoRequest request,        RequestOptions options,        ActionListener\u003cDeprecationInfoResponse\u003e listener    )",
				"documentation": "/**\n     * Asynchronously get deprecation info for one or more indices\n     * @param request the request\n     * @param options the request options (e.g. headers), use {@link RequestOptions#DEFAULT} if nothing needs to be customized\n     * @param listener the listener to be notified upon request completion\n     * @return cancellable that may be used to cancel the request\n     */"
			},
			{
				"signature": "public GetFeatureUpgradeStatusResponse getFeatureUpgradeStatus(GetFeatureUpgradeStatusRequest request, RequestOptions options)        throws IOException",
				"documentation": "/**\n     * Get a list of system features that need to be upgraded for the next release\n     * @param request the request\n     * @param options the request options (e.g. headers), use {@link RequestOptions#DEFAULT} if nothing needs to be customized\n     * @return the response\n     * @throws IOException in case there is a problem sending the request or parsing back the response\n     */"
			},
			{
				"signature": "public Cancellable getFeatureUpgradeStatusAsync(        GetFeatureUpgradeStatusRequest request,        RequestOptions options,        ActionListener\u003cGetFeatureUpgradeStatusResponse\u003e listener    )",
				"documentation": "/**\n     * Asynchronously get a list of system features that need to be upgraded for the next release\n     * @param request the request\n     * @param options the request options (e.g. headers), use {@link RequestOptions#DEFAULT} if nothing needs to be customized\n     * @param listener the listener to be notified upon request completion\n     * @return cancellable that may be used to cancel the request\n     */"
			},
			{
				"signature": "public PostFeatureUpgradeResponse postFeatureUpgrade(PostFeatureUpgradeRequest request, RequestOptions options) throws IOException",
				"documentation": "/**\n     * Trigger a system feature upgrade\n     * @param request the request\n     * @param options the request options (e.g. headers), use {@link RequestOptions#DEFAULT} if nothing needs to be customized\n     * @return the response\n     * @throws IOException in case there is a problem sending the request or parsing back the response\n     */"
			},
			{
				"signature": "public Cancellable postFeatureUpgradeAsync(        PostFeatureUpgradeRequest request,        RequestOptions options,        ActionListener\u003cPostFeatureUpgradeResponse\u003e listener    ) throws IOException",
				"documentation": "/**\n     * Asynchronously trigger a system feature upgrade\n     * @param request the request\n     * @param options the request options (e.g. headers), use {@link RequestOptions#DEFAULT} if nothing needs to be customized\n     * @param listener the listener to be notified upon request completion\n     * @return cancellable that may be used to cancel the request\n     */"
			}
		],
		"interfaces": []
	},
	{
		"documentation": "",
		"name": "org.elasticsearch.client.MigrationRequestConverters",
		"extends": "",
		"Methods": [
			{
				"signature": "private MigrationRequestConverters()",
				"documentation": ""
			},
			{
				"signature": "static Request getDeprecationInfo(DeprecationInfoRequest deprecationInfoRequest)",
				"documentation": ""
			},
			{
				"signature": "static Request getFeatureUpgradeStatus(GetFeatureUpgradeStatusRequest getFeatureUpgradeStatusRequest)",
				"documentation": "/**\n     * Convert a {@link GetFeatureUpgradeStatusRequest} to a {@link Request}\n     * @param getFeatureUpgradeStatusRequest a request for feature upgrade status\n     * @return a {@link Request} with the correct path and HTTP request type\n     */"
			},
			{
				"signature": "static Request postFeatureUpgrade(PostFeatureUpgradeRequest postFeatureUpgradeRequest)",
				"documentation": "/**\n     * Convert a {@link PostFeatureUpgradeRequest} to a {@link Request}\n     * @param postFeatureUpgradeRequest a request for feature upgrade status\n     * @return a {@link Request} with the correct path and HTTP request type\n     */"
			}
		],
		"interfaces": []
	},
	{
		"documentation": "/**\n * Base class for responses that are node responses. These responses always contain the cluster\n * name and the {@link NodesResponseHeader}.\n */",
		"name": "org.elasticsearch.client.NodesResponse",
		"extends": "",
		"Methods": [
			{
				"signature": "protected NodesResponse(NodesResponseHeader header, String clusterName)",
				"documentation": "/**\n * Base class for responses that are node responses. These responses always contain the cluster\n * name and the {@link NodesResponseHeader}.\n */"
			},
			{
				"signature": "public String getClusterName()",
				"documentation": "/**\n     * Get the cluster name associated with all of the nodes.\n     *\n     * @return Never {@code null}.\n     */"
			},
			{
				"signature": "public NodesResponseHeader getHeader()",
				"documentation": "/**\n     * Gets information about the number of total, successful and failed nodes the request was run on.\n     * Also includes exceptions if relevant.\n     */"
			},
			{
				"signature": "public static \u003cT extends NodesResponse\u003e void declareCommonNodesResponseParsing(ConstructingObjectParser\u003cT, Void\u003e parser)",
				"documentation": ""
			}
		],
		"interfaces": []
	},
	{
		"documentation": "/**\n * A utility class to parse the Nodes Header returned by\n * {@link RestActions#buildNodesHeader(XContentBuilder, ToXContent.Params, BaseNodesResponse)}.\n */",
		"name": "org.elasticsearch.client.NodesResponseHeader",
		"extends": "",
		"Methods": [
			{
				"signature": "static",
				"documentation": ""
			},
			{
				"signature": "public NodesResponseHeader(int total, int successful, int failed, @Nullable List\u003cElasticsearchException\u003e failures)",
				"documentation": ""
			},
			{
				"signature": "public static NodesResponseHeader fromXContent(XContentParser parser, Void context) throws IOException",
				"documentation": ""
			},
			{
				"signature": "public int getTotal()",
				"documentation": "/** the total number of nodes that the operation was carried on */"
			},
			{
				"signature": "public int getFailed()",
				"documentation": "/** the number of nodes that the operation has failed on */"
			},
			{
				"signature": "public int getSuccessful()",
				"documentation": "/** the number of nodes that the operation was successful on */"
			},
			{
				"signature": "public List\u003cElasticsearchException\u003e getFailures()",
				"documentation": "/**\n     * Get the failed node exceptions.\n     *\n     * @return Never {@code null}. Can be empty.\n     */"
			},
			{
				"signature": "public boolean hasFailures()",
				"documentation": "/**\n     * Determine if there are any node failures in {@link #failures}.\n     *\n     * @return {@code true} if {@link #failures} contains at least 1 exception.\n     */"
			},
			{
				"signature": "public boolean equals(Object o)",
				"documentation": ""
			},
			{
				"signature": "public int hashCode()",
				"documentation": ""
			}
		],
		"interfaces": []
	},
	{
		"documentation": "",
		"name": "org.elasticsearch.client.RequestConverters",
		"extends": "",
		"Methods": [
			{
				"signature": "private RequestConverters()",
				"documentation": ""
			},
			{
				"signature": "static Request delete(DeleteRequest deleteRequest)",
				"documentation": ""
			},
			{
				"signature": "static Request info()",
				"documentation": ""
			},
			{
				"signature": "static Request bulk(BulkRequest bulkRequest) throws IOException",
				"documentation": ""
			},
			{
				"signature": "NamedXContentRegistry.EMPTY,                        DeprecationHandler.THROW_UNSUPPORTED_OPERATION,                        indexSource,                        indexXContentType                    )                )",
				"documentation": ""
			},
			{
				"signature": "static Request exists(GetRequest getRequest)",
				"documentation": ""
			},
			{
				"signature": "static Request get(GetRequest getRequest)",
				"documentation": ""
			},
			{
				"signature": "private static Request getStyleRequest(String method, GetRequest getRequest)",
				"documentation": ""
			},
			{
				"signature": "static Request sourceExists(GetSourceRequest getSourceRequest)",
				"documentation": ""
			},
			{
				"signature": "static Request getSource(GetSourceRequest getSourceRequest)",
				"documentation": ""
			},
			{
				"signature": "private static Request sourceRequest(GetSourceRequest getSourceRequest, String httpMethodName)",
				"documentation": ""
			},
			{
				"signature": "static Request multiGet(MultiGetRequest multiGetRequest) throws IOException",
				"documentation": ""
			},
			{
				"signature": "static Request index(IndexRequest indexRequest)",
				"documentation": ""
			},
			{
				"signature": "static Request ping()",
				"documentation": ""
			},
			{
				"signature": "static Request update(UpdateRequest updateRequest) throws IOException",
				"documentation": ""
			},
			{
				"signature": "static Request search(SearchRequest searchRequest, String searchEndpoint) throws IOException",
				"documentation": "/**\n     * Convert a {@linkplain SearchRequest} into a {@linkplain Request}.\n     * @param searchRequest the request to convert\n     * @param searchEndpoint the name of the search endpoint. {@literal _search}\n     *    for standard searches and {@literal _rollup_search} for rollup\n     *    searches.\n     */"
			},
			{
				"signature": "static void addSearchRequestParams(Params params, SearchRequest searchRequest)",
				"documentation": ""
			},
			{
				"signature": "static Request searchScroll(SearchScrollRequest searchScrollRequest) throws IOException",
				"documentation": ""
			},
			{
				"signature": "static Request clearScroll(ClearScrollRequest clearScrollRequest) throws IOException",
				"documentation": ""
			},
			{
				"signature": "static Request openPointInTime(OpenPointInTimeRequest openRequest)",
				"documentation": ""
			},
			{
				"signature": "static Request closePointInTime(ClosePointInTimeRequest closeRequest) throws IOException",
				"documentation": ""
			},
			{
				"signature": "static Request multiSearch(MultiSearchRequest multiSearchRequest) throws IOException",
				"documentation": ""
			},
			{
				"signature": "static Request searchTemplate(SearchTemplateRequest searchTemplateRequest) throws IOException",
				"documentation": ""
			},
			{
				"signature": "static Request multiSearchTemplate(MultiSearchTemplateRequest multiSearchTemplateRequest) throws IOException",
				"documentation": ""
			},
			{
				"signature": "static Request count(CountRequest countRequest) throws IOException",
				"documentation": ""
			},
			{
				"signature": "static Request explain(ExplainRequest explainRequest) throws IOException",
				"documentation": ""
			},
			{
				"signature": "static Request fieldCaps(FieldCapabilitiesRequest fieldCapabilitiesRequest) throws IOException",
				"documentation": ""
			},
			{
				"signature": "static Request rankEval(RankEvalRequest rankEvalRequest) throws IOException",
				"documentation": ""
			},
			{
				"signature": "static Request reindex(ReindexRequest reindexRequest) throws IOException",
				"documentation": ""
			},
			{
				"signature": "static Request submitReindex(ReindexRequest reindexRequest) throws IOException",
				"documentation": ""
			},
			{
				"signature": "static Request deleteByQuery(DeleteByQueryRequest deleteByQueryRequest) throws IOException",
				"documentation": ""
			},
			{
				"signature": "static Request submitDeleteByQuery(DeleteByQueryRequest deleteByQueryRequest) throws IOException",
				"documentation": ""
			},
			{
				"signature": "static Request updateByQuery(UpdateByQueryRequest updateByQueryRequest) throws IOException",
				"documentation": ""
			},
			{
				"signature": "static Request submitUpdateByQuery(UpdateByQueryRequest updateByQueryRequest) throws IOException",
				"documentation": ""
			},
			{
				"signature": "private static Request prepareReindexRequest(ReindexRequest reindexRequest, boolean waitForCompletion) throws IOException",
				"documentation": ""
			},
			{
				"signature": "private static Request prepareDeleteByQueryRequest(DeleteByQueryRequest deleteByQueryRequest, boolean waitForCompletion)        throws IOException",
				"documentation": ""
			},
			{
				"signature": "static Request prepareUpdateByQueryRequest(UpdateByQueryRequest updateByQueryRequest, boolean waitForCompletion) throws IOException",
				"documentation": ""
			},
			{
				"signature": "static Request rethrottleReindex(RethrottleRequest rethrottleRequest)",
				"documentation": ""
			},
			{
				"signature": "static Request rethrottleUpdateByQuery(RethrottleRequest rethrottleRequest)",
				"documentation": ""
			},
			{
				"signature": "static Request rethrottleDeleteByQuery(RethrottleRequest rethrottleRequest)",
				"documentation": ""
			},
			{
				"signature": "private static Request rethrottle(RethrottleRequest rethrottleRequest, String firstPathPart)",
				"documentation": ""
			},
			{
				"signature": "static Request putScript(PutStoredScriptRequest putStoredScriptRequest) throws IOException",
				"documentation": ""
			},
			{
				"signature": "static Request termVectors(TermVectorsRequest tvrequest) throws IOException",
				"documentation": ""
			},
			{
				"signature": "static Request mtermVectors(MultiTermVectorsRequest mtvrequest) throws IOException",
				"documentation": ""
			},
			{
				"signature": "static Request getScript(GetStoredScriptRequest getStoredScriptRequest)",
				"documentation": ""
			},
			{
				"signature": "static Request deleteScript(DeleteStoredScriptRequest deleteStoredScriptRequest)",
				"documentation": ""
			},
			{
				"signature": "static HttpEntity createEntity(ToXContent toXContent, XContentType xContentType) throws IOException",
				"documentation": ""
			},
			{
				"signature": "static HttpEntity createEntity(ToXContent toXContent, XContentType xContentType, ToXContent.Params toXContentParams)        throws IOException",
				"documentation": ""
			},
			{
				"signature": "static String endpoint(String index, String type, String id)",
				"documentation": ""
			},
			{
				"signature": "static String endpoint(String index, String id)",
				"documentation": ""
			},
			{
				"signature": "static String endpoint(String index, String type, String id, String endpoint)",
				"documentation": ""
			},
			{
				"signature": "static String endpoint(String[] indices)",
				"documentation": ""
			},
			{
				"signature": "static String endpoint(String[] indices, String endpoint)",
				"documentation": ""
			},
			{
				"signature": "static String endpoint(String[] indices, String[] types, String endpoint)",
				"documentation": ""
			},
			{
				"signature": "static String endpoint(String[] indices, String endpoint, String[] suffixes)",
				"documentation": ""
			},
			{
				"signature": "static String endpoint(String[] indices, String endpoint, String type)",
				"documentation": ""
			},
			{
				"signature": "public static ContentType createContentType(final XContentType xContentType)",
				"documentation": "/**\n     * Returns a {@link ContentType} from a given {@link XContentType}.\n     *\n     * @param xContentType the {@link XContentType}\n     * @return the {@link ContentType}\n     */"
			},
			{
				"signature": "static XContentType enforceSameContentType(IndexRequest indexRequest, @Nullable XContentType xContentType)",
				"documentation": "/**\n     * Ensure that the {@link IndexRequest}'s content type is supported by the Bulk API and that it conforms\n     * to the current {@link BulkRequest}'s content type (if it's known at the time of this method get called).\n     *\n     * @return the {@link IndexRequest}'s content type\n     */"
			}
		],
		"interfaces": []
	},
	{
		"documentation": "/**\n     * Utility class to help with common parameter names and patterns. Wraps\n     * a {@link Request} and adds the parameters to it directly.\n     */",
		"name": "org.elasticsearch.client.RequestConverters.Params",
		"extends": "",
		"Methods": [
			{
				"signature": "Params()",
				"documentation": "/**\n     * Utility class to help with common parameter names and patterns. Wraps\n     * a {@link Request} and adds the parameters to it directly.\n     */"
			},
			{
				"signature": "Params putParam(String name, String value)",
				"documentation": ""
			},
			{
				"signature": "Params putParam(String key, TimeValue value)",
				"documentation": ""
			},
			{
				"signature": "Map\u003cString, String\u003e asMap()",
				"documentation": ""
			},
			{
				"signature": "Params withDocAsUpsert(boolean docAsUpsert)",
				"documentation": ""
			},
			{
				"signature": "Params withFetchSourceContext(FetchSourceContext fetchSourceContext)",
				"documentation": ""
			},
			{
				"signature": "Params withFields(String[] fields)",
				"documentation": ""
			},
			{
				"signature": "Params withMasterTimeout(TimeValue masterTimeout)",
				"documentation": ""
			},
			{
				"signature": "Params withPipeline(String pipeline)",
				"documentation": ""
			},
			{
				"signature": "Params withPreference(String preference)",
				"documentation": ""
			},
			{
				"signature": "Params withSearchType(String searchType)",
				"documentation": ""
			},
			{
				"signature": "Params withMaxConcurrentShardRequests(int maxConcurrentShardRequests)",
				"documentation": ""
			},
			{
				"signature": "Params withBatchedReduceSize(int batchedReduceSize)",
				"documentation": ""
			},
			{
				"signature": "Params withRequestCache(boolean requestCache)",
				"documentation": ""
			},
			{
				"signature": "Params withAllowPartialResults(boolean allowPartialSearchResults)",
				"documentation": ""
			},
			{
				"signature": "Params withRealtime(boolean realtime)",
				"documentation": ""
			},
			{
				"signature": "Params withRefresh(boolean refresh)",
				"documentation": ""
			},
			{
				"signature": "Params withRefreshPolicy(WriteRequest.RefreshPolicy refreshPolicy)",
				"documentation": "/**\n         *  @deprecated If creating a new HLRC ReST API call, use {@link RefreshPolicy}\n         *  instead of {@link WriteRequest.RefreshPolicy} from the server project\n         */"
			},
			{
				"signature": "Params withRefreshPolicy(RefreshPolicy refreshPolicy)",
				"documentation": ""
			},
			{
				"signature": "Params withRequestsPerSecond(float requestsPerSecond)",
				"documentation": ""
			},
			{
				"signature": "Params withRetryOnConflict(int retryOnConflict)",
				"documentation": ""
			},
			{
				"signature": "Params withRouting(String routing)",
				"documentation": ""
			},
			{
				"signature": "Params withSlices(int slices)",
				"documentation": ""
			},
			{
				"signature": "Params withStoredFields(String[] storedFields)",
				"documentation": ""
			},
			{
				"signature": "Params withTerminateAfter(int terminateAfter)",
				"documentation": ""
			},
			{
				"signature": "Params withTimeout(TimeValue timeout)",
				"documentation": ""
			},
			{
				"signature": "Params withVersion(long version)",
				"documentation": ""
			},
			{
				"signature": "Params withVersionType(VersionType versionType)",
				"documentation": ""
			},
			{
				"signature": "Params withIfSeqNo(long ifSeqNo)",
				"documentation": ""
			},
			{
				"signature": "Params withIfPrimaryTerm(long ifPrimaryTerm)",
				"documentation": ""
			},
			{
				"signature": "Params withWaitForActiveShards(ActiveShardCount activeShardCount)",
				"documentation": ""
			},
			{
				"signature": "Params withWaitForActiveShards(ActiveShardCount activeShardCount, ActiveShardCount defaultActiveShardCount)",
				"documentation": ""
			},
			{
				"signature": "Params withRequireAlias(boolean requireAlias)",
				"documentation": ""
			},
			{
				"signature": "Params withIndicesOptions(IndicesOptions indicesOptions)",
				"documentation": ""
			},
			{
				"signature": "Params withIgnoreUnavailable(boolean ignoreUnavailable)",
				"documentation": ""
			},
			{
				"signature": "Params withHuman(boolean human)",
				"documentation": ""
			},
			{
				"signature": "Params withLocal(boolean local)",
				"documentation": ""
			},
			{
				"signature": "Params withIncludeDefaults(boolean includeDefaults)",
				"documentation": ""
			},
			{
				"signature": "Params withPreserveExisting(boolean preserveExisting)",
				"documentation": ""
			},
			{
				"signature": "Params withDetailed(boolean detailed)",
				"documentation": ""
			},
			{
				"signature": "Params withWaitForCompletion(Boolean waitForCompletion)",
				"documentation": ""
			},
			{
				"signature": "Params withNodes(String[] nodes)",
				"documentation": ""
			},
			{
				"signature": "Params withNodes(List\u003cString\u003e nodes)",
				"documentation": ""
			},
			{
				"signature": "Params withActions(String[] actions)",
				"documentation": ""
			},
			{
				"signature": "Params withActions(List\u003cString\u003e actions)",
				"documentation": ""
			},
			{
				"signature": "Params withTaskId(org.elasticsearch.tasks.TaskId taskId)",
				"documentation": ""
			},
			{
				"signature": "Params withParentTaskId(org.elasticsearch.tasks.TaskId parentTaskId)",
				"documentation": ""
			},
			{
				"signature": "Params withTaskId(TaskId taskId)",
				"documentation": ""
			},
			{
				"signature": "Params withParentTaskId(TaskId parentTaskId)",
				"documentation": ""
			},
			{
				"signature": "Params withWaitForStatus(ClusterHealthStatus status)",
				"documentation": ""
			},
			{
				"signature": "Params withWaitForNoRelocatingShards(boolean waitNoRelocatingShards)",
				"documentation": ""
			},
			{
				"signature": "Params withWaitForNoInitializingShards(boolean waitNoInitShards)",
				"documentation": ""
			},
			{
				"signature": "Params withWaitForNodes(String waitForNodes)",
				"documentation": ""
			},
			{
				"signature": "Params withLevel(ClusterHealthRequest.Level level)",
				"documentation": ""
			},
			{
				"signature": "Params withWaitForEvents(Priority waitForEvents)",
				"documentation": ""
			}
		],
		"interfaces": []
	},
	{
		"documentation": "/**\n     * Utility class to build request's endpoint given its parts as strings\n     */",
		"name": "org.elasticsearch.client.RequestConverters.EndpointBuilder",
		"extends": "",
		"Methods": [
			{
				"signature": "EndpointBuilder addPathPart(String... parts)",
				"documentation": "/**\n     * Utility class to build request's endpoint given its parts as strings\n     */"
			},
			{
				"signature": "EndpointBuilder addCommaSeparatedPathParts(String[] parts)",
				"documentation": ""
			},
			{
				"signature": "EndpointBuilder addCommaSeparatedPathParts(List\u003cString\u003e parts)",
				"documentation": ""
			},
			{
				"signature": "EndpointBuilder addPathPartAsIs(String... parts)",
				"documentation": ""
			},
			{
				"signature": "String build()",
				"documentation": ""
			},
			{
				"signature": "private static String encodePart(String pathPart)",
				"documentation": ""
			}
		],
		"interfaces": []
	},
	{
		"documentation": "/**\n * High level REST client that wraps an instance of the low level {@link RestClient} and allows to build requests and read responses. The\n * {@link RestClient} instance is internally built based on the provided {@link RestClientBuilder} and it gets closed automatically when\n * closing the {@link RestHighLevelClient} instance that wraps it.\n * \u003cp\u003e\n *\n * In case an already existing instance of a low-level REST client needs to be provided, this class can be subclassed and the\n * {@link #RestHighLevelClient(RestClient, CheckedConsumer, List)} constructor can be used.\n * \u003cp\u003e\n *\n * This class can also be sub-classed to expose additional client methods that make use of endpoints added to Elasticsearch through plugins,\n * or to add support for custom response sections, again added to Elasticsearch through plugins.\n * \u003cp\u003e\n *\n * The majority of the methods in this class come in two flavors, a blocking and an asynchronous version (e.g.\n * {@link #search(SearchRequest, RequestOptions)} and {@link #searchAsync(SearchRequest, RequestOptions, ActionListener)}, where the later\n * takes an implementation of an {@link ActionListener} as an argument that needs to implement methods that handle successful responses and\n * failure scenarios. Most of the blocking calls can throw an {@link IOException} or an unchecked {@link ElasticsearchException} in the\n * following cases:\n *\n * \u003cul\u003e\n * \u003cli\u003ean {@link IOException} is usually thrown in case of failing to parse the REST response in the high-level REST client, the request\n * times out or similar cases where there is no response coming back from the Elasticsearch server\u003c/li\u003e\n * \u003cli\u003ean {@link ElasticsearchException} is usually thrown in case where the server returns a 4xx or 5xx error code. The high-level client\n * then tries to parse the response body error details into a generic ElasticsearchException and suppresses the original\n * {@link ResponseException}\u003c/li\u003e\n * \u003c/ul\u003e\n *\n * @deprecated The High Level Rest Client is deprecated in favor of the\n * \u003ca href=\"https://www.elastic.co/guide/en/elasticsearch/client/java-api-client/current/introduction.html\"\u003e\n * Elasticsearch Java API Client\u003c/a\u003e\n */",
		"name": "org.elasticsearch.client.RestHighLevelClient",
		"extends": "",
		"Methods": [
			{
				"signature": "public RestHighLevelClient(RestClientBuilder restClientBuilder)",
				"documentation": "/**\n     * Creates a {@link RestHighLevelClient} given the low level {@link RestClientBuilder} that allows to build the\n     * {@link RestClient} to be used to perform requests.\n     */"
			},
			{
				"signature": "protected RestHighLevelClient(RestClientBuilder restClientBuilder, List\u003cNamedXContentRegistry.Entry\u003e namedXContentEntries)",
				"documentation": "/**\n     * Creates a {@link RestHighLevelClient} given the low level {@link RestClientBuilder} that allows to build the\n     * {@link RestClient} to be used to perform requests and parsers for custom response sections added to Elasticsearch through plugins.\n     */"
			},
			{
				"signature": "protected RestHighLevelClient(        RestClient restClient,        CheckedConsumer\u003cRestClient, IOException\u003e doClose,        List\u003cNamedXContentRegistry.Entry\u003e namedXContentEntries    )",
				"documentation": "/**\n     * Creates a {@link RestHighLevelClient} given the low level {@link RestClient} that it should use to perform requests and\n     * a list of entries that allow to parse custom response sections added to Elasticsearch through plugins.\n     * This constructor can be called by subclasses in case an externally created low-level REST client needs to be provided.\n     * The consumer argument allows to control what needs to be done when the {@link #close()} method is called.\n     * Also subclasses can provide parsers for custom response sections added to Elasticsearch through plugins.\n     */"
			},
			{
				"signature": "protected RestHighLevelClient(        RestClient restClient,        CheckedConsumer\u003cRestClient, IOException\u003e doClose,        List\u003cNamedXContentRegistry.Entry\u003e namedXContentEntries,        Boolean useAPICompatibility    )",
				"documentation": "/**\n     * Creates a {@link RestHighLevelClient} given the low level {@link RestClient} that it should use to perform requests and\n     * a list of entries that allow to parse custom response sections added to Elasticsearch through plugins.\n     * This constructor can be called by subclasses in case an externally created low-level REST client needs to be provided.\n     * The consumer argument allows to control what needs to be done when the {@link #close()} method is called.\n     * Also subclasses can provide parsers for custom response sections added to Elasticsearch through plugins.\n     */"
			},
			{
				"signature": "public final RestClient getLowLevelClient()",
				"documentation": "/**\n     * Returns the low-level client that the current high-level client instance is using to perform requests\n     */"
			},
			{
				"signature": "public final void close() throws IOException",
				"documentation": ""
			},
			{
				"signature": "public final SnapshotClient snapshot()",
				"documentation": "/**\n     * Provides a {@link SnapshotClient} which can be used to access the Snapshot API.\n     *\n     * See \u003ca href=\"https://www.elastic.co/guide/en/elasticsearch/reference/current/modules-snapshots.html\"\u003eSnapshot API on elastic.co\u003c/a\u003e\n     */"
			},
			{
				"signature": "public SecurityClient security()",
				"documentation": "/**\n     * Provides methods for accessing the Elastic Licensed Security APIs that\n     * are shipped with the Elastic Stack distribution of Elasticsearch. All of\n     * these APIs will 404 if run against the OSS distribution of Elasticsearch.\n     * \u003cp\u003e\n     * See the \u003ca href=\"https://www.elastic.co/guide/en/elasticsearch/reference/current/security-api.html\"\u003e\n     * Security APIs on elastic.co\u003c/a\u003e for more information.\n     *\n     * @return the client wrapper for making Security API calls\n     */"
			},
			{
				"signature": "public TransformClient transform()",
				"documentation": "/**\n     * Provides methods for accessing the Elastic Licensed Data Frame APIs that\n     * are shipped with the Elastic Stack distribution of Elasticsearch. All of\n     * these APIs will 404 if run against the OSS distribution of Elasticsearch.\n     * \u003cp\u003e\n     * See the \u003ca href=\"https://www.elastic.co/guide/en/elasticsearch/reference/current/transform-apis.html\"\u003e\n     *     Transform APIs on elastic.co\u003c/a\u003e for more information.\n     *\n     * @return the client wrapper for making Data Frame API calls\n     */"
			},
			{
				"signature": "public final EqlClient eql()",
				"documentation": "/**\n     * Provides methods for accessing the Elastic EQL APIs that\n     * are shipped with the Elastic Stack distribution of Elasticsearch. All of\n     * these APIs will 404 if run against the OSS distribution of Elasticsearch.\n     * \u003cp\u003e\n     * See the \u003ca href=\"https://www.elastic.co/guide/en/elasticsearch/reference/current/eql.html\"\u003e\n     *     EQL APIs on elastic.co\u003c/a\u003e for more information.\n     *\n     * @return the client wrapper for making Data Frame API calls\n     */"
			},
			{
				"signature": "public final BulkResponse bulk(BulkRequest bulkRequest, RequestOptions options) throws IOException",
				"documentation": "/**\n     * Executes a bulk request using the Bulk API.\n     * See \u003ca href=\"https://www.elastic.co/guide/en/elasticsearch/reference/current/docs-bulk.html\"\u003eBulk API on elastic.co\u003c/a\u003e\n     * @param bulkRequest the request\n     * @param options the request options (e.g. headers), use {@link RequestOptions#DEFAULT} if nothing needs to be customized\n     * @return the response\n     */"
			},
			{
				"signature": "public final Cancellable bulkAsync(BulkRequest bulkRequest, RequestOptions options, ActionListener\u003cBulkResponse\u003e listener)",
				"documentation": "/**\n     * Asynchronously executes a bulk request using the Bulk API.\n     * See \u003ca href=\"https://www.elastic.co/guide/en/elasticsearch/reference/current/docs-bulk.html\"\u003eBulk API on elastic.co\u003c/a\u003e\n     * @param bulkRequest the request\n     * @param options the request options (e.g. headers), use {@link RequestOptions#DEFAULT} if nothing needs to be customized\n     * @param listener the listener to be notified upon request completion\n     * @return cancellable that may be used to cancel the request\n     */"
			},
			{
				"signature": "public final BulkByScrollResponse reindex(ReindexRequest reindexRequest, RequestOptions options) throws IOException",
				"documentation": "/**\n     * Executes a reindex request.\n     * See \u003ca href=\"https://www.elastic.co/guide/en/elasticsearch/reference/current/docs-reindex.html\"\u003eReindex API on elastic.co\u003c/a\u003e\n     * @param reindexRequest the request\n     * @param options the request options (e.g. headers), use {@link RequestOptions#DEFAULT} if nothing needs to be customized\n     * @return the response\n     */"
			},
			{
				"signature": "public final TaskSubmissionResponse submitReindexTask(ReindexRequest reindexRequest, RequestOptions options) throws IOException",
				"documentation": "/**\n     * Submits a reindex task.\n     * See \u003ca href=\"https://www.elastic.co/guide/en/elasticsearch/reference/current/docs-reindex.html\"\u003eReindex API on elastic.co\u003c/a\u003e\n     * @param reindexRequest the request\n     * @param options the request options (e.g. headers), use {@link RequestOptions#DEFAULT} if nothing needs to be customized\n     * @return the submission response\n     */"
			},
			{
				"signature": "public final Cancellable reindexAsync(        ReindexRequest reindexRequest,        RequestOptions options,        ActionListener\u003cBulkByScrollResponse\u003e listener    )",
				"documentation": "/**\n     * Asynchronously executes a reindex request.\n     * See \u003ca href=\"https://www.elastic.co/guide/en/elasticsearch/reference/current/docs-reindex.html\"\u003eReindex API on elastic.co\u003c/a\u003e\n     * @param reindexRequest the request\n     * @param options the request options (e.g. headers), use {@link RequestOptions#DEFAULT} if nothing needs to be customized\n     * @param listener the listener to be notified upon request completion\n     * @return cancellable that may be used to cancel the request\n     */"
			},
			{
				"signature": "public final BulkByScrollResponse updateByQuery(UpdateByQueryRequest updateByQueryRequest, RequestOptions options) throws IOException",
				"documentation": "/**\n     * Executes a update by query request.\n     * See \u003ca href=\"https://www.elastic.co/guide/en/elasticsearch/reference/current/docs-update-by-query.html\"\u003e\n     *     Update By Query API on elastic.co\u003c/a\u003e\n     * @param updateByQueryRequest the request\n     * @param options the request options (e.g. headers), use {@link RequestOptions#DEFAULT} if nothing needs to be customized\n     * @return the response\n     */"
			},
			{
				"signature": "public final TaskSubmissionResponse submitUpdateByQueryTask(UpdateByQueryRequest updateByQueryRequest, RequestOptions options)        throws IOException",
				"documentation": "/**\n     * Submits a update by query task.\n     * See \u003ca href=\"https://www.elastic.co/guide/en/elasticsearch/reference/current/docs-update-by-query.html\"\u003e\n     *     Update By Query API on elastic.co\u003c/a\u003e\n     * @param updateByQueryRequest the request\n     * @param options the request options (e.g. headers), use {@link RequestOptions#DEFAULT} if nothing needs to be customized\n     * @return the submission response\n     */"
			},
			{
				"signature": "public final Cancellable updateByQueryAsync(        UpdateByQueryRequest updateByQueryRequest,        RequestOptions options,        ActionListener\u003cBulkByScrollResponse\u003e listener    )",
				"documentation": "/**\n     * Asynchronously executes an update by query request.\n     * See \u003ca href=\"https://www.elastic.co/guide/en/elasticsearch/reference/current/docs-update-by-query.html\"\u003e\n     *     Update By Query API on elastic.co\u003c/a\u003e\n     * @param updateByQueryRequest the request\n     * @param options the request options (e.g. headers), use {@link RequestOptions#DEFAULT} if nothing needs to be customized\n     * @param listener the listener to be notified upon request completion\n     * @return cancellable that may be used to cancel the request\n     */"
			},
			{
				"signature": "public final BulkByScrollResponse deleteByQuery(DeleteByQueryRequest deleteByQueryRequest, RequestOptions options) throws IOException",
				"documentation": "/**\n     * Executes a delete by query request.\n     * See \u003ca href=\"https://www.elastic.co/guide/en/elasticsearch/reference/current/docs-delete-by-query.html\"\u003e\n     *     Delete By Query API on elastic.co\u003c/a\u003e\n     * @param deleteByQueryRequest the request\n     * @param options the request options (e.g. headers), use {@link RequestOptions#DEFAULT} if nothing needs to be customized\n     * @return the response\n     */"
			},
			{
				"signature": "public final TaskSubmissionResponse submitDeleteByQueryTask(DeleteByQueryRequest deleteByQueryRequest, RequestOptions options)        throws IOException",
				"documentation": "/**\n     * Submits a delete by query task\n     * See \u003ca href=\"https://www.elastic.co/guide/en/elasticsearch/reference/current/docs-delete-by-query.html\"\u003e\n     *      Delete By Query API on elastic.co\u003c/a\u003e\n     * @param deleteByQueryRequest the request\n     * @param options the request options (e.g. headers), use {@link RequestOptions#DEFAULT} if nothing needs to be customized\n     * @return the submission response\n     */"
			},
			{
				"signature": "public final Cancellable deleteByQueryAsync(        DeleteByQueryRequest deleteByQueryRequest,        RequestOptions options,        ActionListener\u003cBulkByScrollResponse\u003e listener    )",
				"documentation": "/**\n     * Asynchronously executes a delete by query request.\n     * See \u003ca href=\"https://www.elastic.co/guide/en/elasticsearch/reference/current/docs-delete-by-query.html\"\u003e\n     *     Delete By Query API on elastic.co\u003c/a\u003e\n     * @param deleteByQueryRequest the request\n     * @param options the request options (e.g. headers), use {@link RequestOptions#DEFAULT} if nothing needs to be customized\n     * @param listener the listener to be notified upon request completion\n     * @return cancellable that may be used to cancel the request\n     */"
			},
			{
				"signature": "public final ListTasksResponse deleteByQueryRethrottle(RethrottleRequest rethrottleRequest, RequestOptions options) throws IOException",
				"documentation": "/**\n     * Executes a delete by query rethrottle request.\n     * See \u003ca href=\"https://www.elastic.co/guide/en/elasticsearch/reference/current/docs-delete-by-query.html\"\u003e\n     *     Delete By Query API on elastic.co\u003c/a\u003e\n     * @param rethrottleRequest the request\n     * @param options the request options (e.g. headers), use {@link RequestOptions#DEFAULT} if nothing needs to be customized\n     * @return the response\n     */"
			},
			{
				"signature": "public final Cancellable deleteByQueryRethrottleAsync(        RethrottleRequest rethrottleRequest,        RequestOptions options,        ActionListener\u003cListTasksResponse\u003e listener    )",
				"documentation": "/**\n     * Asynchronously execute an delete by query rethrottle request.\n     * See \u003ca href=\"https://www.elastic.co/guide/en/elasticsearch/reference/current/docs-delete-by-query.html\"\u003e\n     *     Delete By Query API on elastic.co\u003c/a\u003e\n     * @param rethrottleRequest the request\n     * @param options the request options (e.g. headers), use {@link RequestOptions#DEFAULT} if nothing needs to be customized\n     * @param listener the listener to be notified upon request completion\n     * @return cancellable that may be used to cancel the request\n     */"
			},
			{
				"signature": "public final ListTasksResponse updateByQueryRethrottle(RethrottleRequest rethrottleRequest, RequestOptions options) throws IOException",
				"documentation": "/**\n     * Executes a update by query rethrottle request.\n     * See \u003ca href=\"https://www.elastic.co/guide/en/elasticsearch/reference/current/docs-update-by-query.html\"\u003e\n     *     Update By Query API on elastic.co\u003c/a\u003e\n     * @param rethrottleRequest the request\n     * @param options the request options (e.g. headers), use {@link RequestOptions#DEFAULT} if nothing needs to be customized\n     * @return the response\n     */"
			},
			{
				"signature": "public final Cancellable updateByQueryRethrottleAsync(        RethrottleRequest rethrottleRequest,        RequestOptions options,        ActionListener\u003cListTasksResponse\u003e listener    )",
				"documentation": "/**\n     * Asynchronously execute an update by query rethrottle request.\n     * See \u003ca href=\"https://www.elastic.co/guide/en/elasticsearch/reference/current/docs-update-by-query.html\"\u003e\n     *     Update By Query API on elastic.co\u003c/a\u003e\n     * @param rethrottleRequest the request\n     * @param options the request options (e.g. headers), use {@link RequestOptions#DEFAULT} if nothing needs to be customized\n     * @param listener the listener to be notified upon request completion\n     * @return cancellable that may be used to cancel the request\n     */"
			},
			{
				"signature": "public final ListTasksResponse reindexRethrottle(RethrottleRequest rethrottleRequest, RequestOptions options) throws IOException",
				"documentation": "/**\n     * Executes a reindex rethrottling request.\n     * See the \u003ca href=\"https://www.elastic.co/guide/en/elasticsearch/reference/current/docs-reindex.html#docs-reindex-rethrottle\"\u003e\n     * Reindex rethrottling API on elastic.co\u003c/a\u003e\n     *\n     * @param rethrottleRequest the request\n     * @param options           the request options (e.g. headers), use {@link RequestOptions#DEFAULT} if nothing needs to be customized\n     * @return the response\n     */"
			},
			{
				"signature": "public final Cancellable reindexRethrottleAsync(        RethrottleRequest rethrottleRequest,        RequestOptions options,        ActionListener\u003cListTasksResponse\u003e listener    )",
				"documentation": "/**\n     * Executes a reindex rethrottling request.\n     * See the \u003ca href=\"https://www.elastic.co/guide/en/elasticsearch/reference/current/docs-reindex.html#docs-reindex-rethrottle\"\u003e\n     * Reindex rethrottling API on elastic.co\u003c/a\u003e\n     * @param rethrottleRequest the request\n     * @param options           the request options (e.g. headers), use {@link RequestOptions#DEFAULT} if nothing needs to be customized\n     * @param listener          the listener to be notified upon request completion\n     * @return cancellable that may be used to cancel the request\n     */"
			},
			{
				"signature": "public final boolean ping(RequestOptions options) throws IOException",
				"documentation": "/**\n     * Pings the remote Elasticsearch cluster and returns true if the ping succeeded, false otherwise\n     * @param options the request options (e.g. headers), use {@link RequestOptions#DEFAULT} if nothing needs to be customized\n     * @return \u003ccode\u003etrue\u003c/code\u003e if the ping succeeded, false otherwise\n     */"
			},
			{
				"signature": "public final MainResponse info(RequestOptions options) throws IOException",
				"documentation": "/**\n     * Get the cluster info otherwise provided when sending an HTTP request to '/'\n     * @param options the request options (e.g. headers), use {@link RequestOptions#DEFAULT} if nothing needs to be customized\n     * @return the response\n     */"
			},
			{
				"signature": "public final GetResponse get(GetRequest getRequest, RequestOptions options) throws IOException",
				"documentation": "/**\n     * Retrieves a document by id using the Get API.\n     * See \u003ca href=\"https://www.elastic.co/guide/en/elasticsearch/reference/current/docs-get.html\"\u003eGet API on elastic.co\u003c/a\u003e\n     * @param getRequest the request\n     * @param options the request options (e.g. headers), use {@link RequestOptions#DEFAULT} if nothing needs to be customized\n     * @return the response\n     */"
			},
			{
				"signature": "public final Cancellable getAsync(GetRequest getRequest, RequestOptions options, ActionListener\u003cGetResponse\u003e listener)",
				"documentation": "/**\n     * Asynchronously retrieves a document by id using the Get API.\n     * See \u003ca href=\"https://www.elastic.co/guide/en/elasticsearch/reference/current/docs-get.html\"\u003eGet API on elastic.co\u003c/a\u003e\n     * @param getRequest the request\n     * @param options the request options (e.g. headers), use {@link RequestOptions#DEFAULT} if nothing needs to be customized\n     * @param listener the listener to be notified upon request completion\n     * @return cancellable that may be used to cancel the request\n     */"
			},
			{
				"signature": "public final MultiGetResponse multiGet(MultiGetRequest multiGetRequest, RequestOptions options) throws IOException",
				"documentation": "/**\n     * Retrieves multiple documents by id using the Multi Get API.\n     * See \u003ca href=\"https://www.elastic.co/guide/en/elasticsearch/reference/current/docs-multi-get.html\"\u003eMulti Get API on elastic.co\u003c/a\u003e\n     * @param multiGetRequest the request\n     * @param options the request options (e.g. headers), use {@link RequestOptions#DEFAULT} if nothing needs to be customized\n     * @return the response\n     * @deprecated use {@link #mget(MultiGetRequest, RequestOptions)} instead\n     */"
			},
			{
				"signature": "public final MultiGetResponse mget(MultiGetRequest multiGetRequest, RequestOptions options) throws IOException",
				"documentation": "/**\n     * Retrieves multiple documents by id using the Multi Get API.\n     * See \u003ca href=\"https://www.elastic.co/guide/en/elasticsearch/reference/current/docs-multi-get.html\"\u003eMulti Get API on elastic.co\u003c/a\u003e\n     * @param multiGetRequest the request\n     * @param options the request options (e.g. headers), use {@link RequestOptions#DEFAULT} if nothing needs to be customized\n     * @return the response\n     */"
			},
			{
				"signature": "public final Cancellable multiGetAsync(        MultiGetRequest multiGetRequest,        RequestOptions options,        ActionListener\u003cMultiGetResponse\u003e listener    )",
				"documentation": "/**\n     * Asynchronously retrieves multiple documents by id using the Multi Get API.\n     * See \u003ca href=\"https://www.elastic.co/guide/en/elasticsearch/reference/current/docs-multi-get.html\"\u003eMulti Get API on elastic.co\u003c/a\u003e\n     * @param multiGetRequest the request\n     * @param options the request options (e.g. headers), use {@link RequestOptions#DEFAULT} if nothing needs to be customized\n     * @param listener the listener to be notified upon request completion\n     * @deprecated use {@link #mgetAsync(MultiGetRequest, RequestOptions, ActionListener)} instead\n     * @return cancellable that may be used to cancel the request\n     */"
			},
			{
				"signature": "public final Cancellable mgetAsync(MultiGetRequest multiGetRequest, RequestOptions options, ActionListener\u003cMultiGetResponse\u003e listener)",
				"documentation": "/**\n     * Asynchronously retrieves multiple documents by id using the Multi Get API.\n     * See \u003ca href=\"https://www.elastic.co/guide/en/elasticsearch/reference/current/docs-multi-get.html\"\u003eMulti Get API on elastic.co\u003c/a\u003e\n     * @param multiGetRequest the request\n     * @param options the request options (e.g. headers), use {@link RequestOptions#DEFAULT} if nothing needs to be customized\n     * @param listener the listener to be notified upon request completion\n     * @return cancellable that may be used to cancel the request\n     */"
			},
			{
				"signature": "public final boolean exists(GetRequest getRequest, RequestOptions options) throws IOException",
				"documentation": "/**\n     * Checks for the existence of a document. Returns true if it exists, false otherwise.\n     * See \u003ca href=\"https://www.elastic.co/guide/en/elasticsearch/reference/current/docs-get.html\"\u003eGet API on elastic.co\u003c/a\u003e\n     * @param getRequest the request\n     * @param options the request options (e.g. headers), use {@link RequestOptions#DEFAULT} if nothing needs to be customized\n     * @return \u003ccode\u003etrue\u003c/code\u003e if the document exists, \u003ccode\u003efalse\u003c/code\u003e otherwise\n     */"
			},
			{
				"signature": "public final Cancellable existsAsync(GetRequest getRequest, RequestOptions options, ActionListener\u003cBoolean\u003e listener)",
				"documentation": "/**\n     * Asynchronously checks for the existence of a document. Returns true if it exists, false otherwise.\n     * See \u003ca href=\"https://www.elastic.co/guide/en/elasticsearch/reference/current/docs-get.html\"\u003eGet API on elastic.co\u003c/a\u003e\n     * @param getRequest the request\n     * @param options the request options (e.g. headers), use {@link RequestOptions#DEFAULT} if nothing needs to be customized\n     * @param listener the listener to be notified upon request completion\n     * @return cancellable that may be used to cancel the request\n     */"
			},
			{
				"signature": "public boolean existsSource(GetRequest getRequest, RequestOptions options) throws IOException",
				"documentation": "/**\n     * Checks for the existence of a document with a \"_source\" field. Returns true if it exists, false otherwise.\n     * See \u003ca href=\"https://www.elastic.co/guide/en/elasticsearch/reference/current/docs-get.html#_source\"\u003eSource exists API\n     * on elastic.co\u003c/a\u003e\n     * @param getRequest the request\n     * @param options the request options (e.g. headers), use {@link RequestOptions#DEFAULT} if nothing needs to be customized\n     * @return \u003ccode\u003etrue\u003c/code\u003e if the document and _source field exists, \u003ccode\u003efalse\u003c/code\u003e otherwise\n     * @deprecated use {@link #existsSource(GetSourceRequest, RequestOptions)} instead\n     */"
			},
			{
				"signature": "public final Cancellable existsSourceAsync(GetRequest getRequest, RequestOptions options, ActionListener\u003cBoolean\u003e listener)",
				"documentation": "/**\n     * Asynchronously checks for the existence of a document with a \"_source\" field. Returns true if it exists, false otherwise.\n     * See \u003ca href=\"https://www.elastic.co/guide/en/elasticsearch/reference/current/docs-get.html#_source\"\u003eSource exists API\n     * on elastic.co\u003c/a\u003e\n     * @param getRequest the request\n     * @param options the request options (e.g. headers), use {@link RequestOptions#DEFAULT} if nothing needs to be customized\n     * @param listener the listener to be notified upon request completion\n     * @return cancellable that may be used to cancel the request\n     * @deprecated use {@link #existsSourceAsync(GetSourceRequest, RequestOptions, ActionListener)} instead\n     */"
			},
			{
				"signature": "public boolean existsSource(GetSourceRequest getSourceRequest, RequestOptions options) throws IOException",
				"documentation": "/**\n     * Checks for the existence of a document with a \"_source\" field. Returns true if it exists, false otherwise.\n     * See \u003ca href=\"https://www.elastic.co/guide/en/elasticsearch/reference/current/docs-get.html#_source\"\u003eSource exists API\n     * on elastic.co\u003c/a\u003e\n     * @param getSourceRequest the request\n     * @param options the request options (e.g. headers), use {@link RequestOptions#DEFAULT} if nothing needs to be customized\n     * @return \u003ccode\u003etrue\u003c/code\u003e if the document and _source field exists, \u003ccode\u003efalse\u003c/code\u003e otherwise\n     */"
			},
			{
				"signature": "public final Cancellable existsSourceAsync(        GetSourceRequest getSourceRequest,        RequestOptions options,        ActionListener\u003cBoolean\u003e listener    )",
				"documentation": "/**\n     * Asynchronously checks for the existence of a document with a \"_source\" field. Returns true if it exists, false otherwise.\n     * See \u003ca href=\"https://www.elastic.co/guide/en/elasticsearch/reference/current/docs-get.html#_source\"\u003eSource exists API\n     * on elastic.co\u003c/a\u003e\n     * @param getSourceRequest the request\n     * @param options the request options (e.g. headers), use {@link RequestOptions#DEFAULT} if nothing needs to be customized\n     * @param listener the listener to be notified upon request completion\n     * @return cancellable that may be used to cancel the request\n     */"
			},
			{
				"signature": "public GetSourceResponse getSource(GetSourceRequest getSourceRequest, RequestOptions options) throws IOException",
				"documentation": "/**\n     * Retrieves the source field only of a document using GetSource API.\n     * See \u003ca href=\"https://www.elastic.co/guide/en/elasticsearch/reference/current/docs-get.html#_source\"\u003eGet Source API\n     * on elastic.co\u003c/a\u003e\n     * @param getSourceRequest the request\n     * @param options the request options (e.g. headers), use {@link RequestOptions#DEFAULT} if nothing needs to be customized\n     * @return the response\n     */"
			},
			{
				"signature": "public final Cancellable getSourceAsync(        GetSourceRequest getSourceRequest,        RequestOptions options,        ActionListener\u003cGetSourceResponse\u003e listener    )",
				"documentation": "/**\n     * Asynchronously retrieves the source field only of a document using GetSource API.\n     * See \u003ca href=\"https://www.elastic.co/guide/en/elasticsearch/reference/current/docs-get.html#_source\"\u003eGet Source API\n     * on elastic.co\u003c/a\u003e\n     * @param getSourceRequest the request\n     * @param options the request options (e.g. headers), use {@link RequestOptions#DEFAULT} if nothing needs to be customized\n     * @param listener the listener to be notified upon request completion\n     * @return cancellable that may be used to cancel the request\n     */"
			},
			{
				"signature": "public final IndexResponse index(IndexRequest indexRequest, RequestOptions options) throws IOException",
				"documentation": "/**\n     * Index a document using the Index API.\n     * See \u003ca href=\"https://www.elastic.co/guide/en/elasticsearch/reference/current/docs-index_.html\"\u003eIndex API on elastic.co\u003c/a\u003e\n     * @param indexRequest the request\n     * @param options the request options (e.g. headers), use {@link RequestOptions#DEFAULT} if nothing needs to be customized\n     * @return the response\n     */"
			},
			{
				"signature": "public final Cancellable indexAsync(IndexRequest indexRequest, RequestOptions options, ActionListener\u003cIndexResponse\u003e listener)",
				"documentation": "/**\n     * Asynchronously index a document using the Index API.\n     * See \u003ca href=\"https://www.elastic.co/guide/en/elasticsearch/reference/current/docs-index_.html\"\u003eIndex API on elastic.co\u003c/a\u003e\n     * @param indexRequest the request\n     * @param options the request options (e.g. headers), use {@link RequestOptions#DEFAULT} if nothing needs to be customized\n     * @param listener the listener to be notified upon request completion\n     * @return cancellable that may be used to cancel the request\n     */"
			},
			{
				"signature": "public final CountResponse count(CountRequest countRequest, RequestOptions options) throws IOException",
				"documentation": "/**\n     * Executes a count request using the Count API.\n     * See \u003ca href=\"https://www.elastic.co/guide/en/elasticsearch/reference/current/search-count.html\"\u003eCount API on elastic.co\u003c/a\u003e\n     * @param countRequest the request\n     * @param options the request options (e.g. headers), use {@link RequestOptions#DEFAULT} if nothing needs to be customized\n     * @return the response\n     */"
			},
			{
				"signature": "public final Cancellable countAsync(CountRequest countRequest, RequestOptions options, ActionListener\u003cCountResponse\u003e listener)",
				"documentation": "/**\n     * Asynchronously executes a count request using the Count API.\n     * See \u003ca href=\"https://www.elastic.co/guide/en/elasticsearch/reference/current/search-count.html\"\u003eCount API on elastic.co\u003c/a\u003e\n     * @param countRequest the request\n     * @param options the request options (e.g. headers), use {@link RequestOptions#DEFAULT} if nothing needs to be customized\n     * @param listener the listener to be notified upon request completion\n     * @return cancellable that may be used to cancel the request\n     */"
			},
			{
				"signature": "public final UpdateResponse update(UpdateRequest updateRequest, RequestOptions options) throws IOException",
				"documentation": "/**\n     * Updates a document using the Update API.\n     * See \u003ca href=\"https://www.elastic.co/guide/en/elasticsearch/reference/current/docs-update.html\"\u003eUpdate API on elastic.co\u003c/a\u003e\n     * @param updateRequest the request\n     * @param options the request options (e.g. headers), use {@link RequestOptions#DEFAULT} if nothing needs to be customized\n     * @return the response\n     */"
			},
			{
				"signature": "public final Cancellable updateAsync(UpdateRequest updateRequest, RequestOptions options, ActionListener\u003cUpdateResponse\u003e listener)",
				"documentation": "/**\n     * Asynchronously updates a document using the Update API.\n     * See \u003ca href=\"https://www.elastic.co/guide/en/elasticsearch/reference/current/docs-update.html\"\u003eUpdate API on elastic.co\u003c/a\u003e\n     * @param updateRequest the request\n     * @param options the request options (e.g. headers), use {@link RequestOptions#DEFAULT} if nothing needs to be customized\n     * @param listener the listener to be notified upon request completion\n     * @return cancellable that may be used to cancel the request\n     */"
			},
			{
				"signature": "public final DeleteResponse delete(DeleteRequest deleteRequest, RequestOptions options) throws IOException",
				"documentation": "/**\n     * Deletes a document by id using the Delete API.\n     * See \u003ca href=\"https://www.elastic.co/guide/en/elasticsearch/reference/current/docs-delete.html\"\u003eDelete API on elastic.co\u003c/a\u003e\n     * @param deleteRequest the request\n     * @param options the request options (e.g. headers), use {@link RequestOptions#DEFAULT} if nothing needs to be customized\n     * @return the response\n     */"
			},
			{
				"signature": "public final Cancellable deleteAsync(DeleteRequest deleteRequest, RequestOptions options, ActionListener\u003cDeleteResponse\u003e listener)",
				"documentation": "/**\n     * Asynchronously deletes a document by id using the Delete API.\n     * See \u003ca href=\"https://www.elastic.co/guide/en/elasticsearch/reference/current/docs-delete.html\"\u003eDelete API on elastic.co\u003c/a\u003e\n     * @param deleteRequest the request\n     * @param options the request options (e.g. headers), use {@link RequestOptions#DEFAULT} if nothing needs to be customized\n     * @param listener the listener to be notified upon request completion\n     * @return cancellable that may be used to cancel the request\n     */"
			},
			{
				"signature": "public final SearchResponse search(SearchRequest searchRequest, RequestOptions options) throws IOException",
				"documentation": "/**\n     * Executes a search request using the Search API.\n     * See \u003ca href=\"https://www.elastic.co/guide/en/elasticsearch/reference/current/search-search.html\"\u003eSearch API on elastic.co\u003c/a\u003e\n     * @param searchRequest the request\n     * @param options the request options (e.g. headers), use {@link RequestOptions#DEFAULT} if nothing needs to be customized\n     * @return the response\n     */"
			},
			{
				"signature": "public final Cancellable searchAsync(SearchRequest searchRequest, RequestOptions options, ActionListener\u003cSearchResponse\u003e listener)",
				"documentation": "/**\n     * Asynchronously executes a search using the Search API.\n     * See \u003ca href=\"https://www.elastic.co/guide/en/elasticsearch/reference/current/search-search.html\"\u003eSearch API on elastic.co\u003c/a\u003e\n     * @param searchRequest the request\n     * @param options the request options (e.g. headers), use {@link RequestOptions#DEFAULT} if nothing needs to be customized\n     * @param listener the listener to be notified upon request completion\n     * @return cancellable that may be used to cancel the request\n     */"
			},
			{
				"signature": "public final MultiSearchResponse multiSearch(MultiSearchRequest multiSearchRequest, RequestOptions options) throws IOException",
				"documentation": "/**\n     * Executes a multi search using the msearch API.\n     * See \u003ca href=\"https://www.elastic.co/guide/en/elasticsearch/reference/current/search-multi-search.html\"\u003eMulti search API on\n     * elastic.co\u003c/a\u003e\n     * @param multiSearchRequest the request\n     * @param options the request options (e.g. headers), use {@link RequestOptions#DEFAULT} if nothing needs to be customized\n     * @return the response\n     * @deprecated use {@link #msearch(MultiSearchRequest, RequestOptions)} instead\n     */"
			},
			{
				"signature": "public final MultiSearchResponse msearch(MultiSearchRequest multiSearchRequest, RequestOptions options) throws IOException",
				"documentation": "/**\n     * Executes a multi search using the msearch API.\n     * See \u003ca href=\"https://www.elastic.co/guide/en/elasticsearch/reference/current/search-multi-search.html\"\u003eMulti search API on\n     * elastic.co\u003c/a\u003e\n     * @param multiSearchRequest the request\n     * @param options the request options (e.g. headers), use {@link RequestOptions#DEFAULT} if nothing needs to be customized\n     * @return the response\n     */"
			},
			{
				"signature": "public final Cancellable multiSearchAsync(        MultiSearchRequest searchRequest,        RequestOptions options,        ActionListener\u003cMultiSearchResponse\u003e listener    )",
				"documentation": "/**\n     * Asynchronously executes a multi search using the msearch API.\n     * See \u003ca href=\"https://www.elastic.co/guide/en/elasticsearch/reference/current/search-multi-search.html\"\u003eMulti search API on\n     * elastic.co\u003c/a\u003e\n     * @param searchRequest the request\n     * @param options the request options (e.g. headers), use {@link RequestOptions#DEFAULT} if nothing needs to be customized\n     * @param listener the listener to be notified upon request completion\n     * @deprecated use {@link #msearchAsync(MultiSearchRequest, RequestOptions, ActionListener)} instead\n     * @return cancellable that may be used to cancel the request\n     */"
			},
			{
				"signature": "public final Cancellable msearchAsync(        MultiSearchRequest searchRequest,        RequestOptions options,        ActionListener\u003cMultiSearchResponse\u003e listener    )",
				"documentation": "/**\n     * Asynchronously executes a multi search using the msearch API.\n     * See \u003ca href=\"https://www.elastic.co/guide/en/elasticsearch/reference/current/search-multi-search.html\"\u003eMulti search API on\n     * elastic.co\u003c/a\u003e\n     * @param searchRequest the request\n     * @param options the request options (e.g. headers), use {@link RequestOptions#DEFAULT} if nothing needs to be customized\n     * @param listener the listener to be notified upon request completion\n     * @return cancellable that may be used to cancel the request\n     */"
			},
			{
				"signature": "public final SearchResponse searchScroll(SearchScrollRequest searchScrollRequest, RequestOptions options) throws IOException",
				"documentation": "/**\n     * Executes a search using the Search Scroll API.\n     * See \u003ca\n     * href=\"https://www.elastic.co/guide/en/elasticsearch/reference/master/search-request-body.html#request-body-search-scroll\"\u003eSearch\n     * Scroll API on elastic.co\u003c/a\u003e\n     * @param searchScrollRequest the request\n     * @param options the request options (e.g. headers), use {@link RequestOptions#DEFAULT} if nothing needs to be customized\n     * @return the response\n     * @deprecated use {@link #scroll(SearchScrollRequest, RequestOptions)} instead\n     */"
			},
			{
				"signature": "public final SearchResponse scroll(SearchScrollRequest searchScrollRequest, RequestOptions options) throws IOException",
				"documentation": "/**\n     * Executes a search using the Search Scroll API.\n     * See \u003ca\n     * href=\"https://www.elastic.co/guide/en/elasticsearch/reference/master/search-request-body.html#request-body-search-scroll\"\u003eSearch\n     * Scroll API on elastic.co\u003c/a\u003e\n     * @param searchScrollRequest the request\n     * @param options the request options (e.g. headers), use {@link RequestOptions#DEFAULT} if nothing needs to be customized\n     * @return the response\n     */"
			},
			{
				"signature": "public final Cancellable searchScrollAsync(        SearchScrollRequest searchScrollRequest,        RequestOptions options,        ActionListener\u003cSearchResponse\u003e listener    )",
				"documentation": "/**\n     * Asynchronously executes a search using the Search Scroll API.\n     * See \u003ca\n     * href=\"https://www.elastic.co/guide/en/elasticsearch/reference/master/search-request-body.html#request-body-search-scroll\"\u003eSearch\n     * Scroll API on elastic.co\u003c/a\u003e\n     * @param searchScrollRequest the request\n     * @param options the request options (e.g. headers), use {@link RequestOptions#DEFAULT} if nothing needs to be customized\n     * @param listener the listener to be notified upon request completion\n     * @deprecated use {@link #scrollAsync(SearchScrollRequest, RequestOptions, ActionListener)} instead\n     * @return cancellable that may be used to cancel the request\n     */"
			},
			{
				"signature": "public final Cancellable scrollAsync(        SearchScrollRequest searchScrollRequest,        RequestOptions options,        ActionListener\u003cSearchResponse\u003e listener    )",
				"documentation": "/**\n     * Asynchronously executes a search using the Search Scroll API.\n     * See \u003ca\n     * href=\"https://www.elastic.co/guide/en/elasticsearch/reference/master/search-request-body.html#request-body-search-scroll\"\u003eSearch\n     * Scroll API on elastic.co\u003c/a\u003e\n     * @param searchScrollRequest the request\n     * @param options the request options (e.g. headers), use {@link RequestOptions#DEFAULT} if nothing needs to be customized\n     * @param listener the listener to be notified upon request completion\n     * @return cancellable that may be used to cancel the request\n     */"
			},
			{
				"signature": "public final ClearScrollResponse clearScroll(ClearScrollRequest clearScrollRequest, RequestOptions options) throws IOException",
				"documentation": "/**\n     * Clears one or more scroll ids using the Clear Scroll API.\n     * See \u003ca\n     * href=\"https://www.elastic.co/guide/en/elasticsearch/reference/master/search-request-body.html#_clear_scroll_api\"\u003e\n     * Clear Scroll API on elastic.co\u003c/a\u003e\n     * @param clearScrollRequest the request\n     * @param options the request options (e.g. headers), use {@link RequestOptions#DEFAULT} if nothing needs to be customized\n     * @return the response\n     */"
			},
			{
				"signature": "public final Cancellable clearScrollAsync(        ClearScrollRequest clearScrollRequest,        RequestOptions options,        ActionListener\u003cClearScrollResponse\u003e listener    )",
				"documentation": "/**\n     * Asynchronously clears one or more scroll ids using the Clear Scroll API.\n     * See \u003ca\n     * href=\"https://www.elastic.co/guide/en/elasticsearch/reference/master/search-request-body.html#_clear_scroll_api\"\u003e\n     * Clear Scroll API on elastic.co\u003c/a\u003e\n     * @param clearScrollRequest the request\n     * @param options the request options (e.g. headers), use {@link RequestOptions#DEFAULT} if nothing needs to be customized\n     * @param listener the listener to be notified upon request completion\n     * @return cancellable that may be used to cancel the request\n     */"
			},
			{
				"signature": "public final OpenPointInTimeResponse openPointInTime(OpenPointInTimeRequest openRequest, RequestOptions options) throws IOException",
				"documentation": "/**\n     * Open a point in time before using it in search requests.\n     * See \u003ca href=\"https://www.elastic.co/guide/en/elasticsearch/reference/master/point-in-time-api.html\"\u003e Point in time API \u003c/a\u003e\n     * @param openRequest the open request\n     * @param options the request options (e.g. headers), use {@link RequestOptions#DEFAULT} if nothing needs to be customized\n     * @return the response containing the point in time id\n     */"
			},
			{
				"signature": "public final Cancellable openPointInTimeAsync(        OpenPointInTimeRequest openRequest,        RequestOptions options,        ActionListener\u003cOpenPointInTimeResponse\u003e listener    )",
				"documentation": "/**\n     * Asynchronously open a point in time before using it in search requests\n     * See \u003ca href=\"https://www.elastic.co/guide/en/elasticsearch/reference/master/point-in-time-api.html\"\u003e Point in time API \u003c/a\u003e\n     * @param openRequest the open request\n     * @param options the request options (e.g. headers), use {@link RequestOptions#DEFAULT} if nothing needs to be customized\n     * @param listener the listener to be notified upon request completion\n     * @return a cancellable that may be used to cancel the request\n     */"
			},
			{
				"signature": "public final ClosePointInTimeResponse closePointInTime(ClosePointInTimeRequest closeRequest, RequestOptions options)        throws IOException",
				"documentation": "/**\n     * Close a point in time that is opened with {@link #openPointInTime(OpenPointInTimeRequest, RequestOptions)} or\n     * {@link #openPointInTimeAsync(OpenPointInTimeRequest, RequestOptions, ActionListener)}.\n     * See \u003ca href=\"https://www.elastic.co/guide/en/elasticsearch/reference/master/point-in-time-api.html#close-point-in-time-api\"\u003e\n     * Close point in time API\u003c/a\u003e\n     * @param closeRequest the close request\n     * @param options the request options (e.g. headers), use {@link RequestOptions#DEFAULT} if nothing needs to be customized\n     * @return the response\n     */"
			},
			{
				"signature": "public final Cancellable closePointInTimeAsync(        ClosePointInTimeRequest closeRequest,        RequestOptions options,        ActionListener\u003cClosePointInTimeResponse\u003e listener    )",
				"documentation": "/**\n     * Asynchronously close a point in time that is opened with {@link #openPointInTime(OpenPointInTimeRequest, RequestOptions)} or\n     * {@link #openPointInTimeAsync(OpenPointInTimeRequest, RequestOptions, ActionListener)}.\n     * See \u003ca href=\"https://www.elastic.co/guide/en/elasticsearch/reference/master/point-in-time-api.html#close-point-in-time-api\"\u003e\n     * Close point in time API\u003c/a\u003e\n     * @param closeRequest the close request\n     * @param options the request options (e.g. headers), use {@link RequestOptions#DEFAULT} if nothing needs to be customized\n     * @param listener the listener to be notified upon request completion\n     * @return a cancellable that may be used to cancel the request\n     */"
			},
			{
				"signature": "public final SearchTemplateResponse searchTemplate(SearchTemplateRequest searchTemplateRequest, RequestOptions options)        throws IOException",
				"documentation": "/**\n     * Executes a request using the Search Template API.\n     * See \u003ca href=\"https://www.elastic.co/guide/en/elasticsearch/reference/current/search-template.html\"\u003eSearch Template API\n     * on elastic.co\u003c/a\u003e.\n     * @param searchTemplateRequest the request\n     * @param options the request options (e.g. headers), use {@link RequestOptions#DEFAULT} if nothing needs to be customized\n     * @return the response\n     */"
			},
			{
				"signature": "public final Cancellable searchTemplateAsync(        SearchTemplateRequest searchTemplateRequest,        RequestOptions options,        ActionListener\u003cSearchTemplateResponse\u003e listener    )",
				"documentation": "/**\n     * Asynchronously executes a request using the Search Template API.\n     *\n     * See \u003ca href=\"https://www.elastic.co/guide/en/elasticsearch/reference/current/search-template.html\"\u003eSearch Template API\n     * on elastic.co\u003c/a\u003e.\n     * @return cancellable that may be used to cancel the request\n     */"
			},
			{
				"signature": "public final ExplainResponse explain(ExplainRequest explainRequest, RequestOptions options) throws IOException",
				"documentation": "/**\n     * Executes a request using the Explain API.\n     * See \u003ca href=\"https://www.elastic.co/guide/en/elasticsearch/reference/current/search-explain.html\"\u003eExplain API on elastic.co\u003c/a\u003e\n     * @param explainRequest the request\n     * @param options the request options (e.g. headers), use {@link RequestOptions#DEFAULT} if nothing needs to be customized\n     * @return the response\n     */"
			},
			{
				"signature": "public final Cancellable explainAsync(ExplainRequest explainRequest, RequestOptions options, ActionListener\u003cExplainResponse\u003e listener)",
				"documentation": "/**\n     * Asynchronously executes a request using the Explain API.\n     *\n     * See \u003ca href=\"https://www.elastic.co/guide/en/elasticsearch/reference/current/search-explain.html\"\u003eExplain API on elastic.co\u003c/a\u003e\n     * @param explainRequest the request\n     * @param options the request options (e.g. headers), use {@link RequestOptions#DEFAULT} if nothing needs to be customized\n     * @param listener the listener to be notified upon request completion\n     * @return cancellable that may be used to cancel the request\n     */"
			},
			{
				"signature": "public final TermVectorsResponse termvectors(TermVectorsRequest request, RequestOptions options) throws IOException",
				"documentation": "/**\n     * Calls the Term Vectors API\n     *\n     * See \u003ca href=\"https://www.elastic.co/guide/en/elasticsearch/reference/current/docs-termvectors.html\"\u003eTerm Vectors API on\n     * elastic.co\u003c/a\u003e\n     *\n     * @param request   the request\n     * @param options   the request options (e.g. headers), use {@link RequestOptions#DEFAULT} if nothing needs to be customized\n     */"
			},
			{
				"signature": "public final Cancellable termvectorsAsync(        TermVectorsRequest request,        RequestOptions options,        ActionListener\u003cTermVectorsResponse\u003e listener    )",
				"documentation": "/**\n     * Asynchronously calls the Term Vectors API\n     *\n     * See \u003ca href=\"https://www.elastic.co/guide/en/elasticsearch/reference/current/docs-termvectors.html\"\u003eTerm Vectors API on\n     * elastic.co\u003c/a\u003e\n     * @param request the request\n     * @param options the request options (e.g. headers), use {@link RequestOptions#DEFAULT} if nothing needs to be customized\n     * @param listener the listener to be notified upon request completion\n     * @return cancellable that may be used to cancel the request\n     */"
			},
			{
				"signature": "public final MultiTermVectorsResponse mtermvectors(MultiTermVectorsRequest request, RequestOptions options) throws IOException",
				"documentation": "/**\n     * Calls the Multi Term Vectors API\n     *\n     * See \u003ca href=\"https://www.elastic.co/guide/en/elasticsearch/reference/current/docs-multi-termvectors.html\"\u003eMulti Term Vectors API\n     * on elastic.co\u003c/a\u003e\n     *\n     * @param request   the request\n     * @param options   the request options (e.g. headers), use {@link RequestOptions#DEFAULT} if nothing needs to be customized\n     */"
			},
			{
				"signature": "public final Cancellable mtermvectorsAsync(        MultiTermVectorsRequest request,        RequestOptions options,        ActionListener\u003cMultiTermVectorsResponse\u003e listener    )",
				"documentation": "/**\n     * Asynchronously calls the Multi Term Vectors API\n     *\n     * See \u003ca href=\"https://www.elastic.co/guide/en/elasticsearch/reference/current/docs-multi-termvectors.html\"\u003eMulti Term Vectors API\n     * on elastic.co\u003c/a\u003e\n     * @param request the request\n     * @param options the request options (e.g. headers), use {@link RequestOptions#DEFAULT} if nothing needs to be customized\n     * @param listener the listener to be notified upon request completion\n     * @return cancellable that may be used to cancel the request\n     */"
			},
			{
				"signature": "public final RankEvalResponse rankEval(RankEvalRequest rankEvalRequest, RequestOptions options) throws IOException",
				"documentation": "/**\n     * Executes a request using the Ranking Evaluation API.\n     * See \u003ca href=\"https://www.elastic.co/guide/en/elasticsearch/reference/current/search-rank-eval.html\"\u003eRanking Evaluation API\n     * on elastic.co\u003c/a\u003e\n     * @param rankEvalRequest the request\n     * @param options the request options (e.g. headers), use {@link RequestOptions#DEFAULT} if nothing needs to be customized\n     * @return the response\n     */"
			},
			{
				"signature": "public final MultiSearchTemplateResponse msearchTemplate(MultiSearchTemplateRequest multiSearchTemplateRequest, RequestOptions options)        throws IOException",
				"documentation": "/**\n     * Executes a request using the Multi Search Template API.\n     *\n     * See \u003ca href=\"https://www.elastic.co/guide/en/elasticsearch/reference/current/multi-search-template.html\"\u003eMulti Search Template API\n     * on elastic.co\u003c/a\u003e.\n     */"
			},
			{
				"signature": "public final Cancellable msearchTemplateAsync(        MultiSearchTemplateRequest multiSearchTemplateRequest,        RequestOptions options,        ActionListener\u003cMultiSearchTemplateResponse\u003e listener    )",
				"documentation": "/**\n     * Asynchronously executes a request using the Multi Search Template API\n     *\n     * See \u003ca href=\"https://www.elastic.co/guide/en/elasticsearch/reference/current/multi-search-template.html\"\u003eMulti Search Template API\n     * on elastic.co\u003c/a\u003e.\n     * @return cancellable that may be used to cancel the request\n     */"
			},
			{
				"signature": "public final Cancellable rankEvalAsync(        RankEvalRequest rankEvalRequest,        RequestOptions options,        ActionListener\u003cRankEvalResponse\u003e listener    )",
				"documentation": "/**\n     * Asynchronously executes a request using the Ranking Evaluation API.\n     * See \u003ca href=\"https://www.elastic.co/guide/en/elasticsearch/reference/current/search-rank-eval.html\"\u003eRanking Evaluation API\n     * on elastic.co\u003c/a\u003e\n     * @param rankEvalRequest the request\n     * @param options the request options (e.g. headers), use {@link RequestOptions#DEFAULT} if nothing needs to be customized\n     * @param listener the listener to be notified upon request completion\n     * @return cancellable that may be used to cancel the request\n     */"
			},
			{
				"signature": "public final FieldCapabilitiesResponse fieldCaps(FieldCapabilitiesRequest fieldCapabilitiesRequest, RequestOptions options)        throws IOException",
				"documentation": "/**\n     * Executes a request using the Field Capabilities API.\n     * See \u003ca href=\"https://www.elastic.co/guide/en/elasticsearch/reference/current/search-field-caps.html\"\u003eField Capabilities API\n     * on elastic.co\u003c/a\u003e.\n     * @param fieldCapabilitiesRequest the request\n     * @param options the request options (e.g. headers), use {@link RequestOptions#DEFAULT} if nothing needs to be customized\n     * @return the response\n     */"
			},
			{
				"signature": "public GetStoredScriptResponse getScript(GetStoredScriptRequest request, RequestOptions options) throws IOException",
				"documentation": "/**\n     * Get stored script by id.\n     * See \u003ca href=\"https://www.elastic.co/guide/en/elasticsearch/reference/current/modules-scripting-using.html\"\u003e\n     *     How to use scripts on elastic.co\u003c/a\u003e\n     * @param request the request\n     * @param options the request options (e.g. headers), use {@link RequestOptions#DEFAULT} if nothing needs to be customized\n     * @return the response\n     */"
			},
			{
				"signature": "public Cancellable getScriptAsync(        GetStoredScriptRequest request,        RequestOptions options,        ActionListener\u003cGetStoredScriptResponse\u003e listener    )",
				"documentation": "/**\n     * Asynchronously get stored script by id.\n     * See \u003ca href=\"https://www.elastic.co/guide/en/elasticsearch/reference/current/modules-scripting-using.html\"\u003e\n     *     How to use scripts on elastic.co\u003c/a\u003e\n     * @param request the request\n     * @param options the request options (e.g. headers), use {@link RequestOptions#DEFAULT} if nothing needs to be customized\n     * @param listener the listener to be notified upon request completion\n     * @return cancellable that may be used to cancel the request\n     */"
			},
			{
				"signature": "public AcknowledgedResponse deleteScript(DeleteStoredScriptRequest request, RequestOptions options) throws IOException",
				"documentation": "/**\n     * Delete stored script by id.\n     * See \u003ca href=\"https://www.elastic.co/guide/en/elasticsearch/reference/current/modules-scripting-using.html\"\u003e\n     *     How to use scripts on elastic.co\u003c/a\u003e\n     * @param request the request\n     * @param options the request options (e.g. headers), use {@link RequestOptions#DEFAULT} if nothing needs to be customized\n     * @return the response\n     */"
			},
			{
				"signature": "public Cancellable deleteScriptAsync(        DeleteStoredScriptRequest request,        RequestOptions options,        ActionListener\u003cAcknowledgedResponse\u003e listener    )",
				"documentation": "/**\n     * Asynchronously delete stored script by id.\n     * See \u003ca href=\"https://www.elastic.co/guide/en/elasticsearch/reference/current/modules-scripting-using.html\"\u003e\n     *     How to use scripts on elastic.co\u003c/a\u003e\n     * @param request the request\n     * @param options the request options (e.g. headers), use {@link RequestOptions#DEFAULT} if nothing needs to be customized\n     * @param listener the listener to be notified upon request completion\n     * @return cancellable that may be used to cancel the request\n     */"
			},
			{
				"signature": "public AcknowledgedResponse putScript(PutStoredScriptRequest putStoredScriptRequest, RequestOptions options) throws IOException",
				"documentation": "/**\n     * Puts an stored script using the Scripting API.\n     * See \u003ca href=\"https://www.elastic.co/guide/en/elasticsearch/reference/current/modules-scripting-using.html\"\u003e Scripting API\n     * on elastic.co\u003c/a\u003e\n     * @param putStoredScriptRequest the request\n     * @param options the request options (e.g. headers), use {@link RequestOptions#DEFAULT} if nothing needs to be customized\n     * @return the response\n     */"
			},
			{
				"signature": "public Cancellable putScriptAsync(        PutStoredScriptRequest putStoredScriptRequest,        RequestOptions options,        ActionListener\u003cAcknowledgedResponse\u003e listener    )",
				"documentation": "/**\n     * Asynchronously puts an stored script using the Scripting API.\n     * See \u003ca href=\"https://www.elastic.co/guide/en/elasticsearch/reference/current/modules-scripting-using.html\"\u003e Scripting API\n     * on elastic.co\u003c/a\u003e\n     * @param putStoredScriptRequest the request\n     * @param options the request options (e.g. headers), use {@link RequestOptions#DEFAULT} if nothing needs to be customized\n     * @param listener the listener to be notified upon request completion\n     * @return cancellable that may be used to cancel the request\n     */"
			},
			{
				"signature": "public final Cancellable fieldCapsAsync(        FieldCapabilitiesRequest fieldCapabilitiesRequest,        RequestOptions options,        ActionListener\u003cFieldCapabilitiesResponse\u003e listener    )",
				"documentation": "/**\n     * Asynchronously executes a request using the Field Capabilities API.\n     * See \u003ca href=\"https://www.elastic.co/guide/en/elasticsearch/reference/current/search-field-caps.html\"\u003eField Capabilities API\n     * on elastic.co\u003c/a\u003e.\n     * @param fieldCapabilitiesRequest the request\n     * @param options the request options (e.g. headers), use {@link RequestOptions#DEFAULT} if nothing needs to be customized\n     * @param listener the listener to be notified upon request completion\n     * @return cancellable that may be used to cancel the request\n     */"
			},
			{
				"signature": "protected final \u003cReq extends ActionRequest, Resp\u003e Resp performRequestAndParseEntity(        Req request,        CheckedFunction\u003cReq, Request, IOException\u003e requestConverter,        RequestOptions options,        CheckedFunction\u003cXContentParser, Resp, IOException\u003e entityParser,        Set\u003cInteger\u003e ignores    ) throws IOException",
				"documentation": "/**\n     * @deprecated If creating a new HLRC ReST API call, consider creating new actions instead of reusing server actions. The Validation\n     * layer has been added to the ReST client, and requests should extend {@link Validatable} instead of {@link ActionRequest}.\n     */"
			},
			{
				"signature": "protected final \u003cReq extends Validatable, Resp\u003e Resp performRequestAndParseEntity(        Req request,        CheckedFunction\u003cReq, Request, IOException\u003e requestConverter,        RequestOptions options,        CheckedFunction\u003cXContentParser, Resp, IOException\u003e entityParser,        Set\u003cInteger\u003e ignores    ) throws IOException",
				"documentation": "/**\n     * Defines a helper method for performing a request and then parsing the returned entity using the provided entityParser.\n     */"
			},
			{
				"signature": "protected final \u003cReq extends ActionRequest, Resp\u003e Resp performRequest(        Req request,        CheckedFunction\u003cReq, Request, IOException\u003e requestConverter,        RequestOptions options,        CheckedFunction\u003cResponse, Resp, IOException\u003e responseConverter,        Set\u003cInteger\u003e ignores    ) throws IOException",
				"documentation": "/**\n     * @deprecated If creating a new HLRC ReST API call, consider creating new actions instead of reusing server actions. The Validation\n     * layer has been added to the ReST client, and requests should extend {@link Validatable} instead of {@link ActionRequest}.\n     */"
			},
			{
				"signature": "protected final \u003cReq extends Validatable, Resp\u003e Resp performRequest(        Req request,        CheckedFunction\u003cReq, Request, IOException\u003e requestConverter,        RequestOptions options,        CheckedFunction\u003cResponse, Resp, IOException\u003e responseConverter,        Set\u003cInteger\u003e ignores    ) throws IOException",
				"documentation": "/**\n     * Defines a helper method for performing a request.\n     */"
			},
			{
				"signature": "private \u003cReq, Resp\u003e Resp internalPerformRequest(        Req request,        CheckedFunction\u003cReq, Request, IOException\u003e requestConverter,        RequestOptions options,        CheckedFunction\u003cResponse, Resp, IOException\u003e responseConverter,        Set\u003cInteger\u003e ignores    ) throws IOException",
				"documentation": "/**\n     * Provides common functionality for performing a request.\n     */"
			},
			{
				"signature": "protected final \u003cReq extends Validatable, Resp\u003e Optional\u003cResp\u003e performRequestAndParseOptionalEntity(        Req request,        CheckedFunction\u003cReq, Request, IOException\u003e requestConverter,        RequestOptions options,        CheckedFunction\u003cXContentParser, Resp, IOException\u003e entityParser    ) throws IOException",
				"documentation": "/**\n     * Defines a helper method for requests that can 404 and in which case will return an empty Optional\n     * otherwise tries to parse the response body\n     */"
			},
			{
				"signature": "protected final \u003cReq extends ActionRequest, Resp\u003e Cancellable performRequestAsyncAndParseEntity(        Req request,        CheckedFunction\u003cReq, Request, IOException\u003e requestConverter,        RequestOptions options,        CheckedFunction\u003cXContentParser, Resp, IOException\u003e entityParser,        ActionListener\u003cResp\u003e listener,        Set\u003cInteger\u003e ignores    )",
				"documentation": "/**\n     * @deprecated If creating a new HLRC ReST API call, consider creating new actions instead of reusing server actions. The Validation\n     * layer has been added to the ReST client, and requests should extend {@link Validatable} instead of {@link ActionRequest}.\n     * @return Cancellable instance that may be used to cancel the request\n     */"
			},
			{
				"signature": "protected final \u003cReq extends Validatable, Resp\u003e Cancellable performRequestAsyncAndParseEntity(        Req request,        CheckedFunction\u003cReq, Request, IOException\u003e requestConverter,        RequestOptions options,        CheckedFunction\u003cXContentParser, Resp, IOException\u003e entityParser,        ActionListener\u003cResp\u003e listener,        Set\u003cInteger\u003e ignores    )",
				"documentation": "/**\n     * Defines a helper method for asynchronously performing a request.\n     * @return Cancellable instance that may be used to cancel the request\n     */"
			},
			{
				"signature": "protected final \u003cReq extends ActionRequest, Resp\u003e Cancellable performRequestAsync(        Req request,        CheckedFunction\u003cReq, Request, IOException\u003e requestConverter,        RequestOptions options,        CheckedFunction\u003cResponse, Resp, IOException\u003e responseConverter,        ActionListener\u003cResp\u003e listener,        Set\u003cInteger\u003e ignores    )",
				"documentation": "/**\n     * @deprecated If creating a new HLRC ReST API call, consider creating new actions instead of reusing server actions. The Validation\n     * layer has been added to the ReST client, and requests should extend {@link Validatable} instead of {@link ActionRequest}.\n     * @return Cancellable instance that may be used to cancel the request\n     */"
			},
			{
				"signature": "protected final \u003cReq extends Validatable, Resp\u003e Cancellable performRequestAsync(        Req request,        CheckedFunction\u003cReq, Request, IOException\u003e requestConverter,        RequestOptions options,        CheckedFunction\u003cResponse, Resp, IOException\u003e responseConverter,        ActionListener\u003cResp\u003e listener,        Set\u003cInteger\u003e ignores    )",
				"documentation": "/**\n     * Defines a helper method for asynchronously performing a request.\n     * @return Cancellable instance that may be used to cancel the request\n     */"
			},
			{
				"signature": "private \u003cReq, Resp\u003e Cancellable internalPerformRequestAsync(        Req request,        CheckedFunction\u003cReq, Request, IOException\u003e requestConverter,        RequestOptions options,        CheckedFunction\u003cResponse, Resp, IOException\u003e responseConverter,        ActionListener\u003cResp\u003e listener,        Set\u003cInteger\u003e ignores    )",
				"documentation": "/**\n     * Provides common functionality for asynchronously performing a request.\n     * @return Cancellable instance that may be used to cancel the request\n     */"
			},
			{
				"signature": "final \u003cResp\u003e ResponseListener wrapResponseListener(        CheckedFunction\u003cResponse, Resp, IOException\u003e responseConverter,        ActionListener\u003cResp\u003e actionListener,        Set\u003cInteger\u003e ignores    )",
				"documentation": ""
			},
			{
				"signature": "public void onSuccess(Response response)",
				"documentation": ""
			},
			{
				"signature": "public void onFailure(Exception exception)",
				"documentation": ""
			},
			{
				"signature": "protected final \u003cReq extends Validatable, Resp\u003e Cancellable performRequestAsyncAndParseOptionalEntity(        Req request,        CheckedFunction\u003cReq, Request, IOException\u003e requestConverter,        RequestOptions options,        CheckedFunction\u003cXContentParser, Resp, IOException\u003e entityParser,        ActionListener\u003cOptional\u003cResp\u003e\u003e listener    )",
				"documentation": "/**\n     * Asynchronous request which returns empty {@link Optional}s in the case of 404s or parses entity into an Optional\n     * @return Cancellable instance that may be used to cancel the request\n     */"
			},
			{
				"signature": "final \u003cResp\u003e ResponseListener wrapResponseListener404sOptional(        CheckedFunction\u003cResponse, Resp, IOException\u003e responseConverter,        ActionListener\u003cOptional\u003cResp\u003e\u003e actionListener    )",
				"documentation": ""
			},
			{
				"signature": "public void onSuccess(Response response)",
				"documentation": ""
			},
			{
				"signature": "public void onFailure(Exception exception)",
				"documentation": ""
			},
			{
				"signature": "protected final ElasticsearchStatusException parseResponseException(ResponseException responseException)",
				"documentation": "/**\n     * Converts a {@link ResponseException} obtained from the low level REST client into an {@link ElasticsearchException}.\n     * If a response body was returned, tries to parse it as an error returned from Elasticsearch.\n     * If no response body was returned or anything goes wrong while parsing the error, returns a new {@link ElasticsearchStatusException}\n     * that wraps the original {@link ResponseException}. The potential exception obtained while parsing is added to the returned\n     * exception as a suppressed exception. This method is guaranteed to not throw any exception eventually thrown while parsing.\n     */"
			},
			{
				"signature": "protected final \u003cResp\u003e Resp parseEntity(final HttpEntity entity, final CheckedFunction\u003cXContentParser, Resp, IOException\u003e entityParser)        throws IOException",
				"documentation": ""
			},
			{
				"signature": "protected static boolean convertExistsResponse(Response response)",
				"documentation": ""
			},
			{
				"signature": "private Cancellable performClientRequestAsync(Request request, ResponseListener listener)",
				"documentation": ""
			},
			{
				"signature": "public void cancel()",
				"documentation": ""
			},
			{
				"signature": "void runIfNotCancelled(Runnable runnable)",
				"documentation": ""
			},
			{
				"signature": "public void onResponse(Optional\u003cString\u003e validation)",
				"documentation": ""
			},
			{
				"signature": "public void onFailure(Exception e)",
				"documentation": ""
			},
			{
				"signature": "boolean addCompatibilityFor(RequestOptions.Builder newOptions, Header entityHeader, String headerName)",
				"documentation": "/**\n     * Go through all the request's existing headers, looking for {@code headerName} headers and if they exist,\n     * changing them to use version compatibility. If no request headers are changed, modify the entity type header if appropriate\n     */"
			},
			{
				"signature": "boolean modifyHeader(RequestOptions.Builder newOptions, Header header, String headerName)",
				"documentation": "/**\n     * Modify the given header to be version compatible, if necessary.\n     * Returns true if a modification was made, false otherwise.\n     */"
			},
			{
				"signature": "void modifyRequestForCompatibility(Request request)",
				"documentation": "/**\n     * Make all necessary changes to support API compatibility for the given request. This includes\n     * modifying the \"Content-Type\" and \"Accept\" headers if present, or modifying the header based\n     * on the request's entity type.\n     */"
			},
			{
				"signature": "private Response performClientRequest(Request request) throws IOException",
				"documentation": ""
			},
			{
				"signature": "private ListenableFuture\u003cOptional\u003cString\u003e\u003e getVersionValidationFuture()",
				"documentation": "/**\n     * Returns a future that asynchronously validates the Elasticsearch product version. Its result is an optional string: if empty then\n     * validation was successful, if present it contains the validation error. API requests should be chained to this future and check\n     * the validation result before going further.\n     * \u003cp\u003e\n     * This future is a memoization of the first successful request to the \"/\" endpoint and the subsequent compatibility check\n     * ({@see #versionValidationFuture}). Further client requests reuse its result.\n     * \u003cp\u003e\n     * If the version check request fails (e.g. network error), {@link #versionValidationFuture} is cleared so that a new validation\n     * request is sent at the next HLRC request. This allows retries to happen while avoiding a busy retry loop (LLRC retries on the node\n     * pool still happen).\n     */"
			},
			{
				"signature": "public void onSuccess(Response response)",
				"documentation": ""
			},
			{
				"signature": "public void onFailure(Exception exception)",
				"documentation": ""
			},
			{
				"signature": "private Optional\u003cString\u003e getVersionValidation(Response response) throws IOException",
				"documentation": "/**\n     * Validates that the response info() is a compatible Elasticsearch version.\n     *\n     * @return an optional string. If empty, version is compatible. Otherwise, it's the message to return to the application.\n     */"
			},
			{
				"signature": "static List\u003cNamedXContentRegistry.Entry\u003e getDefaultNamedXContents()",
				"documentation": "/**\n     * Ignores deprecation warnings. This is appropriate because it is only\n     * used to parse responses from Elasticsearch. Any deprecation warnings\n     * emitted there just mean that you are talking to an old version of\n     * Elasticsearch. There isn't anything you can do about the deprecation.\n     */"
			},
			{
				"signature": "static List\u003cNamedXContentRegistry.Entry\u003e getProvidedNamedXContents()",
				"documentation": "/**\n     * Loads and returns the {@link NamedXContentRegistry.Entry} parsers provided by plugins.\n     */"
			}
		],
		"interfaces": [
			"java.io.Closeable"
		]
	},
	{
		"documentation": "",
		"name": "org.elasticsearch.client.private",
		"extends": "",
		"Methods": [
			{
				"signature": "JSON()",
				"documentation": ""
			},
			{
				"signature": "public String header()",
				"documentation": ""
			},
			{
				"signature": "public String compatibleHeader()",
				"documentation": ""
			},
			{
				"signature": ",        NDJSON()",
				"documentation": ""
			},
			{
				"signature": "public String header()",
				"documentation": ""
			},
			{
				"signature": "public String compatibleHeader()",
				"documentation": ""
			},
			{
				"signature": ",        STAR()",
				"documentation": ""
			},
			{
				"signature": "public String header()",
				"documentation": ""
			},
			{
				"signature": "public String compatibleHeader()",
				"documentation": ""
			},
			{
				"signature": ",        YAML()",
				"documentation": ""
			},
			{
				"signature": "public String header()",
				"documentation": ""
			},
			{
				"signature": "public String compatibleHeader()",
				"documentation": ""
			},
			{
				"signature": ",        SMILE()",
				"documentation": ""
			},
			{
				"signature": "public String header()",
				"documentation": ""
			},
			{
				"signature": "public String compatibleHeader()",
				"documentation": ""
			},
			{
				"signature": ",        CBOR()",
				"documentation": ""
			},
			{
				"signature": "public String header()",
				"documentation": ""
			},
			{
				"signature": "public String compatibleHeader()",
				"documentation": ""
			},
			{
				"signature": "public String toString()",
				"documentation": ""
			}
		],
		"interfaces": []
	},
	{
		"documentation": "/**\n * Helper to build a {@link RestHighLevelClient}, allowing setting the low-level client that\n * should be used as well as whether API compatibility should be used.\n * @deprecated The High Level Rest Client is deprecated in favor of the\n * \u003ca href=\"https://www.elastic.co/guide/en/elasticsearch/client/java-api-client/current/introduction.html\"\u003e\n * Elasticsearch Java API Client\u003c/a\u003e\n */",
		"name": "org.elasticsearch.client.RestHighLevelClientBuilder",
		"extends": "",
		"Methods": [
			{
				"signature": "public RestHighLevelClientBuilder(RestClient restClient)",
				"documentation": "/**\n * Helper to build a {@link RestHighLevelClient}, allowing setting the low-level client that\n * should be used as well as whether API compatibility should be used.\n * @deprecated The High Level Rest Client is deprecated in favor of the\n * \u003ca href=\"https://www.elastic.co/guide/en/elasticsearch/client/java-api-client/current/introduction.html\"\u003e\n * Elasticsearch Java API Client\u003c/a\u003e\n */"
			},
			{
				"signature": "public RestHighLevelClientBuilder closeHandler(CheckedConsumer\u003cRestClient, IOException\u003e closeHandler)",
				"documentation": ""
			},
			{
				"signature": "public RestHighLevelClientBuilder namedXContentEntries(List\u003cNamedXContentRegistry.Entry\u003e namedXContentEntries)",
				"documentation": ""
			},
			{
				"signature": "public RestHighLevelClientBuilder setApiCompatibilityMode(Boolean enabled)",
				"documentation": ""
			},
			{
				"signature": "public RestHighLevelClient build()",
				"documentation": ""
			}
		],
		"interfaces": []
	},
	{
		"documentation": "/**\n * A request changing throttling of a task.\n */",
		"name": "org.elasticsearch.client.RethrottleRequest",
		"extends": "",
		"Methods": [
			{
				"signature": "public RethrottleRequest(TaskId taskId)",
				"documentation": "/**\n     * Create a new {@link RethrottleRequest} which disables any throttling for the given taskId.\n     * @param taskId the task for which throttling will be disabled\n     */"
			},
			{
				"signature": "public RethrottleRequest(TaskId taskId, float requestsPerSecond)",
				"documentation": "/**\n     * Create a new {@link RethrottleRequest} which changes the throttling for the given taskId.\n     * @param taskId the task that throttling changes will be applied to\n     * @param requestsPerSecond the number of requests per second that the task should perform. This needs to be a positive value.\n     */"
			},
			{
				"signature": "public TaskId getTaskId()",
				"documentation": "/**\n     * @return the task Id\n     */"
			},
			{
				"signature": "public float getRequestsPerSecond()",
				"documentation": "/**\n     * @return the requests per seconds value\n     */"
			},
			{
				"signature": "public String toString()",
				"documentation": ""
			}
		],
		"interfaces": [
			"Validatable"
		]
	},
	{
		"documentation": "/**\n * A wrapper for the {@link RestHighLevelClient} that provides methods for accessing the Security APIs.\n * \u003cp\u003e\n * See \u003ca href=\"https://www.elastic.co/guide/en/elasticsearch/reference/current/security-api.html\"\u003eSecurity APIs on elastic.co\u003c/a\u003e\n *\n * @deprecated The High Level Rest Client is deprecated in favor of the\n * \u003ca href=\"https://www.elastic.co/guide/en/elasticsearch/client/java-api-client/current/introduction.html\"\u003e\n * Elasticsearch Java API Client\u003c/a\u003e\n */",
		"name": "org.elasticsearch.client.SecurityClient",
		"extends": "",
		"Methods": [
			{
				"signature": "SecurityClient(RestHighLevelClient restHighLevelClient)",
				"documentation": "/**\n * A wrapper for the {@link RestHighLevelClient} that provides methods for accessing the Security APIs.\n * \u003cp\u003e\n * See \u003ca href=\"https://www.elastic.co/guide/en/elasticsearch/reference/current/security-api.html\"\u003eSecurity APIs on elastic.co\u003c/a\u003e\n *\n * @deprecated The High Level Rest Client is deprecated in favor of the\n * \u003ca href=\"https://www.elastic.co/guide/en/elasticsearch/client/java-api-client/current/introduction.html\"\u003e\n * Elasticsearch Java API Client\u003c/a\u003e\n */"
			},
			{
				"signature": "public ClearRealmCacheResponse clearRealmCache(ClearRealmCacheRequest request, RequestOptions options) throws IOException",
				"documentation": "/**\n     * Clears the cache in one or more realms.\n     * See \u003ca href=\"https://www.elastic.co/guide/en/elasticsearch/reference/current/security-api-clear-cache.html\"\u003e\n     * the docs\u003c/a\u003e for more.\n     *\n     * @param request the request with the realm names and usernames to clear the cache for\n     * @param options the request options (e.g. headers), use {@link RequestOptions#DEFAULT} if nothing needs to be customized\n     * @return the response from the clear realm cache call\n     * @throws IOException in case there is a problem sending the request or parsing back the response\n     */"
			},
			{
				"signature": "public CreateTokenResponse createToken(CreateTokenRequest request, RequestOptions options) throws IOException",
				"documentation": "/**\n     * Creates an OAuth2 token.\n     * See \u003ca href=\"https://www.elastic.co/guide/en/elasticsearch/reference/current/security-api-get-token.html\"\u003e\n     * the docs\u003c/a\u003e for more.\n     *\n     * @param request the request for the token\n     * @param options the request options (e.g. headers), use {@link RequestOptions#DEFAULT} if nothing needs to be customized\n     * @return the response from the create token call\n     * @throws IOException in case there is a problem sending the request or parsing back the response\n     */"
			},
			{
				"signature": "public InvalidateTokenResponse invalidateToken(InvalidateTokenRequest request, RequestOptions options) throws IOException",
				"documentation": "/**\n     * Invalidates an OAuth2 token.\n     * See \u003ca href=\"https://www.elastic.co/guide/en/elasticsearch/reference/current/security-api-invalidate-token.html\"\u003e\n     * the docs\u003c/a\u003e for more.\n     *\n     * @param request the request to invalidate the token\n     * @param options the request options (e.g. headers), use {@link RequestOptions#DEFAULT} if nothing needs to be customized\n     * @return the response from the create token call\n     * @throws IOException in case there is a problem sending the request or parsing back the response\n     */"
			},
			{
				"signature": "public GetApiKeyResponse getApiKey(final GetApiKeyRequest request, final RequestOptions options) throws IOException",
				"documentation": "/**\n     * Retrieve API Key(s) information.\u003cbr\u003e\n     * See \u003ca href=\"https://www.elastic.co/guide/en/elasticsearch/reference/current/security-api-get-api-key.html\"\u003e\n     * the docs\u003c/a\u003e for more.\n     *\n     * @param request the request to retrieve API key(s)\n     * @param options the request options (e.g. headers), use {@link RequestOptions#DEFAULT} if nothing needs to be customized\n     * @return the response from the get API key call\n     * @throws IOException in case there is a problem sending the request or parsing back the response\n     */"
			},
			{
				"signature": "public InvalidateApiKeyResponse invalidateApiKey(final InvalidateApiKeyRequest request, final RequestOptions options)        throws IOException",
				"documentation": "/**\n     * Invalidate API Key(s).\u003cbr\u003e\n     * See \u003ca href=\"https://www.elastic.co/guide/en/elasticsearch/reference/current/security-api-invalidate-api-key.html\"\u003e\n     * the docs\u003c/a\u003e for more.\n     *\n     * @param request the request to invalidate API key(s)\n     * @param options the request options (e.g. headers), use {@link RequestOptions#DEFAULT} if nothing needs to be customized\n     * @return the response from the invalidate API key call\n     * @throws IOException in case there is a problem sending the request or parsing back the response\n     */"
			},
			{
				"signature": "public DelegatePkiAuthenticationResponse delegatePkiAuthentication(DelegatePkiAuthenticationRequest request, RequestOptions options)        throws IOException",
				"documentation": "/**\n     * Get an Elasticsearch access token from an {@code X509Certificate} chain. The certificate chain is that of the client from a mutually\n     * authenticated TLS session, and it is validated by the PKI realms with {@code delegation.enabled} toggled to {@code true}.\u003cbr\u003e\n     * See \u003ca href=\"https://www.elastic.co/guide/en/elasticsearch/reference/current/security-api-delegate-pki-authentication.html\"\u003e the\n     * docs\u003c/a\u003e for more details.\n     *\n     * @param request the request containing the certificate chain\n     * @param options the request options (e.g. headers), use {@link RequestOptions#DEFAULT} if nothing needs to be customized\n     * @return the response from the delegate-pki-authentication API key call\n     * @throws IOException in case there is a problem sending the request or parsing back the response\n     */"
			}
		],
		"interfaces": []
	},
	{
		"documentation": "",
		"name": "org.elasticsearch.client.SecurityRequestConverters",
		"extends": "",
		"Methods": [
			{
				"signature": "private SecurityRequestConverters()",
				"documentation": ""
			},
			{
				"signature": "static Request clearRealmCache(ClearRealmCacheRequest clearRealmCacheRequest)",
				"documentation": ""
			},
			{
				"signature": "static Request createToken(CreateTokenRequest createTokenRequest) throws IOException",
				"documentation": ""
			},
			{
				"signature": "static Request delegatePkiAuthentication(DelegatePkiAuthenticationRequest delegatePkiAuthenticationRequest) throws IOException",
				"documentation": ""
			},
			{
				"signature": "static Request invalidateToken(InvalidateTokenRequest invalidateTokenRequest) throws IOException",
				"documentation": ""
			},
			{
				"signature": "static Request getApiKey(final GetApiKeyRequest getApiKeyRequest) throws IOException",
				"documentation": ""
			},
			{
				"signature": "static Request invalidateApiKey(final InvalidateApiKeyRequest invalidateApiKeyRequest) throws IOException",
				"documentation": ""
			}
		],
		"interfaces": []
	},
	{
		"documentation": "/**\n * A wrapper for the {@link RestHighLevelClient} that provides methods for accessing the Snapshot API.\n * \u003cp\u003e\n * See \u003ca href=\"https://www.elastic.co/guide/en/elasticsearch/reference/current/modules-snapshots.html\"\u003eSnapshot API on elastic.co\u003c/a\u003e\n *\n * @deprecated The High Level Rest Client is deprecated in favor of the\n * \u003ca href=\"https://www.elastic.co/guide/en/elasticsearch/client/java-api-client/current/introduction.html\"\u003e\n * Elasticsearch Java API Client\u003c/a\u003e\n */",
		"name": "org.elasticsearch.client.SnapshotClient",
		"extends": "",
		"Methods": [
			{
				"signature": "SnapshotClient(RestHighLevelClient restHighLevelClient)",
				"documentation": "/**\n * A wrapper for the {@link RestHighLevelClient} that provides methods for accessing the Snapshot API.\n * \u003cp\u003e\n * See \u003ca href=\"https://www.elastic.co/guide/en/elasticsearch/reference/current/modules-snapshots.html\"\u003eSnapshot API on elastic.co\u003c/a\u003e\n *\n * @deprecated The High Level Rest Client is deprecated in favor of the\n * \u003ca href=\"https://www.elastic.co/guide/en/elasticsearch/client/java-api-client/current/introduction.html\"\u003e\n * Elasticsearch Java API Client\u003c/a\u003e\n */"
			},
			{
				"signature": "public GetRepositoriesResponse getRepository(GetRepositoriesRequest getRepositoriesRequest, RequestOptions options) throws IOException",
				"documentation": "/**\n     * Gets a list of snapshot repositories. If the list of repositories is empty or it contains a single element \"_all\", all\n     * registered repositories are returned.\n     * See \u003ca href=\"https://www.elastic.co/guide/en/elasticsearch/reference/current/modules-snapshots.html\"\u003e Snapshot and Restore\n     * API on elastic.co\u003c/a\u003e\n     * @param getRepositoriesRequest the request\n     * @param options the request options (e.g. headers), use {@link RequestOptions#DEFAULT} if nothing needs to be customized\n     * @return the response\n     * @throws IOException in case there is a problem sending the request or parsing back the response\n     */"
			},
			{
				"signature": "public Cancellable getRepositoryAsync(        GetRepositoriesRequest getRepositoriesRequest,        RequestOptions options,        ActionListener\u003cGetRepositoriesResponse\u003e listener    )",
				"documentation": "/**\n     * Asynchronously gets a list of snapshot repositories. If the list of repositories is empty or it contains a single element \"_all\", all\n     * registered repositories are returned.\n     * See \u003ca href=\"https://www.elastic.co/guide/en/elasticsearch/reference/current/modules-snapshots.html\"\u003e Snapshot and Restore\n     * API on elastic.co\u003c/a\u003e\n     * @param getRepositoriesRequest the request\n     * @param options the request options (e.g. headers), use {@link RequestOptions#DEFAULT} if nothing needs to be customized\n     * @param listener the listener to be notified upon request completion\n     * @return cancellable that may be used to cancel the request\n     */"
			},
			{
				"signature": "public AcknowledgedResponse createRepository(PutRepositoryRequest putRepositoryRequest, RequestOptions options) throws IOException",
				"documentation": "/**\n     * Creates a snapshot repository.\n     * See \u003ca href=\"https://www.elastic.co/guide/en/elasticsearch/reference/current/modules-snapshots.html\"\u003e Snapshot and Restore\n     * API on elastic.co\u003c/a\u003e\n     * @param putRepositoryRequest the request\n     * @param options the request options (e.g. headers), use {@link RequestOptions#DEFAULT} if nothing needs to be customized\n     * @return the response\n     * @throws IOException in case there is a problem sending the request or parsing back the response\n     */"
			},
			{
				"signature": "public Cancellable createRepositoryAsync(        PutRepositoryRequest putRepositoryRequest,        RequestOptions options,        ActionListener\u003cAcknowledgedResponse\u003e listener    )",
				"documentation": "/**\n     * Asynchronously creates a snapshot repository.\n     * See \u003ca href=\"https://www.elastic.co/guide/en/elasticsearch/reference/current/modules-snapshots.html\"\u003e Snapshot and Restore\n     * API on elastic.co\u003c/a\u003e\n     * @param putRepositoryRequest the request\n     * @param options the request options (e.g. headers), use {@link RequestOptions#DEFAULT} if nothing needs to be customized\n     * @param listener the listener to be notified upon request completion\n     * @return cancellable that may be used to cancel the request\n     */"
			},
			{
				"signature": "public AcknowledgedResponse deleteRepository(DeleteRepositoryRequest deleteRepositoryRequest, RequestOptions options)        throws IOException",
				"documentation": "/**\n     * Deletes a snapshot repository.\n     * See \u003ca href=\"https://www.elastic.co/guide/en/elasticsearch/reference/current/modules-snapshots.html\"\u003e Snapshot and Restore\n     * API on elastic.co\u003c/a\u003e\n     * @param deleteRepositoryRequest the request\n     * @param options the request options (e.g. headers), use {@link RequestOptions#DEFAULT} if nothing needs to be customized\n     * @return the response\n     * @throws IOException in case there is a problem sending the request or parsing back the response\n     */"
			},
			{
				"signature": "public Cancellable deleteRepositoryAsync(        DeleteRepositoryRequest deleteRepositoryRequest,        RequestOptions options,        ActionListener\u003cAcknowledgedResponse\u003e listener    )",
				"documentation": "/**\n     * Asynchronously deletes a snapshot repository.\n     * See \u003ca href=\"https://www.elastic.co/guide/en/elasticsearch/reference/current/modules-snapshots.html\"\u003e Snapshot and Restore\n     * API on elastic.co\u003c/a\u003e\n     * @param deleteRepositoryRequest the request\n     * @param options the request options (e.g. headers), use {@link RequestOptions#DEFAULT} if nothing needs to be customized\n     * @param listener the listener to be notified upon request completion\n     * @return cancellable that may be used to cancel the request\n     */"
			},
			{
				"signature": "public VerifyRepositoryResponse verifyRepository(VerifyRepositoryRequest verifyRepositoryRequest, RequestOptions options)        throws IOException",
				"documentation": "/**\n     * Verifies a snapshot repository.\n     * See \u003ca href=\"https://www.elastic.co/guide/en/elasticsearch/reference/current/modules-snapshots.html\"\u003e Snapshot and Restore\n     * API on elastic.co\u003c/a\u003e\n     * @param verifyRepositoryRequest the request\n     * @param options the request options (e.g. headers), use {@link RequestOptions#DEFAULT} if nothing needs to be customized\n     * @return the response\n     * @throws IOException in case there is a problem sending the request or parsing back the response\n     */"
			},
			{
				"signature": "public Cancellable verifyRepositoryAsync(        VerifyRepositoryRequest verifyRepositoryRequest,        RequestOptions options,        ActionListener\u003cVerifyRepositoryResponse\u003e listener    )",
				"documentation": "/**\n     * Asynchronously verifies a snapshot repository.\n     * See \u003ca href=\"https://www.elastic.co/guide/en/elasticsearch/reference/current/modules-snapshots.html\"\u003e Snapshot and Restore\n     * API on elastic.co\u003c/a\u003e\n     * @param verifyRepositoryRequest the request\n     * @param options the request options (e.g. headers), use {@link RequestOptions#DEFAULT} if nothing needs to be customized\n     * @param listener the listener to be notified upon request completion\n     * @return cancellable that may be used to cancel the request\n     */"
			},
			{
				"signature": "public CleanupRepositoryResponse cleanupRepository(CleanupRepositoryRequest cleanupRepositoryRequest, RequestOptions options)        throws IOException",
				"documentation": "/**\n     * Cleans up a snapshot repository.\n     * See \u003ca href=\"https://www.elastic.co/guide/en/elasticsearch/reference/current/modules-snapshots.html\"\u003e Snapshot and Restore\n     * API on elastic.co\u003c/a\u003e\n     * @param cleanupRepositoryRequest the request\n     * @param options the request options (e.g. headers), use {@link RequestOptions#DEFAULT} if nothing needs to be customized\n     * @return the response\n     * @throws IOException in case there is a problem sending the request or parsing back the response\n     */"
			},
			{
				"signature": "public Cancellable cleanupRepositoryAsync(        CleanupRepositoryRequest cleanupRepositoryRequest,        RequestOptions options,        ActionListener\u003cCleanupRepositoryResponse\u003e listener    )",
				"documentation": "/**\n     * Asynchronously cleans up a snapshot repository.\n     * See \u003ca href=\"https://www.elastic.co/guide/en/elasticsearch/reference/current/modules-snapshots.html\"\u003e Snapshot and Restore\n     * API on elastic.co\u003c/a\u003e\n     * @param cleanupRepositoryRequest the request\n     * @param options the request options (e.g. headers), use {@link RequestOptions#DEFAULT} if nothing needs to be customized\n     * @param listener the listener to be notified upon request completion\n     * @return cancellable that may be used to cancel the request\n     */"
			},
			{
				"signature": "public CreateSnapshotResponse create(CreateSnapshotRequest createSnapshotRequest, RequestOptions options) throws IOException",
				"documentation": "/**\n     * Creates a snapshot.\n     * \u003cp\u003e\n     * See \u003ca href=\"https://www.elastic.co/guide/en/elasticsearch/reference/current/modules-snapshots.html\"\u003e Snapshot and Restore\n     * API on elastic.co\u003c/a\u003e\n     */"
			},
			{
				"signature": "public Cancellable createAsync(        CreateSnapshotRequest createSnapshotRequest,        RequestOptions options,        ActionListener\u003cCreateSnapshotResponse\u003e listener    )",
				"documentation": "/**\n     * Asynchronously creates a snapshot.\n     * \u003cp\u003e\n     * See \u003ca href=\"https://www.elastic.co/guide/en/elasticsearch/reference/current/modules-snapshots.html\"\u003e Snapshot and Restore\n     * API on elastic.co\u003c/a\u003e\n     * @return cancellable that may be used to cancel the request\n     */"
			},
			{
				"signature": "public AcknowledgedResponse clone(CloneSnapshotRequest cloneSnapshotRequest, RequestOptions options) throws IOException",
				"documentation": "/**\n     * Clones a snapshot.\n     * \u003cp\u003e\n     * See \u003ca href=\"https://www.elastic.co/guide/en/elasticsearch/reference/current/modules-snapshots.html\"\u003e Snapshot and Restore\n     * API on elastic.co\u003c/a\u003e\n     */"
			},
			{
				"signature": "public Cancellable cloneAsync(        CloneSnapshotRequest cloneSnapshotRequest,        RequestOptions options,        ActionListener\u003cAcknowledgedResponse\u003e listener    )",
				"documentation": "/**\n     * Asynchronously clones a snapshot.\n     * \u003cp\u003e\n     * See \u003ca href=\"https://www.elastic.co/guide/en/elasticsearch/reference/current/modules-snapshots.html\"\u003e Snapshot and Restore\n     * API on elastic.co\u003c/a\u003e\n     * @return cancellable that may be used to cancel the request\n     */"
			},
			{
				"signature": "public GetSnapshotsResponse get(GetSnapshotsRequest getSnapshotsRequest, RequestOptions options) throws IOException",
				"documentation": "/**\n     * Get snapshots.\n     * See \u003ca href=\"https://www.elastic.co/guide/en/elasticsearch/reference/current/modules-snapshots.html\"\u003e Snapshot and Restore\n     * API on elastic.co\u003c/a\u003e\n     *\n     * @param getSnapshotsRequest the request\n     * @param options the request options (e.g. headers), use {@link RequestOptions#DEFAULT} if nothing needs to be customized\n     * @return the response\n     * @throws IOException in case there is a problem sending the request or parsing back the response\n     */"
			},
			{
				"signature": "public Cancellable getAsync(        GetSnapshotsRequest getSnapshotsRequest,        RequestOptions options,        ActionListener\u003cGetSnapshotsResponse\u003e listener    )",
				"documentation": "/**\n     * Asynchronously get snapshots.\n     * See \u003ca href=\"https://www.elastic.co/guide/en/elasticsearch/reference/current/modules-snapshots.html\"\u003e Snapshot and Restore\n     * API on elastic.co\u003c/a\u003e\n     *  @param getSnapshotsRequest the request\n     * @param options the request options (e.g. headers), use {@link RequestOptions#DEFAULT} if nothing needs to be customized\n     * @param listener the listener to be notified upon request completion\n     * @return cancellable that may be used to cancel the request\n     */"
			},
			{
				"signature": "public SnapshotsStatusResponse status(SnapshotsStatusRequest snapshotsStatusRequest, RequestOptions options) throws IOException",
				"documentation": "/**\n     * Gets the status of requested snapshots.\n     * See \u003ca href=\"https://www.elastic.co/guide/en/elasticsearch/reference/current/modules-snapshots.html\"\u003e Snapshot and Restore\n     * API on elastic.co\u003c/a\u003e\n     * @param snapshotsStatusRequest the request\n     * @param options the request options (e.g. headers), use {@link RequestOptions#DEFAULT} if nothing needs to be customized\n     * @return the response\n     * @throws IOException in case there is a problem sending the request or parsing back the response\n     */"
			},
			{
				"signature": "public Cancellable statusAsync(        SnapshotsStatusRequest snapshotsStatusRequest,        RequestOptions options,        ActionListener\u003cSnapshotsStatusResponse\u003e listener    )",
				"documentation": "/**\n     * Asynchronously gets the status of requested snapshots.\n     * See \u003ca href=\"https://www.elastic.co/guide/en/elasticsearch/reference/current/modules-snapshots.html\"\u003e Snapshot and Restore\n     * API on elastic.co\u003c/a\u003e\n     * @param snapshotsStatusRequest the request\n     * @param options the request options (e.g. headers), use {@link RequestOptions#DEFAULT} if nothing needs to be customized\n     * @param listener the listener to be notified upon request completion\n     * @return cancellable that may be used to cancel the request\n     */"
			},
			{
				"signature": "public RestoreSnapshotResponse restore(RestoreSnapshotRequest restoreSnapshotRequest, RequestOptions options) throws IOException",
				"documentation": "/**\n     * Restores a snapshot.\n     * See \u003ca href=\"https://www.elastic.co/guide/en/elasticsearch/reference/current/modules-snapshots.html\"\u003e Snapshot and Restore\n     * API on elastic.co\u003c/a\u003e\n     *\n     * @param restoreSnapshotRequest the request\n     * @param options the request options (e.g. headers), use {@link RequestOptions#DEFAULT} if nothing needs to be customized\n     * @return the response\n     * @throws IOException in case there is a problem sending the request or parsing back the response\n     */"
			},
			{
				"signature": "public Cancellable restoreAsync(        RestoreSnapshotRequest restoreSnapshotRequest,        RequestOptions options,        ActionListener\u003cRestoreSnapshotResponse\u003e listener    )",
				"documentation": "/**\n     * Asynchronously restores a snapshot.\n     * See \u003ca href=\"https://www.elastic.co/guide/en/elasticsearch/reference/current/modules-snapshots.html\"\u003e Snapshot and Restore\n     * API on elastic.co\u003c/a\u003e\n     *\n     * @param restoreSnapshotRequest the request\n     * @param options the request options (e.g. headers), use {@link RequestOptions#DEFAULT} if nothing needs to be customized\n     * @param listener the listener to be notified upon request completion\n     * @return cancellable that may be used to cancel the request\n     */"
			},
			{
				"signature": "public AcknowledgedResponse delete(DeleteSnapshotRequest deleteSnapshotRequest, RequestOptions options) throws IOException",
				"documentation": "/**\n     * Deletes a snapshot.\n     * See \u003ca href=\"https://www.elastic.co/guide/en/elasticsearch/reference/current/modules-snapshots.html\"\u003e Snapshot and Restore\n     * API on elastic.co\u003c/a\u003e\n     *\n     * @param deleteSnapshotRequest the request\n     * @param options the request options (e.g. headers), use {@link RequestOptions#DEFAULT} if nothing needs to be customized\n     * @return the response\n     * @throws IOException in case there is a problem sending the request or parsing back the response\n     */"
			},
			{
				"signature": "public Cancellable deleteAsync(        DeleteSnapshotRequest deleteSnapshotRequest,        RequestOptions options,        ActionListener\u003cAcknowledgedResponse\u003e listener    )",
				"documentation": "/**\n     * Asynchronously deletes a snapshot.\n     * See \u003ca href=\"https://www.elastic.co/guide/en/elasticsearch/reference/current/modules-snapshots.html\"\u003e Snapshot and Restore\n     * API on elastic.co\u003c/a\u003e\n     *\n     * @param deleteSnapshotRequest the request\n     * @param options the request options (e.g. headers), use {@link RequestOptions#DEFAULT} if nothing needs to be customized\n     * @param listener the listener to be notified upon request completion\n     * @return cancellable that may be used to cancel the request\n     */"
			}
		],
		"interfaces": []
	},
	{
		"documentation": "",
		"name": "org.elasticsearch.client.SnapshotRequestConverters",
		"extends": "",
		"Methods": [
			{
				"signature": "private SnapshotRequestConverters()",
				"documentation": ""
			},
			{
				"signature": "static Request getRepositories(GetRepositoriesRequest getRepositoriesRequest)",
				"documentation": ""
			},
			{
				"signature": "static Request createRepository(PutRepositoryRequest putRepositoryRequest) throws IOException",
				"documentation": ""
			},
			{
				"signature": "static Request deleteRepository(DeleteRepositoryRequest deleteRepositoryRequest)",
				"documentation": ""
			},
			{
				"signature": "static Request verifyRepository(VerifyRepositoryRequest verifyRepositoryRequest)",
				"documentation": ""
			},
			{
				"signature": "static Request cleanupRepository(CleanupRepositoryRequest cleanupRepositoryRequest)",
				"documentation": ""
			},
			{
				"signature": "static Request createSnapshot(CreateSnapshotRequest createSnapshotRequest) throws IOException",
				"documentation": ""
			},
			{
				"signature": "static Request cloneSnapshot(CloneSnapshotRequest cloneSnapshotRequest) throws IOException",
				"documentation": ""
			},
			{
				"signature": "static Request getSnapshots(GetSnapshotsRequest getSnapshotsRequest)",
				"documentation": ""
			},
			{
				"signature": "static Request snapshotsStatus(SnapshotsStatusRequest snapshotsStatusRequest)",
				"documentation": ""
			},
			{
				"signature": "static Request restoreSnapshot(RestoreSnapshotRequest restoreSnapshotRequest) throws IOException",
				"documentation": ""
			},
			{
				"signature": "static Request deleteSnapshot(DeleteSnapshotRequest deleteSnapshotRequest)",
				"documentation": ""
			}
		],
		"interfaces": []
	},
	{
		"documentation": "/**\n * A base request for any requests that supply timeouts.\n *\n * Please note, any requests that use a ackTimeout should set timeout as they\n * represent the same backing field on the server.\n */",
		"name": "org.elasticsearch.client.TimedRequest",
		"extends": "",
		"Methods": [
			{
				"signature": "public void setTimeout(TimeValue timeout)",
				"documentation": "/**\n     * Sets the timeout to wait for the all the nodes to acknowledge\n     * @param timeout timeout as a {@link TimeValue}\n     */"
			},
			{
				"signature": "public void setMasterTimeout(TimeValue masterTimeout)",
				"documentation": "/**\n     * Sets the timeout to connect to the master node\n     * @param masterTimeout timeout as a {@link TimeValue}\n     */"
			},
			{
				"signature": "public TimeValue timeout()",
				"documentation": "/**\n     * Returns the request timeout\n     */"
			},
			{
				"signature": "public TimeValue masterNodeTimeout()",
				"documentation": "/**\n     * Returns the timeout for the request to be completed on the master node\n     */"
			}
		],
		"interfaces": [
			"Validatable"
		]
	},
	{
		"documentation": "/**\n * @deprecated The High Level Rest Client is deprecated in favor of the\n * \u003ca href=\"https://www.elastic.co/guide/en/elasticsearch/client/java-api-client/current/introduction.html\"\u003e\n * Elasticsearch Java API Client\u003c/a\u003e\n */",
		"name": "org.elasticsearch.client.TransformClient",
		"extends": "",
		"Methods": [
			{
				"signature": "TransformClient(RestHighLevelClient restHighLevelClient)",
				"documentation": "/**\n * @deprecated The High Level Rest Client is deprecated in favor of the\n * \u003ca href=\"https://www.elastic.co/guide/en/elasticsearch/client/java-api-client/current/introduction.html\"\u003e\n * Elasticsearch Java API Client\u003c/a\u003e\n */"
			},
			{
				"signature": "public AcknowledgedResponse putTransform(PutTransformRequest request, RequestOptions options) throws IOException",
				"documentation": "/**\n     * Creates a new transform\n     * \u003cp\u003e\n     * For additional info\n     * see \u003ca href=\"https://www.elastic.co/guide/en/elasticsearch/reference/current/put-transform.html\"\u003e\n     *     Create transform documentation\u003c/a\u003e\n     *\n     * @param request The PutTransformRequest containing the\n     * {@link org.elasticsearch.client.transform.transforms.TransformConfig}.\n     * @param options Additional request options (e.g. headers), use {@link RequestOptions#DEFAULT} if nothing needs to be customized\n     * @return An AcknowledgedResponse object indicating request success\n     * @throws IOException when there is a serialization issue sending the request or receiving the response\n     */"
			},
			{
				"signature": "public Cancellable putTransformAsync(        PutTransformRequest request,        RequestOptions options,        ActionListener\u003cAcknowledgedResponse\u003e listener    )",
				"documentation": "/**\n     * Creates a new transform asynchronously and notifies listener on completion\n     * \u003cp\u003e\n     * For additional info\n     * see \u003ca href=\"https://www.elastic.co/guide/en/elasticsearch/reference/current/put-transform.html\"\u003e\n     *     Create transform documentation\u003c/a\u003e\n     * @param request The PutTransformRequest containing the\n     * {@link org.elasticsearch.client.transform.transforms.TransformConfig}.\n     * @param options Additional request options (e.g. headers), use {@link RequestOptions#DEFAULT} if nothing needs to be customized\n     * @param listener Listener to be notified upon request completion\n     * @return cancellable that may be used to cancel the request\n     */"
			},
			{
				"signature": "public UpdateTransformResponse updateTransform(UpdateTransformRequest request, RequestOptions options) throws IOException",
				"documentation": "/**\n     * Updates an existing transform\n     * \u003cp\u003e\n     * For additional info\n     * see \u003ca href=\"https://www.elastic.co/guide/en/elasticsearch/reference/current/update-transform.html\"\u003e\n     *     Create transform documentation\u003c/a\u003e\n     *\n     * @param request The UpdateTransformRequest containing the\n     * {@link org.elasticsearch.client.transform.transforms.TransformConfigUpdate}.\n     * @param options Additional request options (e.g. headers), use {@link RequestOptions#DEFAULT} if nothing needs to be customized\n     * @return An UpdateTransformResponse object containing the updated configuration\n     * @throws IOException when there is a serialization issue sending the request or receiving the response\n     */"
			},
			{
				"signature": "public Cancellable updateTransformAsync(        UpdateTransformRequest request,        RequestOptions options,        ActionListener\u003cUpdateTransformResponse\u003e listener    )",
				"documentation": "/**\n     * Updates an existing transform asynchronously and notifies listener on completion\n     * \u003cp\u003e\n     * For additional info\n     * see \u003ca href=\"https://www.elastic.co/guide/en/elasticsearch/reference/current/update-transform.html\"\u003e\n     *     Create transform documentation\u003c/a\u003e\n     * @param request The UpdateTransformRequest containing the\n     * {@link org.elasticsearch.client.transform.transforms.TransformConfigUpdate}.\n     * @param options Additional request options (e.g. headers), use {@link RequestOptions#DEFAULT} if nothing needs to be customized\n     * @param listener Listener to be notified upon request completion\n     * @return cancellable that may be used to cancel the request\n     */"
			},
			{
				"signature": "public GetTransformStatsResponse getTransformStats(GetTransformStatsRequest request, RequestOptions options) throws IOException",
				"documentation": "/**\n     * Get the running statistics of a transform\n     * \u003cp\u003e\n     * For additional info\n     * see \u003ca href=\"https://www.elastic.co/guide/en/elasticsearch/reference/current/get-transform-stats.html\"\u003e\n     *     Get transform stats documentation\u003c/a\u003e\n     *\n     * @param request Specifies which transforms to get the stats for\n     * @param options Additional request options (e.g. headers), use {@link RequestOptions#DEFAULT} if nothing needs to be customized\n     * @return The transform stats\n     * @throws IOException when there is a serialization issue sending the request or receiving the response\n     */"
			},
			{
				"signature": "public Cancellable getTransformStatsAsync(        GetTransformStatsRequest request,        RequestOptions options,        ActionListener\u003cGetTransformStatsResponse\u003e listener    )",
				"documentation": "/**\n     * Get the running statistics of a transform asynchronously and notifies listener on completion\n     * \u003cp\u003e\n     * For additional info\n     * see \u003ca href=\"https://www.elastic.co/guide/en/elasticsearch/reference/current/get-transform-stats.html\"\u003e\n     *     Get transform stats documentation\u003c/a\u003e\n     * @param request Specifies which transforms to get the stats for\n     * @param options Additional request options (e.g. headers), use {@link RequestOptions#DEFAULT} if nothing needs to be customized\n     * @param listener Listener to be notified upon request completion\n     * @return cancellable that may be used to cancel the request\n     */"
			},
			{
				"signature": "public AcknowledgedResponse deleteTransform(DeleteTransformRequest request, RequestOptions options) throws IOException",
				"documentation": "/**\n     * Delete a transform\n     * \u003cp\u003e\n     * For additional info\n     * see \u003ca href=\"https://www.elastic.co/guide/en/elasticsearch/reference/current/delete-transform.html\"\u003e\n     *     Delete transform documentation\u003c/a\u003e\n     *\n     * @param request The delete transform request\n     * @param options Additional request options (e.g. headers), use {@link RequestOptions#DEFAULT} if nothing needs to be customized\n     * @return An AcknowledgedResponse object indicating request success\n     * @throws IOException when there is a serialization issue sending the request or receiving the response\n     */"
			},
			{
				"signature": "public Cancellable deleteTransformAsync(        DeleteTransformRequest request,        RequestOptions options,        ActionListener\u003cAcknowledgedResponse\u003e listener    )",
				"documentation": "/**\n     * Delete a transform asynchronously and notifies listener on completion\n     * \u003cp\u003e\n     * For additional info\n     * see \u003ca href=\"https://www.elastic.co/guide/en/elasticsearch/reference/current/delete-transform.html\"\u003e\n     *     Delete transform documentation\u003c/a\u003e\n     * @param request The delete transform request\n     * @param options Additional request options (e.g. headers), use {@link RequestOptions#DEFAULT} if nothing needs to be customized\n     * @param listener Listener to be notified upon request completion\n     * @return cancellable that may be used to cancel the request\n     */"
			},
			{
				"signature": "public PreviewTransformResponse previewTransform(PreviewTransformRequest request, RequestOptions options) throws IOException",
				"documentation": "/**\n     * Preview the result of a transform\n     * \u003cp\u003e\n     * For additional info\n     * see \u003ca href=\"https://www.elastic.co/guide/en/elasticsearch/reference/current/preview-transform.html\"\u003e\n     *     Preview transform documentation\u003c/a\u003e\n     *\n     * @param request The preview transform request\n     * @param options Additional request options (e.g. headers), use {@link RequestOptions#DEFAULT} if nothing needs to be customized\n     * @return A response containing the results of the applied transform\n     * @throws IOException when there is a serialization issue sending the request or receiving the response\n     */"
			},
			{
				"signature": "public Cancellable previewTransformAsync(        PreviewTransformRequest request,        RequestOptions options,        ActionListener\u003cPreviewTransformResponse\u003e listener    )",
				"documentation": "/**\n     * Preview the result of a transform asynchronously and notifies listener on completion\n     * \u003cp\u003e\n     * see \u003ca href=\"https://www.elastic.co/guide/en/elasticsearch/reference/current/preview-transform.html\"\u003e\n     *     Preview transform documentation\u003c/a\u003e\n     * @param request The preview transform request\n     * @param options Additional request options (e.g. headers), use {@link RequestOptions#DEFAULT} if nothing needs to be customized\n     * @param listener Listener to be notified upon request completion\n     * @return cancellable that may be used to cancel the request\n     */"
			},
			{
				"signature": "public StartTransformResponse startTransform(StartTransformRequest request, RequestOptions options) throws IOException",
				"documentation": "/**\n     * Start a transform\n     * \u003cp\u003e\n     * For additional info\n     * see \u003ca href=\"https://www.elastic.co/guide/en/elasticsearch/reference/current/start-transform.html\"\u003e\n     *     Start transform documentation\u003c/a\u003e\n     *\n     * @param request The start transform request\n     * @param options Additional request options (e.g. headers), use {@link RequestOptions#DEFAULT} if nothing needs to be customized\n     * @return A response object indicating request success\n     * @throws IOException when there is a serialization issue sending the request or receiving the response\n     */"
			},
			{
				"signature": "public Cancellable startTransformAsync(        StartTransformRequest request,        RequestOptions options,        ActionListener\u003cStartTransformResponse\u003e listener    )",
				"documentation": "/**\n     * Start a transform asynchronously and notifies listener on completion\n     * \u003cp\u003e\n     * For additional info\n     * see \u003ca href=\"https://www.elastic.co/guide/en/elasticsearch/reference/current/start-transform.html\"\u003e\n     *     Start transform documentation\u003c/a\u003e\n     * @param request The start transform request\n     * @param options Additional request options (e.g. headers), use {@link RequestOptions#DEFAULT} if nothing needs to be customized\n     * @param listener Listener to be notified upon request completion\n     * @return cancellable that may be used to cancel the request\n     */"
			},
			{
				"signature": "public StopTransformResponse stopTransform(StopTransformRequest request, RequestOptions options) throws IOException",
				"documentation": "/**\n     * Stop a transform\n     * \u003cp\u003e\n     * For additional info\n     * see \u003ca href=\"https://www.elastic.co/guide/en/elasticsearch/reference/current/stop-transform.html\"\u003e\n     *     Stop transform documentation\u003c/a\u003e\n     *\n     * @param request The stop transform request\n     * @param options Additional request options (e.g. headers), use {@link RequestOptions#DEFAULT} if nothing needs to be customized\n     * @return A response object indicating request success\n     * @throws IOException when there is a serialization issue sending the request or receiving the response\n     */"
			},
			{
				"signature": "public Cancellable stopTransformAsync(        StopTransformRequest request,        RequestOptions options,        ActionListener\u003cStopTransformResponse\u003e listener    )",
				"documentation": "/**\n     * Stop a transform asynchronously and notifies listener on completion\n     * \u003cp\u003e\n     * For additional info\n     * see \u003ca href=\"https://www.elastic.co/guide/en/elasticsearch/reference/current/stop-transform.html\"\u003e\n     *     Stop transform documentation\u003c/a\u003e\n     * @param request The stop transform request\n     * @param options Additional request options (e.g. headers), use {@link RequestOptions#DEFAULT} if nothing needs to be customized\n     * @param listener Listener to be notified upon request completion\n     * @return cancellable that may be used to cancel the request\n     */"
			},
			{
				"signature": "public GetTransformResponse getTransform(GetTransformRequest request, RequestOptions options) throws IOException",
				"documentation": "/**\n     * Get one or more transform configurations\n     * \u003cp\u003e\n     * For additional info\n     * see \u003ca href=\"https://www.elastic.co/guide/en/elasticsearch/reference/current/get-transform.html\"\u003e\n     *     Get transform documentation\u003c/a\u003e\n     *\n     * @param request The get transform request\n     * @param options Additional request options (e.g. headers), use {@link RequestOptions#DEFAULT} if nothing needs to be customized\n     * @return An GetTransformResponse containing the requested transforms\n     * @throws IOException when there is a serialization issue sending the request or receiving the response\n     */"
			},
			{
				"signature": "public Cancellable getTransformAsync(        GetTransformRequest request,        RequestOptions options,        ActionListener\u003cGetTransformResponse\u003e listener    )",
				"documentation": "/**\n     * Get one or more transform configurations asynchronously and notifies listener on completion\n     * \u003cp\u003e\n     * For additional info\n     * see \u003ca href=\"https://www.elastic.co/guide/en/elasticsearch/reference/current/get-transform.html\"\u003e\n     *     Get data transform documentation\u003c/a\u003e\n     * @param request The get transform request\n     * @param options Additional request options (e.g. headers), use {@link RequestOptions#DEFAULT} if nothing needs to be customized\n     * @param listener Listener to be notified upon request completion\n     * @return cancellable that may be used to cancel the request\n     */"
			}
		],
		"interfaces": []
	}
]
