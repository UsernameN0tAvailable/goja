[
	{
		"documentation": "",
		"name": "org.elasticsearch.benchmark.bytes.BytesArrayReadLongBenchmark",
		"extends": "",
		"Methods": [
			{
				"signature": "public void initResults() throws IOException",
				"documentation": ""
			},
			{
				"signature": "public long readLong() throws IOException",
				"documentation": ""
			}
		],
		"interfaces": []
	},
	{
		"documentation": "",
		"name": "org.elasticsearch.benchmark.bytes.BytesArrayReadVLongBenchmark",
		"extends": "",
		"Methods": [
			{
				"signature": "public void initResults() throws IOException",
				"documentation": ""
			},
			{
				"signature": "public long readVLong() throws IOException",
				"documentation": ""
			}
		],
		"interfaces": []
	},
	{
		"documentation": "",
		"name": "org.elasticsearch.benchmark.bytes.PagedBytesReferenceReadLongBenchmark",
		"extends": "",
		"Methods": [
			{
				"signature": "public void initResults() throws IOException",
				"documentation": ""
			},
			{
				"signature": "public long readLong() throws IOException",
				"documentation": ""
			}
		],
		"interfaces": []
	},
	{
		"documentation": "",
		"name": "org.elasticsearch.benchmark.bytes.PagedBytesReferenceReadVIntBenchmark",
		"extends": "",
		"Methods": [
			{
				"signature": "public void initResults() throws IOException",
				"documentation": ""
			},
			{
				"signature": "public int readVInt() throws IOException",
				"documentation": ""
			}
		],
		"interfaces": []
	},
	{
		"documentation": "",
		"name": "org.elasticsearch.benchmark.bytes.PagedBytesReferenceReadVLongBenchmark",
		"extends": "",
		"Methods": [
			{
				"signature": "public void initResults() throws IOException",
				"documentation": ""
			},
			{
				"signature": "public long readVLong() throws IOException",
				"documentation": ""
			}
		],
		"interfaces": []
	},
	{
		"documentation": "",
		"name": "org.elasticsearch.benchmark.fs.AvailableIndexFoldersBenchmark",
		"extends": "",
		"Methods": [
			{
				"signature": "public void setup() throws IOException",
				"documentation": ""
			},
			{
				"signature": "public Set\u003cString\u003e availableIndexFolderNaive() throws IOException",
				"documentation": ""
			},
			{
				"signature": "public Set\u003cString\u003e availableIndexFolderOptimized() throws IOException",
				"documentation": ""
			}
		],
		"interfaces": []
	},
	{
		"documentation": "",
		"name": "org.elasticsearch.benchmark.indices.breaker.MemoryStatsBenchmark",
		"extends": "",
		"Methods": [
			{
				"signature": "public void baseline()",
				"documentation": ""
			},
			{
				"signature": "public long getMemoryStats_01()",
				"documentation": ""
			},
			{
				"signature": "public long getMemoryStats_02()",
				"documentation": ""
			},
			{
				"signature": "public long getMemoryStats_04()",
				"documentation": ""
			},
			{
				"signature": "public long getMemoryStats_08()",
				"documentation": ""
			},
			{
				"signature": "public long getMemoryStats_16()",
				"documentation": ""
			},
			{
				"signature": "public long getMemoryStats_32()",
				"documentation": ""
			},
			{
				"signature": "public long getMemoryStats_64()",
				"documentation": ""
			}
		],
		"interfaces": []
	},
	{
		"documentation": "",
		"name": "org.elasticsearch.benchmark.indices.common.RoundingBenchmark",
		"extends": "",
		"Methods": [
			{
				"signature": "private static final DateFormatter FORMATTER = DateFormatter.forPattern(\"date_optional_time\");    @Param(",
				"documentation": ""
			},
			{
				"signature": "public void buildDates()",
				"documentation": ""
			},
			{
				"signature": "public void round(Blackhole bh)",
				"documentation": ""
			},
			{
				"signature": "public void nextRoundingValue(Blackhole bh)",
				"documentation": ""
			}
		],
		"interfaces": []
	},
	{
		"documentation": "",
		"name": "org.elasticsearch.benchmark.routing.allocation.AllocationBenchmark",
		"extends": "",
		"Methods": [
			{
				"signature": "public void setUp() throws Exception",
				"documentation": ""
			},
			{
				"signature": "private int toInt(String v)",
				"documentation": ""
			},
			{
				"signature": "public ClusterState measureAllocation()",
				"documentation": ""
			}
		],
		"interfaces": []
	},
	{
		"documentation": "",
		"name": "org.elasticsearch.benchmark.routing.allocation.Allocators",
		"extends": "",
		"Methods": [
			{
				"signature": "private Allocators()",
				"documentation": ""
			},
			{
				"signature": "public static AllocationService createAllocationService(Settings settings)",
				"documentation": ""
			},
			{
				"signature": "public static AllocationService createAllocationService(Settings settings, ClusterSettings clusterSettings)",
				"documentation": ""
			},
			{
				"signature": "public static AllocationDeciders defaultAllocationDeciders(Settings settings, ClusterSettings clusterSettings)",
				"documentation": ""
			},
			{
				"signature": "public static DiscoveryNode newNode(String nodeId, Map\u003cString, String\u003e attributes)",
				"documentation": ""
			}
		],
		"interfaces": []
	},
	{
		"documentation": "",
		"name": "org.elasticsearch.benchmark.routing.allocation.Allocators.NoopGatewayAllocator",
		"extends": "org.elasticsearch.gateway.GatewayAllocator",
		"Methods": [
			{
				"signature": "public void applyStartedShards(List\u003cShardRouting\u003e startedShards, RoutingAllocation allocation)",
				"documentation": ""
			},
			{
				"signature": "public void applyFailedShards(List\u003cFailedShard\u003e failedShards, RoutingAllocation allocation)",
				"documentation": ""
			},
			{
				"signature": "public void allocateUnassigned(            ShardRouting shardRouting,            RoutingAllocation allocation,            UnassignedAllocationHandler unassignedAllocationHandler        )",
				"documentation": ""
			}
		],
		"interfaces": []
	},
	{
		"documentation": "/**\n * A race between Lucene Expressions, Painless, and a hand optimized script\n * implementing a {@link ScriptScoreQuery}.\n */",
		"name": "org.elasticsearch.benchmark.script.ScriptScoreBenchmark",
		"extends": "",
		"Methods": [
			{
				"signature": "public void setupScript()",
				"documentation": ""
			},
			{
				"signature": "public void setupIndex() throws IOException",
				"documentation": ""
			},
			{
				"signature": "public TopDocs benchmark() throws IOException",
				"documentation": ""
			},
			{
				"signature": "private Query scriptScoreQuery(ScoreScript.Factory factory)",
				"documentation": ""
			},
			{
				"signature": "private ScoreScript.Factory bareMetalScript()",
				"documentation": ""
			},
			{
				"signature": "public ScoreScript newInstance(DocReader docReader) throws IOException",
				"documentation": ""
			},
			{
				"signature": "public double execute(ExplanationHolder explanation)",
				"documentation": ""
			},
			{
				"signature": "public void setDocument(int docid)",
				"documentation": ""
			},
			{
				"signature": "public boolean needs_score()",
				"documentation": ""
			}
		],
		"interfaces": []
	},
	{
		"documentation": "",
		"name": "org.elasticsearch.benchmark.search.QueryParserHelperBenchmark",
		"extends": "",
		"Methods": [
			{
				"signature": "public void setup() throws IOException",
				"documentation": ""
			},
			{
				"signature": "private SourceToParse buildDoc(int docId)",
				"documentation": ""
			},
			{
				"signature": "public void tearDown()",
				"documentation": ""
			},
			{
				"signature": "public void expand()",
				"documentation": ""
			},
			{
				"signature": "protected SearchExecutionContext buildSearchExecutionContext()",
				"documentation": ""
			},
			{
				"signature": "protected final MapperService createMapperService(String mappings)",
				"documentation": ""
			},
			{
				"signature": "public \u003cT\u003e T compile(Script script, ScriptContext\u003cT\u003e scriptContext)",
				"documentation": ""
			}
		],
		"interfaces": []
	},
	{
		"documentation": "/**\n * Benchmarks the overhead of constructing {@link Aggregator}s in many\n * parallel threads. Machines with different numbers of cores will see\n * wildly different results running this from running this with more\n * cores seeing more benefits from preallocation.\n */",
		"name": "org.elasticsearch.benchmark.search.aggregations.AggConstructionContentionBenchmark",
		"extends": "",
		"Methods": [
			{
				"signature": "public void setup()",
				"documentation": ""
			},
			{
				"signature": "public void sum() throws IOException",
				"documentation": ""
			},
			{
				"signature": "public void termsSum() throws IOException",
				"documentation": ""
			},
			{
				"signature": "public void termsSixtySums() throws IOException",
				"documentation": ""
			},
			{
				"signature": "private void buildFactories(AggregatorFactories.Builder factories) throws IOException",
				"documentation": ""
			}
		],
		"interfaces": []
	},
	{
		"documentation": "",
		"name": "org.elasticsearch.benchmark.search.aggregations.DummyAggregationContext",
		"extends": "org.elasticsearch.search.aggregations.support.AggregationContext",
		"Methods": [
			{
				"signature": "DummyAggregationContext(long bytesToPreallocate)",
				"documentation": ""
			},
			{
				"signature": "public Query query()",
				"documentation": ""
			},
			{
				"signature": "public Aggregator profileIfEnabled(Aggregator agg) throws IOException",
				"documentation": ""
			},
			{
				"signature": "public boolean profiling()",
				"documentation": ""
			},
			{
				"signature": "public long nowInMillis()",
				"documentation": ""
			},
			{
				"signature": "public Analyzer getNamedAnalyzer(String analyzer)",
				"documentation": ""
			},
			{
				"signature": "public Analyzer buildCustomAnalyzer(            IndexSettings indexSettings,            boolean normalizer,            NameOrDefinition tokenizer,            List\u003cNameOrDefinition\u003e charFilters,            List\u003cNameOrDefinition\u003e tokenFilters        )",
				"documentation": ""
			},
			{
				"signature": "protected IndexFieldData\u003c?\u003e buildFieldData(MappedFieldType ft)",
				"documentation": ""
			},
			{
				"signature": "public MappedFieldType getFieldType(String path)",
				"documentation": ""
			},
			{
				"signature": "public Set\u003cString\u003e getMatchingFieldNames(String pattern)",
				"documentation": ""
			},
			{
				"signature": "public boolean isFieldMapped(String field)",
				"documentation": ""
			},
			{
				"signature": "public \u003cFactoryType\u003e FactoryType compile(Script script, ScriptContext\u003cFactoryType\u003e context)",
				"documentation": ""
			},
			{
				"signature": "public SearchLookup lookup()",
				"documentation": ""
			},
			{
				"signature": "public ValuesSourceRegistry getValuesSourceRegistry()",
				"documentation": ""
			},
			{
				"signature": "public BigArrays bigArrays()",
				"documentation": ""
			},
			{
				"signature": "public IndexSearcher searcher()",
				"documentation": ""
			},
			{
				"signature": "public Query buildQuery(QueryBuilder builder) throws IOException",
				"documentation": ""
			},
			{
				"signature": "public Query filterQuery(Query query)",
				"documentation": ""
			},
			{
				"signature": "public IndexSettings getIndexSettings()",
				"documentation": ""
			},
			{
				"signature": "public Optional\u003cSortAndFormats\u003e buildSort(List\u003cSortBuilder\u003c?\u003e\u003e sortBuilders) throws IOException",
				"documentation": ""
			},
			{
				"signature": "public NestedLookup nestedLookup()",
				"documentation": ""
			},
			{
				"signature": "public NestedScope nestedScope()",
				"documentation": ""
			},
			{
				"signature": "public SubSearchContext subSearchContext()",
				"documentation": ""
			},
			{
				"signature": "public void addReleasable(Aggregator aggregator)",
				"documentation": ""
			},
			{
				"signature": "public MultiBucketConsumer multiBucketConsumer()",
				"documentation": ""
			},
			{
				"signature": "public BitsetFilterCache bitsetFilterCache()",
				"documentation": ""
			},
			{
				"signature": "public BucketedSort buildBucketedSort(SortBuilder\u003c?\u003e sort, int size, ExtraData values) throws IOException",
				"documentation": ""
			},
			{
				"signature": "public int shardRandomSeed()",
				"documentation": ""
			},
			{
				"signature": "public long getRelativeTimeInMillis()",
				"documentation": ""
			},
			{
				"signature": "public boolean isCancelled()",
				"documentation": ""
			},
			{
				"signature": "public CircuitBreaker breaker()",
				"documentation": ""
			},
			{
				"signature": "public Analyzer getIndexAnalyzer(Function\u003cString, NamedAnalyzer\u003e unindexedFieldAnalyzer)",
				"documentation": ""
			},
			{
				"signature": "public boolean isCacheable()",
				"documentation": ""
			},
			{
				"signature": "public boolean enableRewriteToFilterByFilter()",
				"documentation": ""
			},
			{
				"signature": "public boolean isInSortOrderExecutionRequired()",
				"documentation": ""
			},
			{
				"signature": "public Set\u003cString\u003e sourcePath(String fullName)",
				"documentation": ""
			},
			{
				"signature": "public void close()",
				"documentation": ""
			}
		],
		"interfaces": []
	},
	{
		"documentation": "",
		"name": "org.elasticsearch.benchmark.search.aggregations.TermsReduceBenchmark",
		"extends": "",
		"Methods": [
			{
				"signature": "public AggregationReduceContext forPartialReduction()",
				"documentation": ""
			},
			{
				"signature": "public AggregationReduceContext forFinalReduction()",
				"documentation": ""
			},
			{
				"signature": "public SearchPhaseController.ReducedQueryPhase reduceAggs(TermsList candidateList) throws Exception",
				"documentation": ""
			}
		],
		"interfaces": []
	},
	{
		"documentation": "",
		"name": "org.elasticsearch.benchmark.search.aggregations.TermsReduceBenchmark.TermsList",
		"extends": "java.util.AbstractList",
		"Methods": [
			{
				"signature": "public void setup()",
				"documentation": ""
			},
			{
				"signature": "private StringTerms newTerms(Random rand, BytesRef[] dict, boolean withNested)",
				"documentation": ""
			},
			{
				"signature": "public InternalAggregations get(int index)",
				"documentation": ""
			},
			{
				"signature": "public int size()",
				"documentation": ""
			}
		],
		"interfaces": []
	},
	{
		"documentation": "",
		"name": "org.elasticsearch.benchmark.search.aggregations.bucket.terms.LongKeyedBucketOrdsBenchmark",
		"extends": "",
		"Methods": [
			{
				"signature": "public void forceLoadClasses(Blackhole bh)",
				"documentation": "/**\n     * Force loading all of the implementations just for extra paranoia's sake.\n     * We really don't want the JVM to be able to eliminate one of them just\n     * because we don't use it in the particular benchmark. That is totally a\n     * thing it'd do. It is sneaky.\n     */"
			},
			{
				"signature": "public void singleBucketIntoSingleImmutableMonmorphicInvocation(Blackhole bh)",
				"documentation": "/**\n     * Emulates a way that we do \u003cstrong\u003enot\u003c/strong\u003e use {@link LongKeyedBucketOrds}\n     * because it is not needed.\n     */"
			},
			{
				"signature": "public void singleBucketIntoSingleImmutableMegamorphicInvocation(Blackhole bh)",
				"documentation": "/**\n     * Emulates the way that most aggregations use {@link LongKeyedBucketOrds}.\n     */"
			},
			{
				"signature": "public void singleBucketIntoSingleMutableMonmorphicInvocation(Blackhole bh)",
				"documentation": "/**\n     * Emulates the way that {@link AutoDateHistogramAggregationBuilder} uses {@link LongKeyedBucketOrds}.\n     */"
			},
			{
				"signature": "public void singleBucketIntoSingleMutableMegamorphicInvocation(Blackhole bh)",
				"documentation": "/**\n     * Emulates a way that we do \u003cstrong\u003enot\u003c/strong\u003e use {@link LongKeyedBucketOrds}\n     * because it is significantly slower than the\n     * {@link #singleBucketIntoSingleMutableMonmorphicInvocation monomorphic invocation}.\n     */"
			},
			{
				"signature": "public void singleBucketIntoMulti(Blackhole bh)",
				"documentation": "/**\n     * Emulates an aggregation that collects from a single bucket \"by accident\".\n     * This can happen if an aggregation is under, say, a {@code terms}\n     * aggregation and there is only a single value for that term in the index\n     * but we can't tell that up front.\n     */"
			},
			{
				"signature": "public void singleBucketIntoMultiSmall(Blackhole bh)",
				"documentation": "/**\n     * Emulates an aggregation that collects from a single bucket \"by accident\"\n     * and gets a \"small\" bucket ords. This can happen to a {@code terms} inside\n     * of another {@code terms} when the \"inner\" terms only even has a single\n     * bucket.\n     */"
			},
			{
				"signature": "private void singleBucketIntoMultiSmall(LongKeyedBucketOrds ords)",
				"documentation": ""
			},
			{
				"signature": "public void multiBucketManySmall(Blackhole bh)",
				"documentation": "/**\n     * Emulates an aggregation that collects from many buckets with a known\n     * bounds on the values.\n     */"
			},
			{
				"signature": "public void multiBucketMany(Blackhole bh)",
				"documentation": "/**\n     * Emulates an aggregation that collects from many buckets.\n     */"
			},
			{
				"signature": "private void multiBucket(Blackhole bh, LongKeyedBucketOrds ords)",
				"documentation": ""
			}
		],
		"interfaces": []
	},
	{
		"documentation": "",
		"name": "org.elasticsearch.benchmark.search.aggregations.bucket.terms.StringTermsSerializationBenchmark",
		"extends": "",
		"Methods": [
			{
				"signature": "public void initResults()",
				"documentation": ""
			},
			{
				"signature": "private StringTerms newTerms(boolean withNested)",
				"documentation": ""
			},
			{
				"signature": "public DelayableWriteable\u003cInternalAggregations\u003e serialize()",
				"documentation": ""
			}
		],
		"interfaces": []
	},
	{
		"documentation": "",
		"name": "org.elasticsearch.benchmark.search.fetch.subphase.FetchSourcePhaseBenchmark",
		"extends": "",
		"Methods": [
			{
				"signature": "public void setup() throws IOException",
				"documentation": ""
			},
			{
				"signature": "private BytesReference read300BytesExample() throws IOException",
				"documentation": ""
			},
			{
				"signature": "private BytesReference buildBigExample(String extraText) throws IOException",
				"documentation": ""
			},
			{
				"signature": "public BytesReference filterObjects() throws IOException",
				"documentation": ""
			},
			{
				"signature": "public BytesReference filterXContentOnParser() throws IOException",
				"documentation": ""
			},
			{
				"signature": "public BytesReference filterXContentOnBuilder() throws IOException",
				"documentation": ""
			}
		],
		"interfaces": []
	},
	{
		"documentation": "",
		"name": "org.elasticsearch.benchmark.time.DateFormatterFromBenchmark",
		"extends": "",
		"Methods": [
			{
				"signature": "public TemporalAccessor benchmarkFrom()",
				"documentation": ""
			}
		],
		"interfaces": []
	},
	{
		"documentation": "",
		"name": "org.elasticsearch.benchmark.xcontent.FilterContentBenchmark",
		"extends": "",
		"Methods": [
			{
				"signature": "public void setup() throws IOException",
				"documentation": ""
			},
			{
				"signature": "private Set\u003cString\u003e buildFilters()",
				"documentation": ""
			},
			{
				"signature": "public BytesReference filterWithParserConfigCreated() throws IOException",
				"documentation": ""
			},
			{
				"signature": "public BytesReference filterWithParserConfigCreatedMatchDotsInFieldNames() throws IOException",
				"documentation": ""
			},
			{
				"signature": "public BytesReference filterWithNewParserConfig() throws IOException",
				"documentation": ""
			},
			{
				"signature": "public BytesReference filterWithMap() throws IOException",
				"documentation": ""
			},
			{
				"signature": "public BytesReference filterWithBuilder() throws IOException",
				"documentation": ""
			},
			{
				"signature": "private XContentParserConfiguration buildParseConfig(boolean matchDotsInFieldNames)",
				"documentation": ""
			},
			{
				"signature": "private BytesReference filter(XContentParserConfiguration contentParserConfiguration) throws IOException",
				"documentation": ""
			},
			{
				"signature": "private BytesReference readSource(String fileName) throws IOException",
				"documentation": ""
			}
		],
		"interfaces": []
	},
	{
		"documentation": "/**\n * This is a copy of Checkstyle's {@link com.puppycrawl.tools.checkstyle.checks.coding.HiddenFieldCheck}. See\n * the original class for full documentation.\n */",
		"name": "org.elasticsearch.gradle.internal.checkstyle.HiddenFieldCheck",
		"extends": "com.puppycrawl.tools.checkstyle.api.AbstractCheck",
		"Methods": [
			{
				"signature": "public int[] getDefaultTokens()",
				"documentation": "/** Control the minimal amount of lines in method to allow shadowed variables .*/"
			},
			{
				"signature": "public int[] getAcceptableTokens()",
				"documentation": ""
			},
			{
				"signature": "public int[] getRequiredTokens()",
				"documentation": ""
			},
			{
				"signature": "public void beginTree(DetailAST rootAST)",
				"documentation": ""
			},
			{
				"signature": "public void visitToken(DetailAST ast)",
				"documentation": ""
			},
			{
				"signature": "private void processLambda(DetailAST ast)",
				"documentation": "/**\n     * Process a lambda token.\n     * Checks whether a lambda parameter shadows a field.\n     * Note, that when parameter of lambda expression is untyped,\n     * ANTLR parses the parameter as an identifier.\n     *\n     * @param ast the lambda token.\n     */"
			},
			{
				"signature": "private void visitOtherTokens(DetailAST ast, int type)",
				"documentation": "/**\n     * Called to process tokens other than {@link TokenTypes#VARIABLE_DEF}\n     * and {@link TokenTypes#PARAMETER_DEF}.\n     *\n     * @param ast token to process\n     * @param type type of the token\n     */"
			},
			{
				"signature": "public void leaveToken(DetailAST ast)",
				"documentation": ""
			},
			{
				"signature": "private void processVariable(DetailAST ast)",
				"documentation": "/**\n     * Process a variable token.\n     * Check whether a local variable or parameter shadows a field.\n     * Store a field for later comparison with local variables and parameters.\n     *\n     * @param ast the variable token.\n     */"
			},
			{
				"signature": "private boolean isIgnoredParam(DetailAST ast, String name)",
				"documentation": "/**\n     * Checks whether method or constructor parameter is ignored.\n     *\n     * @param ast the parameter token.\n     * @param name the parameter name.\n     * @return true if parameter is ignored.\n     */"
			},
			{
				"signature": "private boolean isIgnoredVariable(DetailAST ast, String name)",
				"documentation": ""
			},
			{
				"signature": "private boolean isInstanceField(DetailAST ast, String name)",
				"documentation": "/**\n     * Check for instance field.\n     *\n     * @param ast token\n     * @param name identifier of token\n     * @return true if instance field\n     */"
			},
			{
				"signature": "private boolean isMatchingRegexp(String name)",
				"documentation": "/**\n     * Check name by regExp.\n     *\n     * @param name string value to check\n     * @return true is regexp is matching\n     */"
			},
			{
				"signature": "private static boolean isInStatic(DetailAST ast)",
				"documentation": "/**\n     * Determines whether an AST node is in a static method or static\n     * initializer.\n     *\n     * @param ast the node to check.\n     * @return true if ast is in a static method or a static block;\n     */"
			},
			{
				"signature": "private boolean isIgnoredSetterParam(DetailAST ast, String name)",
				"documentation": "/**\n     * Decides whether to ignore an AST node that is the parameter of a\n     * setter method, where the property setter method for field 'xyz' has\n     * name 'setXyz', one parameter named 'xyz', and return type void\n     * (default behavior) or return type is name of the class in which\n     * such method is declared (allowed only if\n     * {@link #setSetterCanReturnItsClass(boolean)} is called with\n     * value \u003cem\u003etrue\u003c/em\u003e).\n     *\n     * @param ast the AST to check.\n     * @param name the name of ast.\n     * @return true if ast should be ignored because check property\n     *     ignoreSetter is true and ast is the parameter of a setter method.\n     */"
			},
			{
				"signature": "private boolean isSetterMethod(DetailAST aMethodAST, String aName)",
				"documentation": "/**\n     * Determine if a specific method identified by methodAST and a single\n     * variable name aName is a setter. This recognition partially depends\n     * on setterCanReturnItsClass property.\n     *\n     * @param aMethodAST AST corresponding to a method call\n     * @param aName name of single parameter of this method.\n     * @return true of false indicating of method is a setter or not.\n     */"
			},
			{
				"signature": "private static String capitalize(final String name, boolean javaBeanCompliant)",
				"documentation": "/**\n     * Capitalizes a given property name the way we expect to see it in\n     * a setter name.\n     *\n     * @param name a property name\n     * @return capitalized property name\n     */"
			},
			{
				"signature": "private boolean isIgnoredConstructorParam(DetailAST ast)",
				"documentation": "/**\n     * Decides whether to ignore an AST node that is the parameter of a\n     * constructor.\n     *\n     * @param ast the AST to check.\n     * @return true if ast should be ignored because check property\n     *     ignoreConstructorParameter is true and ast is a constructor parameter.\n     */"
			},
			{
				"signature": "private boolean isIgnoredParamOfAbstractMethod(DetailAST ast)",
				"documentation": "/**\n     * Decides whether to ignore an AST node that is the parameter of an\n     * abstract method.\n     *\n     * @param ast the AST to check.\n     * @return true if ast should be ignored because check property\n     *     ignoreAbstractMethods is true and ast is a parameter of abstract methods.\n     */"
			},
			{
				"signature": "private boolean isVariableInIgnoredMethod(DetailAST ast, String name)",
				"documentation": "/**\n     * Decides whether to ignore an AST node that is witin a method that ought to be ignored.\n     * This is either because:\n     *\n     * \u003cul\u003e\n     *   \u003cli\u003eThe method name matches the {@link #ignoreMethodNames} regex, if set.\u003c/li\u003e\n     *   \u003cli\u003eThe method's line length is less that or equal to the {@link #minLineCount}\u003c/li\u003e\n     * \u003c/ul\u003e\n     *\n     * @param ast the AST to check\n     * @return true is the ast node should be ignored\n     */"
			},
			{
				"signature": "private boolean isVariableInConstructorBody(DetailAST ast, String name)",
				"documentation": ""
			},
			{
				"signature": "private boolean isVariableInIgnoredConstructor(DetailAST ast, String name)",
				"documentation": ""
			},
			{
				"signature": "public void setIgnoreFormat(Pattern pattern)",
				"documentation": "/**\n     * Setter to define the RegExp for names of variables and parameters to ignore.\n     *\n     * @param pattern a pattern.\n     */"
			},
			{
				"signature": "public void setIgnoreSetter(boolean ignoreSetter)",
				"documentation": "/**\n     * Setter to allow to ignore the parameter of a property setter method.\n     *\n     * @param ignoreSetter decide whether to ignore the parameter of\n     *     a property setter method.\n     */"
			},
			{
				"signature": "public void setSetterCanReturnItsClass(boolean aSetterCanReturnItsClass)",
				"documentation": "/**\n     * Setter to allow to expand the definition of a setter method to include methods\n     * that return the class' instance.\n     *\n     * @param aSetterCanReturnItsClass if true then setter can return\n     *        either void or class in which it is declared. If false then\n     *        in order to be recognized as setter method (otherwise\n     *        already recognized as a setter) must return void.  Later is\n     *        the default behavior.\n     */"
			},
			{
				"signature": "public void setIgnoreConstructorParameter(boolean ignoreConstructorParameter)",
				"documentation": "/**\n     * Setter to control whether to ignore constructor parameters.\n     *\n     * @param ignoreConstructorParameter decide whether to ignore\n     *     constructor parameters.\n     */"
			},
			{
				"signature": "public void setIgnoreAbstractMethods(boolean ignoreAbstractMethods)",
				"documentation": "/**\n     * Setter to control whether to ignore parameters of abstract methods.\n     *\n     * @param ignoreAbstractMethods decide whether to ignore\n     *     parameters of abstract methods.\n     */"
			},
			{
				"signature": "public void setIgnoreMethodNames(String ignoreMethodNames)",
				"documentation": ""
			},
			{
				"signature": "public void setIgnoreConstructorBody(boolean ignoreConstructorBody)",
				"documentation": ""
			},
			{
				"signature": "public void setIgnoreConstructorMethods(String ignoreConstructorMethods)",
				"documentation": ""
			},
			{
				"signature": "public void setMinLineCount(int minLineCount)",
				"documentation": ""
			},
			{
				"signature": "private static int getMethodsNumberOfLine(DetailAST methodDef)",
				"documentation": ""
			}
		],
		"interfaces": []
	},
	{
		"documentation": "/**\n     * Holds the names of static and instance fields of a type.\n     */",
		"name": "org.elasticsearch.gradle.internal.checkstyle.HiddenFieldCheck.FieldFrame",
		"extends": "",
		"Methods": [
			{
				"signature": "FieldFrame(FieldFrame parent, boolean staticType, String frameName)",
				"documentation": ""
			},
			{
				"signature": "public void addInstanceField(String field)",
				"documentation": "/**\n         * Adds an instance field to this FieldFrame.\n         *\n         * @param field  the name of the instance field.\n         */"
			},
			{
				"signature": "public void addStaticField(String field)",
				"documentation": "/**\n         * Adds a static field to this FieldFrame.\n         *\n         * @param field  the name of the instance field.\n         */"
			},
			{
				"signature": "public boolean containsInstanceField(String field)",
				"documentation": "/**\n         * Determines whether this FieldFrame contains an instance field.\n         *\n         * @param field the field to check.\n         * @return true if this FieldFrame contains instance field field.\n         */"
			},
			{
				"signature": "public boolean containsStaticField(String field)",
				"documentation": "/**\n         * Determines whether this FieldFrame contains a static field.\n         *\n         * @param field the field to check.\n         * @return true if this FieldFrame contains static field field.\n         */"
			},
			{
				"signature": "public FieldFrame getParent()",
				"documentation": "/**\n         * Getter for parent frame.\n         *\n         * @return parent frame.\n         */"
			},
			{
				"signature": "private boolean isEmbeddedIn(String classOrEnumName)",
				"documentation": "/**\n         * Check if current frame is embedded in class or enum with\n         * specific name.\n         *\n         * @param classOrEnumName name of class or enum that we are looking\n         *     for in the chain of field frames.\n         *\n         * @return true if current frame is embedded in class or enum\n         *     with name classOrNameName\n         */"
			}
		],
		"interfaces": []
	},
	{
		"documentation": "/**\n * This is a copy of Checkstyle's {@link com.puppycrawl.tools.checkstyle.checks.javadoc.MissingJavadocTypeCheck},\n * modified to accept a regex to exclude classes by name. See the original class for full documentation.\n */",
		"name": "org.elasticsearch.gradle.internal.checkstyle.MissingJavadocTypeCheck",
		"extends": "com.puppycrawl.tools.checkstyle.api.AbstractCheck",
		"Methods": [
			{
				"signature": "public void setScope(Scope scope)",
				"documentation": "/**\n     * Setter to specify the visibility scope where Javadoc comments are checked.\n     *\n     * @param scope a scope.\n     */"
			},
			{
				"signature": "public void setExcludeScope(Scope excludeScope)",
				"documentation": "/**\n     * Setter to specify the visibility scope where Javadoc comments are not checked.\n     *\n     * @param excludeScope a scope.\n     */"
			},
			{
				"signature": "public void setSkipAnnotations(String... userAnnotations)",
				"documentation": "/**\n     * Setter to specify the list of annotations that allow missed documentation.\n     * Only short names are allowed, e.g. {@code Generated}.\n     *\n     * @param userAnnotations user's value.\n     */"
			},
			{
				"signature": "public final void setIgnorePattern(Pattern pattern)",
				"documentation": "/**\n     * Setter to specify pattern for types to ignore.\n     *\n     * @param pattern a pattern.\n     */"
			},
			{
				"signature": "public int[] getDefaultTokens()",
				"documentation": ""
			},
			{
				"signature": "public int[] getAcceptableTokens()",
				"documentation": ""
			},
			{
				"signature": "public int[] getRequiredTokens()",
				"documentation": ""
			},
			{
				"signature": "public void visitToken(DetailAST ast)",
				"documentation": ""
			},
			{
				"signature": "private boolean shouldCheck(final DetailAST ast)",
				"documentation": "/**\n     * Whether we should check this node.\n     *\n     * @param ast a given node.\n     * @return whether we should check a given node.\n     */"
			}
		],
		"interfaces": []
	},
	{
		"documentation": "/**\n * Checks the snippets included in the docs aren't too wide to fit on\n * the page.\n * \u003cp\u003e\n * Regions contained in the special \u003ccode\u003enoformat\u003c/code\u003e tag are exempt from the length\n * check. This region is also exempt from automatic formatting.\n */",
		"name": "org.elasticsearch.gradle.internal.checkstyle.SnippetLengthCheck",
		"extends": "com.puppycrawl.tools.checkstyle.api.AbstractFileSetCheck",
		"Methods": [
			{
				"signature": "public void setMax(int max)",
				"documentation": "/**\n     * The maximum width that a snippet may have.\n     */"
			},
			{
				"signature": "protected void processFiltered(File file, FileText fileText) throws CheckstyleException",
				"documentation": ""
			},
			{
				"signature": "static void checkFile(BiConsumer\u003cInteger, String\u003e log, int max, String... lineArray)",
				"documentation": ""
			},
			{
				"signature": "private static void checkSnippet(BiConsumer\u003cInteger, String\u003e log, int max, LineItr lines, String leadingSpaces, String name)",
				"documentation": ""
			}
		],
		"interfaces": []
	},
	{
		"documentation": "",
		"name": "org.elasticsearch.gradle.internal.checkstyle.SnippetLengthCheck.LineItr",
		"extends": "",
		"Methods": [
			{
				"signature": "LineItr(Iterator\u003cString\u003e delegate)",
				"documentation": ""
			},
			{
				"signature": "public boolean hasNext()",
				"documentation": ""
			},
			{
				"signature": "public String next()",
				"documentation": ""
			}
		],
		"interfaces": [
			"java.util.Iterator"
		]
	},
	{
		"documentation": "/**\n * Checks for calls to {@link String#formatted(Object...)} that include format specifiers that\n * are not locale-safe. This method always uses the default {@link Locale}, and so for our\n * purposes it is safer to use {@link String#format(Locale, String, Object...)}.\n * \u003cp\u003e\n * Note that this rule can currently only detect violations when calling \u003ccode\u003eformatted()\u003c/code\u003e\n * on a string literal or text block. In theory, it could be extended to detect violations in\n * local variables or statics.\n */",
		"name": "org.elasticsearch.gradle.internal.checkstyle.StringFormattingCheck",
		"extends": "com.puppycrawl.tools.checkstyle.api.AbstractCheck",
		"Methods": [
			{
				"signature": "public int[] getDefaultTokens()",
				"documentation": "/**\n * Checks for calls to {@link String#formatted(Object...)} that include format specifiers that\n * are not locale-safe. This method always uses the default {@link Locale}, and so for our\n * purposes it is safer to use {@link String#format(Locale, String, Object...)}.\n * \u003cp\u003e\n * Note that this rule can currently only detect violations when calling \u003ccode\u003eformatted()\u003c/code\u003e\n * on a string literal or text block. In theory, it could be extended to detect violations in\n * local variables or statics.\n */"
			},
			{
				"signature": "public int[] getAcceptableTokens()",
				"documentation": ""
			},
			{
				"signature": "public int[] getRequiredTokens()",
				"documentation": ""
			},
			{
				"signature": "public void visitToken(DetailAST ast)",
				"documentation": ""
			},
			{
				"signature": "private void checkFormattedMethod(DetailAST ast)",
				"documentation": ""
			}
		],
		"interfaces": []
	},
	{
		"documentation": "",
		"name": "org.elasticsearch.gradle.internal.conventions.BuildToolsConventionsPlugin",
		"extends": "",
		"Methods": [
			{
				"signature": "public void apply(Project project)",
				"documentation": ""
			}
		],
		"interfaces": [
			"org.gradle.api.Plugin"
		]
	},
	{
		"documentation": "",
		"name": "org.elasticsearch.gradle.internal.conventions.EclipseConventionPlugin",
		"extends": "",
		"Methods": [
			{
				"signature": "public void apply(Project project)",
				"documentation": ""
			},
			{
				"signature": "public String transform(String s)",
				"documentation": ""
			},
			{
				"signature": "public void execute(Delete delete)",
				"documentation": ""
			},
			{
				"signature": "private File root(Project project)",
				"documentation": ""
			}
		],
		"interfaces": [
			"org.gradle.api.Plugin"
		]
	},
	{
		"documentation": "",
		"name": "org.elasticsearch.gradle.internal.conventions.GUtils",
		"extends": "",
		"Methods": [
			{
				"signature": "public static String capitalize(String s)",
				"documentation": ""
			}
		],
		"interfaces": []
	},
	{
		"documentation": "",
		"name": "org.elasticsearch.gradle.internal.conventions.GitInfoPlugin",
		"extends": "",
		"Methods": [
			{
				"signature": "GitInfoPlugin(ProviderFactory factory, ObjectFactory objectFactory)",
				"documentation": ""
			},
			{
				"signature": "public void apply(Project project)",
				"documentation": ""
			},
			{
				"signature": "public Property\u003cGitInfo\u003e getGitInfo()",
				"documentation": ""
			},
			{
				"signature": "public Provider\u003cString\u003e getRevision()",
				"documentation": ""
			}
		],
		"interfaces": [
			"org.gradle.api.Plugin"
		]
	},
	{
		"documentation": "",
		"name": "org.elasticsearch.gradle.internal.conventions.LicensingPlugin",
		"extends": "",
		"Methods": [
			{
				"signature": "public LicensingPlugin(ProviderFactory providerFactory)",
				"documentation": ""
			},
			{
				"signature": "public void apply(Project project)",
				"documentation": ""
			},
			{
				"signature": "private boolean isSnapshotVersion(Project project)",
				"documentation": ""
			}
		],
		"interfaces": [
			"org.gradle.api.Plugin"
		]
	},
	{
		"documentation": "",
		"name": "org.elasticsearch.gradle.internal.conventions.PublishPlugin",
		"extends": "",
		"Methods": [
			{
				"signature": "public PublishPlugin(ProjectLayout projectLayout, BuildLayout buildLayout, ProviderFactory providerFactory)",
				"documentation": ""
			},
			{
				"signature": "public void apply(Project project)",
				"documentation": ""
			},
			{
				"signature": "private void configurePublications(Project project)",
				"documentation": ""
			},
			{
				"signature": "private static String getArchivesBaseName(ExtensionContainer extensions)",
				"documentation": ""
			},
			{
				"signature": "private void configurePomGeneration(Project project)",
				"documentation": "/**\n     * Configuration generation of maven poms.\n     */"
			},
			{
				"signature": "private void addNameAndDescriptiontoPom(Project project, NamedDomainObjectSet\u003cMavenPublication\u003e mavenPublications)",
				"documentation": ""
			},
			{
				"signature": "private static void configureWithShadowPlugin(Project project, MavenPublication publication)",
				"documentation": ""
			},
			{
				"signature": "private static void addScmInfo(XmlProvider xml, GitInfo gitInfo)",
				"documentation": ""
			},
			{
				"signature": "private static void configureJavadocJar(Project project)",
				"documentation": "/**\n     * Adds a javadocJar task to generate a jar containing javadocs.\n     */"
			},
			{
				"signature": "static void configureSourcesJar(Project project)",
				"documentation": ""
			}
		],
		"interfaces": [
			"org.gradle.api.Plugin"
		]
	},
	{
		"documentation": "",
		"name": "org.elasticsearch.gradle.internal.conventions.VersionPropertiesBuildService",
		"extends": "",
		"Methods": [
			{
				"signature": "public VersionPropertiesBuildService(ProviderFactory providerFactory)",
				"documentation": ""
			},
			{
				"signature": "private JavaVersion resolveMinimumRuntimeJavaVersion(File infoPath)",
				"documentation": ""
			},
			{
				"signature": "private JavaVersion resolveMinimumCompilerJavaVersion(File infoPath)",
				"documentation": ""
			},
			{
				"signature": "private JavaVersion resolveJavaVersion(File infoPath, String path)",
				"documentation": ""
			},
			{
				"signature": "public Properties getProperties()",
				"documentation": ""
			},
			{
				"signature": "public void close() throws Exception",
				"documentation": ""
			}
		],
		"interfaces": [
			"org.gradle.api.services.BuildService",
			"AutoCloseable"
		]
	},
	{
		"documentation": "",
		"name": "org.elasticsearch.gradle.internal.conventions.VersionPropertiesLoader",
		"extends": "",
		"Methods": [
			{
				"signature": "static Properties loadBuildSrcVersion(File input, ProviderFactory providerFactory) throws IOException",
				"documentation": ""
			},
			{
				"signature": "protected static void loadBuildSrcVersion(Properties loadedProps, ProviderFactory providers)",
				"documentation": ""
			}
		],
		"interfaces": []
	},
	{
		"documentation": "",
		"name": "org.elasticsearch.gradle.internal.conventions.VersionPropertiesPlugin",
		"extends": "",
		"Methods": [
			{
				"signature": "public void apply(Project project)",
				"documentation": ""
			}
		],
		"interfaces": [
			"org.gradle.api.Plugin"
		]
	},
	{
		"documentation": "",
		"name": "org.elasticsearch.gradle.internal.conventions.info.GitInfo",
		"extends": "",
		"Methods": [
			{
				"signature": "private GitInfo(String revision, String origin)",
				"documentation": ""
			},
			{
				"signature": "public String getRevision()",
				"documentation": ""
			},
			{
				"signature": "public String getOrigin()",
				"documentation": ""
			},
			{
				"signature": "public static GitInfo gitInfo(File rootDir)",
				"documentation": ""
			},
			{
				"signature": "private static String findOriginUrl(final Path configFile) throws IOException",
				"documentation": ""
			},
			{
				"signature": "private static String readFirstLine(final Path path) throws IOException",
				"documentation": ""
			},
			{
				"signature": "public String urlFromOrigin()",
				"documentation": "/** Find the reponame. */"
			}
		],
		"interfaces": []
	},
	{
		"documentation": "",
		"name": "org.elasticsearch.gradle.internal.conventions.info.ParallelDetector",
		"extends": "",
		"Methods": [
			{
				"signature": "public static int findDefaultParallel(Project project)",
				"documentation": ""
			},
			{
				"signature": "private static boolean isMac(ProviderFactory providers)",
				"documentation": ""
			}
		],
		"interfaces": []
	},
	{
		"documentation": "/**\n * This plugin configures formatting for Java source using Spotless\n * for Gradle. Since the act of formatting existing source can interfere\n * with developers' workflows, we don't automatically format all code\n * (yet). Instead, we maintain a list of projects that are excluded from\n * formatting, until we reach a point where we can comfortably format them\n * in one go without too much disruption.\n *\n * \u003cp\u003eAny new sub-projects must not be added to the exclusions list!\n *\n * \u003cp\u003eTo perform a reformat, run:\n *\n * \u003cpre\u003e    ./gradlew spotlessApply\u003c/pre\u003e\n *\n * \u003cp\u003eTo check the current format, run:\n *\n * \u003cpre\u003e    ./gradlew spotlessJavaCheck\u003c/pre\u003e\n *\n * \u003cp\u003eThis is also carried out by the `precommit` task.\n *\n * \u003cp\u003eSee also the \u003ca href=\"https://github.com/diffplug/spotless/tree/master/plugin-gradle\"\n * \u003eSpotless project page\u003c/a\u003e.\n */",
		"name": "org.elasticsearch.gradle.internal.conventions.precommit.FormattingPrecommitPlugin",
		"extends": "",
		"Methods": [
			{
				"signature": "public void apply(Project project)",
				"documentation": "/**\n * This plugin configures formatting for Java source using Spotless\n * for Gradle. Since the act of formatting existing source can interfere\n * with developers' workflows, we don't automatically format all code\n * (yet). Instead, we maintain a list of projects that are excluded from\n * formatting, until we reach a point where we can comfortably format them\n * in one go without too much disruption.\n *\n * \u003cp\u003eAny new sub-projects must not be added to the exclusions list!\n *\n * \u003cp\u003eTo perform a reformat, run:\n *\n * \u003cpre\u003e    ./gradlew spotlessApply\u003c/pre\u003e\n *\n * \u003cp\u003eTo check the current format, run:\n *\n * \u003cpre\u003e    ./gradlew spotlessJavaCheck\u003c/pre\u003e\n *\n * \u003cp\u003eThis is also carried out by the `precommit` task.\n *\n * \u003cp\u003eSee also the \u003ca href=\"https://github.com/diffplug/spotless/tree/master/plugin-gradle\"\n * \u003eSpotless project page\u003c/a\u003e.\n */"
			}
		],
		"interfaces": [
			"org.gradle.api.Plugin"
		]
	},
	{
		"documentation": "",
		"name": "org.elasticsearch.gradle.internal.conventions.precommit.LicenseHeadersPrecommitPlugin",
		"extends": "PrecommitPlugin",
		"Methods": [
			{
				"signature": "public LicenseHeadersPrecommitPlugin(ProviderFactory providerFactory)",
				"documentation": ""
			},
			{
				"signature": "public TaskProvider\u003c? extends Task\u003e createTask(Project project)",
				"documentation": ""
			}
		],
		"interfaces": []
	},
	{
		"documentation": "/**\n * Checks files for license headers..\n */",
		"name": "org.elasticsearch.gradle.internal.conventions.precommit.LicenseHeadersTask",
		"extends": "org.gradle.api.DefaultTask",
		"Methods": [
			{
				"signature": "public LicenseHeadersTask(ObjectFactory objectFactory, ProjectLayout projectLayout)",
				"documentation": "/**\n     * Files that should be excluded from the license header check. Use with extreme care, only in situations where the license on the\n     * source file is compatible with the codebase but we do not want to add the license to the list of approved headers (to avoid the\n     * possibility of inadvertently using the license on our own source files).\n     */"
			},
			{
				"signature": "public List\u003cFileCollection\u003e getJavaFiles()",
				"documentation": "/**\n     * The list of java files to check. protected so the afterEvaluate closure in the\n     * constructor can write to it.\n     */"
			},
			{
				"signature": "public RegularFileProperty getReportFile()",
				"documentation": ""
			},
			{
				"signature": "public List\u003cString\u003e getApprovedLicenses()",
				"documentation": ""
			},
			{
				"signature": "public void setApprovedLicenses(List\u003cString\u003e approvedLicenses)",
				"documentation": ""
			},
			{
				"signature": "public List\u003cString\u003e getExcludes()",
				"documentation": ""
			},
			{
				"signature": "public void setExcludes(List\u003cString\u003e excludes)",
				"documentation": ""
			},
			{
				"signature": "public ListProperty\u003cLicense\u003e getAdditionalLicenses()",
				"documentation": "/**\n     * Additional license families that may be found. The key is the license category name (5 characters),\n     * followed by the family name and the value list of patterns to search for.\n     */"
			},
			{
				"signature": "public void additionalLicense(final String categoryName, String familyName, String pattern)",
				"documentation": "/**\n     * Add a new license type.\n     * \u003cp\u003e\n     * The license may be added to the {@link #approvedLicenses} using the {@code familyName}.\n     *\n     * @param categoryName A 5-character string identifier for the license\n     * @param familyName   An expanded string name for the license\n     * @param pattern      A pattern to search for, which if found, indicates a file contains the license\n     */"
			},
			{
				"signature": "public void runRat()",
				"documentation": ""
			},
			{
				"signature": "private IHeaderMatcher subStringMatcher(String licenseFamilyCategory, String licenseFamilyName, String substringPattern)",
				"documentation": ""
			},
			{
				"signature": "private ClaimStatistic generateReport(ReportConfiguration config, File xmlReportFile)",
				"documentation": ""
			},
			{
				"signature": "private ClaimStatistic toXmlReportFile(ReportConfiguration config, Writer writer) throws RatException, IOException",
				"documentation": ""
			},
			{
				"signature": "private static List\u003cString\u003e unapprovedFiles(File xmlReportFile)",
				"documentation": ""
			},
			{
				"signature": "private static List\u003cElement\u003e elementList(NodeList resourcesNodes)",
				"documentation": ""
			}
		],
		"interfaces": []
	},
	{
		"documentation": "",
		"name": "org.elasticsearch.gradle.internal.conventions.precommit.LicenseHeadersTask.License",
		"extends": "",
		"Methods": [
			{
				"signature": "public License(String licenseFamilyCategory, String licenseFamilyName, String substringPattern)",
				"documentation": ""
			}
		],
		"interfaces": [
			"java.io.Serializable"
		]
	},
	{
		"documentation": "/**\n * Adds pom validation to every pom generation task.\n */",
		"name": "org.elasticsearch.gradle.internal.conventions.precommit.PomValidationPrecommitPlugin",
		"extends": "PrecommitPlugin",
		"Methods": [
			{
				"signature": "public TaskProvider\u003c? extends Task\u003e createTask(Project project)",
				"documentation": "/**\n * Adds pom validation to every pom generation task.\n */"
			}
		],
		"interfaces": []
	},
	{
		"documentation": "",
		"name": "org.elasticsearch.gradle.internal.conventions.precommit.PomValidationTask",
		"extends": "org.elasticsearch.gradle.internal.conventions.precommit.PrecommitTask",
		"Methods": [
			{
				"signature": "public PomValidationTask(ObjectFactory objects)",
				"documentation": ""
			},
			{
				"signature": "public RegularFileProperty getPomFile()",
				"documentation": ""
			},
			{
				"signature": "public void checkPom() throws Exception",
				"documentation": ""
			},
			{
				"signature": "private void logError(String element, String message)",
				"documentation": ""
			},
			{
				"signature": "private \u003cT\u003e void validateNonEmpty(String element, T value, Predicate\u003cT\u003e isEmpty)",
				"documentation": ""
			},
			{
				"signature": "private \u003cT\u003e void validateNonNull(String element, T value, Runnable validator)",
				"documentation": ""
			},
			{
				"signature": "private void validateString(String element, String value)",
				"documentation": ""
			},
			{
				"signature": "private \u003cT\u003e void validateCollection(String element, Collection\u003cT\u003e value, Consumer\u003cT\u003e validator)",
				"documentation": ""
			}
		],
		"interfaces": []
	},
	{
		"documentation": "/**\n * Base plugin for adding a precommit task.\n */",
		"name": "org.elasticsearch.gradle.internal.conventions.precommit.PrecommitPlugin",
		"extends": "",
		"Methods": [
			{
				"signature": "public final void apply(Project project)",
				"documentation": "/**\n * Base plugin for adding a precommit task.\n */"
			}
		],
		"interfaces": [
			"org.gradle.api.Plugin"
		]
	},
	{
		"documentation": "",
		"name": "org.elasticsearch.gradle.internal.conventions.precommit.PrecommitTask",
		"extends": "org.gradle.api.DefaultTask",
		"Methods": [
			{
				"signature": "public File getSuccessMarker()",
				"documentation": ""
			},
			{
				"signature": "public void writeMarker() throws IOException",
				"documentation": ""
			},
			{
				"signature": "protected ProjectLayout getProjectLayout()",
				"documentation": ""
			}
		],
		"interfaces": []
	},
	{
		"documentation": "",
		"name": "org.elasticsearch.gradle.internal.conventions.precommit.PrecommitTaskPlugin",
		"extends": "",
		"Methods": [
			{
				"signature": "public void apply(Project project)",
				"documentation": ""
			}
		],
		"interfaces": [
			"org.gradle.api.Plugin"
		]
	},
	{
		"documentation": "",
		"name": "org.elasticsearch.gradle.internal.conventions.util.Util",
		"extends": "",
		"Methods": [
			{
				"signature": "public static boolean getBooleanProperty(String property, boolean defaultValue)",
				"documentation": ""
			},
			{
				"signature": "public static FileTree getJavaMainSourceResources(Project project, Action\u003c? super PatternFilterable\u003e filter)",
				"documentation": "/**\n     * @param project The project to look for resources.\n     * @param filter  Optional filter function to filter the returned resources\n     * @return Returns the {@link FileTree} for main resources from Java projects. Returns null if no files exist.\n     */"
			},
			{
				"signature": "public static FileTree getJavaTestSourceResources(Project project, Action\u003c? super PatternFilterable\u003e filter)",
				"documentation": "/**\n     * @param project The project to look for resources.\n     * @param filter  Optional filter function to filter the returned resources\n     * @return Returns the {@link FileTree} for test resources from Java projects. Returns null if no files exist.\n     */"
			},
			{
				"signature": "public static FileTree getJavaTestAndMainSourceResources(Project project, Action\u003c? super PatternFilterable\u003e filter)",
				"documentation": "/**\n     * @param project The project to look for resources.\n     * @param filter  Optional filter function to filter the returned resources\n     * @return Returns the combined {@link FileTree} for test and main resources from Java projects. Returns null if no files exist.\n     */"
			},
			{
				"signature": "public static Optional\u003cSourceSet\u003e getJavaTestSourceSet(Project project)",
				"documentation": "/**\n     * @param project The project to look for test Java resources.\n     * @return An Optional that contains the Java test SourceSet if it exists.\n     */"
			},
			{
				"signature": "public static Optional\u003cSourceSet\u003e getJavaMainSourceSet(Project project)",
				"documentation": "/**\n     * @param project The project to look for main Java resources.\n     * @return An Optional that contains the Java main SourceSet if it exists.\n     */"
			},
			{
				"signature": "private static boolean isJavaExtensionAvailable(Project project)",
				"documentation": ""
			},
			{
				"signature": "public static Object toStringable(Supplier\u003cString\u003e getter)",
				"documentation": ""
			},
			{
				"signature": "public String toString()",
				"documentation": ""
			},
			{
				"signature": "public static SourceSetContainer getJavaSourceSets(Project project)",
				"documentation": ""
			}
		],
		"interfaces": []
	},
	{
		"documentation": "/**\n * A standalone process that will reap external services after a build dies.\n *\n * \u003ch2\u003eInput\u003c/h2\u003e\n * Since how to reap a given service is platform and service dependent, this tool\n * operates on system commands to execute. It takes a single argument, a directory\n * that will contain files with reaping commands. Each line in each file will be\n * executed with {@link Runtime#exec(String)}.\n *\n * The main method will wait indefinitely on the parent process (Gradle) by\n * reading from stdin. When Gradle shuts down, whether normally or abruptly, the\n * pipe will be broken and read will return.\n *\n * The reaper will then iterate over the files in the configured directory,\n * and execute the given commands. If any commands fail, a failure message is\n * written to stderr. Otherwise, the input file will be deleted. If no inputs\n * produced errors, the entire input directory is deleted upon completion of reaping.\n */",
		"name": "org.elasticsearch.gradle.reaper.Reaper",
		"extends": "",
		"Methods": [
			{
				"signature": "private Reaper(Path inputDir)",
				"documentation": "/**\n * A standalone process that will reap external services after a build dies.\n *\n * \u003ch2\u003eInput\u003c/h2\u003e\n * Since how to reap a given service is platform and service dependent, this tool\n * operates on system commands to execute. It takes a single argument, a directory\n * that will contain files with reaping commands. Each line in each file will be\n * executed with {@link Runtime#exec(String)}.\n *\n * The main method will wait indefinitely on the parent process (Gradle) by\n * reading from stdin. When Gradle shuts down, whether normally or abruptly, the\n * pipe will be broken and read will return.\n *\n * The reaper will then iterate over the files in the configured directory,\n * and execute the given commands. If any commands fail, a failure message is\n * written to stderr. Otherwise, the input file will be deleted. If no inputs\n * produced errors, the entire input directory is deleted upon completion of reaping.\n */"
			},
			{
				"signature": "public static void main(String[] args) throws Exception",
				"documentation": ""
			},
			{
				"signature": "private void reap()",
				"documentation": ""
			},
			{
				"signature": "private void logFailure(String message, Exception e)",
				"documentation": ""
			},
			{
				"signature": "private void delete(Path toDelete)",
				"documentation": ""
			},
			{
				"signature": "public void close()",
				"documentation": ""
			}
		],
		"interfaces": [
			"java.io.Closeable"
		]
	},
	{
		"documentation": "",
		"name": "org.elasticsearch.gradle.ReaperPluginIT",
		"extends": "org.elasticsearch.gradle.internal.test.GradleIntegrationTestCase",
		"Methods": [
			{
				"signature": "public String projectName()",
				"documentation": ""
			},
			{
				"signature": "public void testCanLaunchReaper()",
				"documentation": ""
			}
		],
		"interfaces": []
	},
	{
		"documentation": "",
		"name": "org.elasticsearch.gradle.AbstractLazyPropertyCollection",
		"extends": "",
		"Methods": [
			{
				"signature": "public AbstractLazyPropertyCollection(String name)",
				"documentation": ""
			},
			{
				"signature": "public AbstractLazyPropertyCollection(String name, Object owner)",
				"documentation": ""
			},
			{
				"signature": "void assertNotNull(Object value, String description)",
				"documentation": ""
			}
		],
		"interfaces": []
	},
	{
		"documentation": "",
		"name": "org.elasticsearch.gradle.Architecture",
		"extends": "",
		"Methods": [
			{
				"signature": "Architecture(String classifier)",
				"documentation": ""
			},
			{
				"signature": "public static Architecture current()",
				"documentation": ""
			}
		],
		"interfaces": []
	},
	{
		"documentation": "",
		"name": "org.elasticsearch.gradle.DistributionDependency.StringBasedDistributionDependency",
		"extends": "",
		"Methods": [
			{
				"signature": "public StringBasedDistributionDependency(String notation)",
				"documentation": ""
			},
			{
				"signature": "public Object getDefaultNotation()",
				"documentation": ""
			},
			{
				"signature": "public Object getExtractedNotation()",
				"documentation": ""
			}
		],
		"interfaces": [
			"DistributionDependency"
		]
	},
	{
		"documentation": "/**\n * A plugin to manage getting and extracting distributions of Elasticsearch.\n * \u003cp\u003e\n * The plugin provides hooks to register custom distribution resolutions.\n * This plugin resolves distributions from the Elastic downloads service if\n * no registered resolution strategy can resolve to a distribution.\n */",
		"name": "org.elasticsearch.gradle.DistributionDownloadPlugin",
		"extends": "",
		"Methods": [
			{
				"signature": "public DistributionDownloadPlugin(ObjectFactory objectFactory)",
				"documentation": "/**\n * A plugin to manage getting and extracting distributions of Elasticsearch.\n * \u003cp\u003e\n * The plugin provides hooks to register custom distribution resolutions.\n * This plugin resolves distributions from the Elastic downloads service if\n * no registered resolution strategy can resolve to a distribution.\n */"
			},
			{
				"signature": "public void setDockerAvailability(Provider\u003cBoolean\u003e dockerAvailability)",
				"documentation": ""
			},
			{
				"signature": "public void apply(Project project)",
				"documentation": ""
			},
			{
				"signature": "private void setupDistributionContainer(Project project, Property\u003cBoolean\u003e dockerAvailable)",
				"documentation": ""
			},
			{
				"signature": "private void setupResolutionsContainer(Project project)",
				"documentation": ""
			},
			{
				"signature": "public static NamedDomainObjectContainer\u003cElasticsearchDistribution\u003e getContainer(Project project)",
				"documentation": ""
			},
			{
				"signature": "public static NamedDomainObjectContainer\u003cDistributionResolution\u003e getRegistrationsContainer(Project project)",
				"documentation": ""
			},
			{
				"signature": "private void finalizeDistributionDependencies(Project project, ElasticsearchDistribution distribution)",
				"documentation": ""
			},
			{
				"signature": "private DistributionDependency resolveDependencyNotation(Project p, ElasticsearchDistribution distribution)",
				"documentation": ""
			},
			{
				"signature": "private static void addIvyRepo(Project project, String name, String url, String group)",
				"documentation": ""
			},
			{
				"signature": "private static void setupDownloadServiceRepo(Project project)",
				"documentation": ""
			},
			{
				"signature": "private String dependencyNotation(ElasticsearchDistribution distribution)",
				"documentation": "/**\n     * Returns a dependency object representing the given distribution.\n     * \u003cp\u003e\n     * The returned object is suitable to be passed to {@link DependencyHandler}.\n     * The concrete type of the object will be a set of maven coordinates as a {@link String}.\n     * Maven coordinates point to either the integ-test-zip coordinates on maven central, or a set of artificial\n     * coordinates that resolve to the Elastic download service through an ivy repository.\n     */"
			}
		],
		"interfaces": [
			"org.gradle.api.Plugin"
		]
	},
	{
		"documentation": "",
		"name": "org.elasticsearch.gradle.DistributionResolution",
		"extends": "",
		"Methods": [
			{
				"signature": "public DistributionResolution(String name)",
				"documentation": ""
			},
			{
				"signature": "public String getName()",
				"documentation": ""
			},
			{
				"signature": "public Resolver getResolver()",
				"documentation": ""
			},
			{
				"signature": "public void setResolver(Resolver resolver)",
				"documentation": ""
			},
			{
				"signature": "public void setPriority(int priority)",
				"documentation": ""
			},
			{
				"signature": "public int getPriority()",
				"documentation": ""
			}
		],
		"interfaces": []
	},
	{
		"documentation": "",
		"name": "org.elasticsearch.gradle.ElasticsearchDistribution",
		"extends": "",
		"Methods": [
			{
				"signature": "ElasticsearchDistribution(        String name,        ObjectFactory objectFactory,        Property\u003cBoolean\u003e dockerAvailability,        Configuration fileConfiguration,        Configuration extractedConfiguration,        Action\u003cElasticsearchDistribution\u003e distributionFinalizer    )",
				"documentation": ""
			},
			{
				"signature": "public String getName()",
				"documentation": ""
			},
			{
				"signature": "public String getVersion()",
				"documentation": ""
			},
			{
				"signature": "public void setVersion(String version)",
				"documentation": ""
			},
			{
				"signature": "public Platform getPlatform()",
				"documentation": ""
			},
			{
				"signature": "public void setPlatform(Platform platform)",
				"documentation": ""
			},
			{
				"signature": "public ElasticsearchDistributionType getType()",
				"documentation": ""
			},
			{
				"signature": "public void setType(ElasticsearchDistributionType type)",
				"documentation": ""
			},
			{
				"signature": "public void setType(String type)",
				"documentation": "/**\n     * For simplicity only public distribution types are supported here\n     * */"
			},
			{
				"signature": "public boolean getBundledJdk()",
				"documentation": ""
			},
			{
				"signature": "public boolean isDocker()",
				"documentation": ""
			},
			{
				"signature": "public void setBundledJdk(Boolean bundledJdk)",
				"documentation": ""
			},
			{
				"signature": "public boolean getFailIfUnavailable()",
				"documentation": ""
			},
			{
				"signature": "public void setFailIfUnavailable(boolean failIfUnavailable)",
				"documentation": ""
			},
			{
				"signature": "public void setArchitecture(Architecture architecture)",
				"documentation": ""
			},
			{
				"signature": "public Architecture getArchitecture()",
				"documentation": ""
			},
			{
				"signature": "public String toString()",
				"documentation": ""
			},
			{
				"signature": "public ElasticsearchDistribution maybeFreeze()",
				"documentation": "/**\n     * if not executed before, this\n     * freezes the distribution configuration and\n     * runs distribution finalizer logic.\n     */"
			},
			{
				"signature": "public String getFilepath()",
				"documentation": ""
			},
			{
				"signature": "public Configuration getExtracted()",
				"documentation": ""
			},
			{
				"signature": "public TaskDependency getBuildDependencies()",
				"documentation": ""
			},
			{
				"signature": "private boolean skippingDockerDistributionBuild()",
				"documentation": ""
			},
			{
				"signature": "public Iterator\u003cFile\u003e iterator()",
				"documentation": ""
			},
			{
				"signature": "void finalizeValues()",
				"documentation": ""
			},
			{
				"signature": "public TaskDependency getArchiveDependencies()",
				"documentation": ""
			}
		],
		"interfaces": [
			"org.gradle.api.Buildable",
			"Iterable"
		]
	},
	{
		"documentation": "",
		"name": "org.elasticsearch.gradle.public",
		"extends": "",
		"Methods": [
			{
				"signature": "public String toString()",
				"documentation": ""
			}
		],
		"interfaces": []
	},
	{
		"documentation": "/**\n * An outputstream to a File that is lazily opened on the first write.\n */",
		"name": "org.elasticsearch.gradle.LazyFileOutputStream",
		"extends": "java.io.OutputStream",
		"Methods": [
			{
				"signature": "LazyFileOutputStream(File file)",
				"documentation": "/**\n * An outputstream to a File that is lazily opened on the first write.\n */"
			},
			{
				"signature": "private void bootstrap() throws IOException",
				"documentation": "/**\n * An outputstream to a File that is lazily opened on the first write.\n */"
			},
			{
				"signature": "public void write(int b) throws IOException",
				"documentation": ""
			},
			{
				"signature": "public void write(byte b[], int off, int len) throws IOException",
				"documentation": ""
			},
			{
				"signature": "public void write(int b) throws IOException",
				"documentation": ""
			},
			{
				"signature": "public void write(byte b[], int off, int len) throws IOException",
				"documentation": ""
			},
			{
				"signature": "public void close() throws IOException",
				"documentation": ""
			}
		],
		"interfaces": []
	},
	{
		"documentation": "",
		"name": "org.elasticsearch.gradle.LazyPropertyList",
		"extends": "AbstractLazyPropertyCollection",
		"Methods": [
			{
				"signature": "public LazyPropertyList(String name)",
				"documentation": ""
			},
			{
				"signature": "public LazyPropertyList(String name, Object owner)",
				"documentation": ""
			},
			{
				"signature": "public int size()",
				"documentation": ""
			},
			{
				"signature": "public boolean isEmpty()",
				"documentation": ""
			},
			{
				"signature": "public boolean contains(Object o)",
				"documentation": ""
			},
			{
				"signature": "public Iterator\u003cT\u003e iterator()",
				"documentation": ""
			},
			{
				"signature": "public Object[] toArray()",
				"documentation": ""
			},
			{
				"signature": "public \u003cT1\u003e T1[] toArray(T1[] a)",
				"documentation": ""
			},
			{
				"signature": "public boolean add(T t)",
				"documentation": ""
			},
			{
				"signature": "public boolean add(Supplier\u003cT\u003e supplier)",
				"documentation": ""
			},
			{
				"signature": "public boolean add(Supplier\u003cT\u003e supplier, PropertyNormalization normalization)",
				"documentation": ""
			},
			{
				"signature": "public boolean remove(Object o)",
				"documentation": ""
			},
			{
				"signature": "public boolean containsAll(Collection\u003c?\u003e c)",
				"documentation": ""
			},
			{
				"signature": "public boolean addAll(Collection\u003c? extends T\u003e c)",
				"documentation": ""
			},
			{
				"signature": "public boolean addAll(int index, Collection\u003c? extends T\u003e c)",
				"documentation": ""
			},
			{
				"signature": "public boolean removeAll(Collection\u003c?\u003e c)",
				"documentation": ""
			},
			{
				"signature": "public boolean retainAll(Collection\u003c?\u003e c)",
				"documentation": ""
			},
			{
				"signature": "public void clear()",
				"documentation": ""
			},
			{
				"signature": "public T get(int index)",
				"documentation": ""
			},
			{
				"signature": "public T set(int index, T element)",
				"documentation": ""
			},
			{
				"signature": "public void add(int index, T element)",
				"documentation": ""
			},
			{
				"signature": "public T remove(int index)",
				"documentation": ""
			},
			{
				"signature": "public int indexOf(Object o)",
				"documentation": ""
			},
			{
				"signature": "public int lastIndexOf(Object o)",
				"documentation": ""
			},
			{
				"signature": "public ListIterator\u003cT\u003e listIterator()",
				"documentation": ""
			},
			{
				"signature": "public ListIterator\u003cT\u003e listIterator(int index)",
				"documentation": ""
			},
			{
				"signature": "public List\u003cT\u003e subList(int fromIndex, int toIndex)",
				"documentation": ""
			},
			{
				"signature": "public List\u003c? extends PropertyListEntry\u003cT\u003e\u003e getNormalizedCollection()",
				"documentation": ""
			},
			{
				"signature": "public List\u003c? extends T\u003e getFlatNormalizedCollection()",
				"documentation": "/**\n     * Return a \"flattened\" collection. This should be used when the collection type is itself a complex type with properties\n     * annotated as Gradle inputs rather than a simple type like {@link String}.\n     *\n     * @return a flattened collection filtered according to normalization strategy\n     */"
			},
			{
				"signature": "private void validate(PropertyListEntry\u003cT\u003e entry)",
				"documentation": ""
			}
		],
		"interfaces": [
			"java.util.List"
		]
	},
	{
		"documentation": "",
		"name": "org.elasticsearch.gradle.PropertyListEntry",
		"extends": "",
		"Methods": [
			{
				"signature": "PropertyListEntry(Supplier\u003cT\u003e supplier, PropertyNormalization normalization)",
				"documentation": ""
			},
			{
				"signature": "public PropertyNormalization getNormalization()",
				"documentation": ""
			},
			{
				"signature": "public T getValue()",
				"documentation": ""
			}
		],
		"interfaces": []
	},
	{
		"documentation": "",
		"name": "org.elasticsearch.gradle.LazyPropertyMap",
		"extends": "AbstractLazyPropertyCollection",
		"Methods": [
			{
				"signature": "public LazyPropertyMap(String name)",
				"documentation": ""
			},
			{
				"signature": "public LazyPropertyMap(String name, Object owner)",
				"documentation": ""
			},
			{
				"signature": "public LazyPropertyMap(String name, Object owner, BiFunction\u003cK, V, ?\u003e normalizationMapper)",
				"documentation": ""
			},
			{
				"signature": "public int size()",
				"documentation": ""
			},
			{
				"signature": "public boolean isEmpty()",
				"documentation": ""
			},
			{
				"signature": "public boolean containsKey(Object key)",
				"documentation": ""
			},
			{
				"signature": "public boolean containsValue(Object value)",
				"documentation": ""
			},
			{
				"signature": "public V get(Object key)",
				"documentation": ""
			},
			{
				"signature": "public V put(K key, V value)",
				"documentation": ""
			},
			{
				"signature": "public V put(K key, V value, PropertyNormalization normalization)",
				"documentation": ""
			},
			{
				"signature": "public V put(K key, Supplier\u003cV\u003e supplier)",
				"documentation": ""
			},
			{
				"signature": "public V put(K key, Supplier\u003cV\u003e supplier, PropertyNormalization normalization)",
				"documentation": ""
			},
			{
				"signature": "public V remove(Object key)",
				"documentation": ""
			},
			{
				"signature": "public void putAll(Map\u003c? extends K, ? extends V\u003e m)",
				"documentation": ""
			},
			{
				"signature": "public void clear()",
				"documentation": ""
			},
			{
				"signature": "public Set\u003cK\u003e keySet()",
				"documentation": ""
			},
			{
				"signature": "public Collection\u003cV\u003e values()",
				"documentation": ""
			},
			{
				"signature": "public Set\u003cEntry\u003cK, V\u003e\u003e entrySet()",
				"documentation": ""
			},
			{
				"signature": "public List\u003c? extends Object\u003e getNormalizedCollection()",
				"documentation": ""
			},
			{
				"signature": "private void validate(Map.Entry\u003cK, PropertyMapEntry\u003cK, V\u003e\u003e entry)",
				"documentation": ""
			},
			{
				"signature": "private void validate(PropertyMapEntry\u003cK, V\u003e supplier)",
				"documentation": ""
			}
		],
		"interfaces": [
			"java.util.Map"
		]
	},
	{
		"documentation": "",
		"name": "org.elasticsearch.gradle.LazyPropertyMap.PropertyMapEntry",
		"extends": "",
		"Methods": [
			{
				"signature": "PropertyMapEntry(K key, Supplier\u003cV\u003e value, PropertyNormalization normalization)",
				"documentation": ""
			},
			{
				"signature": "public PropertyNormalization getNormalization()",
				"documentation": ""
			},
			{
				"signature": "public String getName()",
				"documentation": ""
			},
			{
				"signature": "public K getKey()",
				"documentation": ""
			},
			{
				"signature": "public V getValue()",
				"documentation": ""
			}
		],
		"interfaces": [
			"org.gradle.api.Named"
		]
	},
	{
		"documentation": "/**\n * A wrapper around gradle's Exec task to capture output and log on error.\n */",
		"name": "org.elasticsearch.gradle.LoggedExec",
		"extends": "org.gradle.api.tasks.Exec",
		"Methods": [
			{
				"signature": "public LoggedExec(FileSystemOperations fileSystemOperations)",
				"documentation": "/**\n * A wrapper around gradle's Exec task to capture output and log on error.\n */"
			},
			{
				"signature": "public void execute(Task task)",
				"documentation": "/**\n * A wrapper around gradle's Exec task to capture output and log on error.\n */"
			},
			{
				"signature": "public void setSpoolOutput(boolean spoolOutput)",
				"documentation": ""
			},
			{
				"signature": "public static ExecResult exec(ExecOperations execOperations, Action\u003cExecSpec\u003e action)",
				"documentation": ""
			},
			{
				"signature": "public static ExecResult javaexec(ExecOperations project, Action\u003cJavaExecSpec\u003e action)",
				"documentation": ""
			},
			{
				"signature": "private static \u003cT extends BaseExecSpec\u003e ExecResult genericExec(Function\u003cAction\u003cT\u003e, ExecResult\u003e function, Action\u003cT\u003e action)",
				"documentation": ""
			},
			{
				"signature": "public WorkResult delete(Object... objects)",
				"documentation": ""
			}
		],
		"interfaces": [
			"FileSystemOperationsAware"
		]
	},
	{
		"documentation": "",
		"name": "org.elasticsearch.gradle.OS",
		"extends": "",
		"Methods": [
			{
				"signature": "public static OS current()",
				"documentation": ""
			},
			{
				"signature": "public static \u003cT\u003e Conditional\u003cT\u003e conditional()",
				"documentation": ""
			},
			{
				"signature": "public static Conditional\u003cString\u003e conditionalString()",
				"documentation": ""
			}
		],
		"interfaces": []
	},
	{
		"documentation": "",
		"name": "org.elasticsearch.gradle.OS.Conditional",
		"extends": "",
		"Methods": [
			{
				"signature": "public Conditional\u003cT\u003e onWindows(Supplier\u003cT\u003e supplier)",
				"documentation": ""
			},
			{
				"signature": "public Conditional\u003cT\u003e onLinux(Supplier\u003cT\u003e supplier)",
				"documentation": ""
			},
			{
				"signature": "public Conditional\u003cT\u003e onMac(Supplier\u003cT\u003e supplier)",
				"documentation": ""
			},
			{
				"signature": "public Conditional\u003cT\u003e onUnix(Supplier\u003cT\u003e supplier)",
				"documentation": ""
			},
			{
				"signature": "public T supply()",
				"documentation": ""
			}
		],
		"interfaces": []
	},
	{
		"documentation": "",
		"name": "org.elasticsearch.gradle.PropertyNormalization",
		"extends": "",
		"Methods": [],
		"interfaces": []
	},
	{
		"documentation": "/**\n * A plugin to handle reaping external services spawned by a build if Gradle dies.\n */",
		"name": "org.elasticsearch.gradle.ReaperPlugin",
		"extends": "",
		"Methods": [
			{
				"signature": "ReaperPlugin(ProjectLayout projectLayout)",
				"documentation": "/**\n     * The unique identifier to register the reaper shared service within a gradle build\n     * */"
			},
			{
				"signature": "public void apply(Project project)",
				"documentation": ""
			},
			{
				"signature": "public static void registerReaperService(Project project, ProjectLayout projectLayout, boolean internal)",
				"documentation": ""
			}
		],
		"interfaces": [
			"org.gradle.api.Plugin"
		]
	},
	{
		"documentation": "",
		"name": "org.elasticsearch.gradle.ReaperService",
		"extends": "",
		"Methods": [
			{
				"signature": "public void registerPid(String serviceId, long pid)",
				"documentation": "/**\n     * Register a pid that will be killed by the reaper.\n     */"
			},
			{
				"signature": "public void registerCommand(String serviceId, String... command)",
				"documentation": "/**\n     * Register a system command that will be run by the reaper.\n     */"
			},
			{
				"signature": "private Path getCmdFile(String serviceId)",
				"documentation": ""
			},
			{
				"signature": "public void unregister(String serviceId)",
				"documentation": ""
			},
			{
				"signature": "void shutdown()",
				"documentation": ""
			},
			{
				"signature": "private Path logFilePath()",
				"documentation": ""
			},
			{
				"signature": "private Path locateReaperJar()",
				"documentation": ""
			},
			{
				"signature": "private void ensureReaperAlive()",
				"documentation": ""
			},
			{
				"signature": "public void close() throws Exception",
				"documentation": ""
			}
		],
		"interfaces": [
			"org.gradle.api.services.BuildService",
			"AutoCloseable"
		]
	},
	{
		"documentation": "/**\n * Encapsulates comparison and printing logic for an x.y.z version.\n */",
		"name": "org.elasticsearch.gradle.Version",
		"extends": "",
		"Methods": [
			{
				"signature": "public Version(int major, int minor, int revision)",
				"documentation": ""
			},
			{
				"signature": "public Version(int major, int minor, int revision, String qualifier)",
				"documentation": ""
			},
			{
				"signature": "public static Version fromString(final String s)",
				"documentation": ""
			},
			{
				"signature": "public static Version fromString(final String s, final Mode mode)",
				"documentation": ""
			},
			{
				"signature": "public String toString()",
				"documentation": ""
			},
			{
				"signature": "public boolean before(Version compareTo)",
				"documentation": ""
			},
			{
				"signature": "public boolean before(String compareTo)",
				"documentation": ""
			},
			{
				"signature": "public boolean onOrBefore(Version compareTo)",
				"documentation": ""
			},
			{
				"signature": "public boolean onOrBefore(String compareTo)",
				"documentation": ""
			},
			{
				"signature": "public boolean onOrAfter(Version compareTo)",
				"documentation": ""
			},
			{
				"signature": "public boolean onOrAfter(String compareTo)",
				"documentation": ""
			},
			{
				"signature": "public boolean after(Version compareTo)",
				"documentation": ""
			},
			{
				"signature": "public boolean after(String compareTo)",
				"documentation": ""
			},
			{
				"signature": "public boolean equals(Object o)",
				"documentation": ""
			},
			{
				"signature": "public int hashCode()",
				"documentation": ""
			},
			{
				"signature": "public int getMajor()",
				"documentation": ""
			},
			{
				"signature": "public int getMinor()",
				"documentation": ""
			},
			{
				"signature": "public int getRevision()",
				"documentation": ""
			},
			{
				"signature": "protected int getId()",
				"documentation": ""
			},
			{
				"signature": "public String getQualifier()",
				"documentation": ""
			},
			{
				"signature": "public int compareTo(Version other)",
				"documentation": ""
			}
		],
		"interfaces": [
			"Comparable",
			"java.io.Serializable"
		]
	},
	{
		"documentation": "/**\n     * Specifies how a version string should be parsed.\n     */",
		"name": "org.elasticsearch.gradle.public",
		"extends": "",
		"Methods": [],
		"interfaces": []
	},
	{
		"documentation": "/**\n * Accessor for shared dependency versions used by elasticsearch, namely the elasticsearch and lucene versions.\n */",
		"name": "org.elasticsearch.gradle.VersionProperties",
		"extends": "",
		"Methods": [
			{
				"signature": "public static String getElasticsearch()",
				"documentation": "/**\n * Accessor for shared dependency versions used by elasticsearch, namely the elasticsearch and lucene versions.\n */"
			},
			{
				"signature": "public static Version getElasticsearchVersion()",
				"documentation": ""
			},
			{
				"signature": "public static String getLucene()",
				"documentation": ""
			},
			{
				"signature": "public static String getBundledJdkVersion()",
				"documentation": ""
			},
			{
				"signature": "public static String getBundledJdkVendor()",
				"documentation": ""
			},
			{
				"signature": "public static Map\u003cString, String\u003e getVersions()",
				"documentation": ""
			},
			{
				"signature": "static",
				"documentation": ""
			},
			{
				"signature": "private static Properties getVersionProperties()",
				"documentation": ""
			},
			{
				"signature": "public static boolean isElasticsearchSnapshot()",
				"documentation": ""
			}
		],
		"interfaces": []
	},
	{
		"documentation": "",
		"name": "org.elasticsearch.gradle.dependencies.CompileOnlyResolvePlugin",
		"extends": "",
		"Methods": [
			{
				"signature": "public void apply(Project project)",
				"documentation": ""
			}
		],
		"interfaces": [
			"org.gradle.api.Plugin"
		]
	},
	{
		"documentation": "",
		"name": "org.elasticsearch.gradle.distribution.ArchiveElasticsearchDistributionType",
		"extends": "",
		"Methods": [
			{
				"signature": "ArchiveElasticsearchDistributionType()",
				"documentation": ""
			},
			{
				"signature": "public String getName()",
				"documentation": ""
			},
			{
				"signature": "public String getExtension(ElasticsearchDistribution.Platform platform)",
				"documentation": ""
			},
			{
				"signature": "public String getClassifier(ElasticsearchDistribution.Platform platform, Version version)",
				"documentation": ""
			},
			{
				"signature": "public boolean shouldExtract()",
				"documentation": ""
			}
		],
		"interfaces": [
			"org.elasticsearch.gradle.ElasticsearchDistributionType"
		]
	},
	{
		"documentation": "",
		"name": "org.elasticsearch.gradle.distribution.ElasticsearchDistributionTypes",
		"extends": "",
		"Methods": [],
		"interfaces": []
	},
	{
		"documentation": "",
		"name": "org.elasticsearch.gradle.distribution.IntegTestZipElasticsearchDistributionType",
		"extends": "",
		"Methods": [
			{
				"signature": "IntegTestZipElasticsearchDistributionType()",
				"documentation": ""
			},
			{
				"signature": "public String getName()",
				"documentation": ""
			},
			{
				"signature": "public boolean shouldExtract()",
				"documentation": ""
			}
		],
		"interfaces": [
			"org.elasticsearch.gradle.ElasticsearchDistributionType"
		]
	},
	{
		"documentation": "",
		"name": "org.elasticsearch.gradle.jarhell.JarHellPlugin",
		"extends": "",
		"Methods": [
			{
				"signature": "public void apply(Project project)",
				"documentation": ""
			},
			{
				"signature": "private TaskProvider\u003c? extends Task\u003e createTask(Project project)",
				"documentation": ""
			},
			{
				"signature": "private static SourceSet getJavaTestSourceSet(Project project)",
				"documentation": "/**\n     * @param project The project to look for test Java resources.\n     */"
			}
		],
		"interfaces": [
			"org.gradle.api.Plugin"
		]
	},
	{
		"documentation": "/**\n * Runs CheckJarHell on a classpath.\n */",
		"name": "org.elasticsearch.gradle.jarhell.JarHellTask",
		"extends": "org.gradle.api.DefaultTask",
		"Methods": [
			{
				"signature": "public JarHellTask(ExecOperations execOperations, ProjectLayout projectLayout)",
				"documentation": "/**\n * Runs CheckJarHell on a classpath.\n */"
			},
			{
				"signature": "public File getSuccessMarker()",
				"documentation": ""
			},
			{
				"signature": "public void runJarHellCheck() throws IOException",
				"documentation": ""
			},
			{
				"signature": "private void writeMarker() throws IOException",
				"documentation": ""
			},
			{
				"signature": "public FileCollection getClasspath()",
				"documentation": ""
			},
			{
				"signature": "public void setClasspath(FileCollection classpath)",
				"documentation": ""
			},
			{
				"signature": "public FileCollection getJarHellRuntimeClasspath()",
				"documentation": ""
			},
			{
				"signature": "public void setJarHellRuntimeClasspath(FileCollection jarHellRuntimeClasspath)",
				"documentation": ""
			}
		],
		"interfaces": []
	},
	{
		"documentation": "/**\n * Encapsulates build configuration for an Elasticsearch plugin.\n */",
		"name": "org.elasticsearch.gradle.plugin.PluginBuildPlugin",
		"extends": "",
		"Methods": [
			{
				"signature": "public void apply(final Project project)",
				"documentation": "/**\n * Encapsulates build configuration for an Elasticsearch plugin.\n */"
			},
			{
				"signature": "private static NamedDomainObjectContainer\u003cElasticsearchCluster\u003e testClusters(Project project, String extensionName)",
				"documentation": ""
			},
			{
				"signature": "private static void configurePublishing(Project project, PluginPropertiesExtension extension)",
				"documentation": ""
			},
			{
				"signature": "private static void configureDependencies(final Project project)",
				"documentation": ""
			},
			{
				"signature": "private static TaskProvider\u003cZip\u003e createBundleTasks(final Project project, PluginPropertiesExtension extension)",
				"documentation": "/**\n     * Adds bundle tasks which builds the dir and zip containing the plugin jars,\n     * metadata, properties, and packaging files\n     */"
			},
			{
				"signature": "public void execute(Task task)",
				"documentation": "/**\n     * Adds bundle tasks which builds the dir and zip containing the plugin jars,\n     * metadata, properties, and packaging files\n     */"
			},
			{
				"signature": "public void execute(Task task)",
				"documentation": "/**\n     * Adds bundle tasks which builds the dir and zip containing the plugin jars,\n     * metadata, properties, and packaging files\n     */"
			},
			{
				"signature": "private static CopySpec createBundleSpec(Project project, File pluginMetadata, TaskProvider\u003cCopy\u003e buildProperties)",
				"documentation": ""
			}
		],
		"interfaces": [
			"org.gradle.api.Plugin"
		]
	},
	{
		"documentation": "/**\n * A container for plugin properties that will be written to the plugin descriptor, for easy\n * manipulation in the gradle DSL.\n */",
		"name": "org.elasticsearch.gradle.plugin.PluginPropertiesExtension",
		"extends": "",
		"Methods": [
			{
				"signature": "public PluginPropertiesExtension(Project project)",
				"documentation": "/**\n     * A notice file that should be included in the built plugin zip. This will be\n     * extended with notices from the {@code licenses/} directory.\n     */"
			},
			{
				"signature": "public String getName()",
				"documentation": ""
			},
			{
				"signature": "public void setName(String name)",
				"documentation": ""
			},
			{
				"signature": "public String getVersion()",
				"documentation": ""
			},
			{
				"signature": "public void setVersion(String version)",
				"documentation": ""
			},
			{
				"signature": "public String getDescription()",
				"documentation": ""
			},
			{
				"signature": "public void setDescription(String description)",
				"documentation": ""
			},
			{
				"signature": "public String getClassname()",
				"documentation": ""
			},
			{
				"signature": "public void setClassname(String classname)",
				"documentation": ""
			},
			{
				"signature": "public List\u003cString\u003e getExtendedPlugins()",
				"documentation": ""
			},
			{
				"signature": "public boolean isHasNativeController()",
				"documentation": ""
			},
			{
				"signature": "public void setHasNativeController(boolean hasNativeController)",
				"documentation": ""
			},
			{
				"signature": "public PluginType getType()",
				"documentation": ""
			},
			{
				"signature": "public void setType(PluginType type)",
				"documentation": ""
			},
			{
				"signature": "public String getJavaOpts()",
				"documentation": ""
			},
			{
				"signature": "public void setJavaOpts(String javaOpts)",
				"documentation": ""
			},
			{
				"signature": "public boolean isLicensed()",
				"documentation": ""
			},
			{
				"signature": "public void setLicensed(boolean licensed)",
				"documentation": ""
			},
			{
				"signature": "public boolean isRequiresKeystore()",
				"documentation": ""
			},
			{
				"signature": "public void setRequiresKeystore(boolean requiresKeystore)",
				"documentation": ""
			},
			{
				"signature": "public File getLicenseFile()",
				"documentation": ""
			},
			{
				"signature": "public void setLicenseFile(File licenseFile)",
				"documentation": ""
			},
			{
				"signature": "public File getNoticeFile()",
				"documentation": ""
			},
			{
				"signature": "public void setNoticeFile(File noticeFile)",
				"documentation": ""
			},
			{
				"signature": "public Project getProject()",
				"documentation": ""
			},
			{
				"signature": "public void setExtendedPlugins(List\u003cString\u003e extendedPlugins)",
				"documentation": ""
			},
			{
				"signature": "public void setBundleSpec(CopySpec bundleSpec)",
				"documentation": ""
			},
			{
				"signature": "public CopySpec getBundleSpec()",
				"documentation": ""
			}
		],
		"interfaces": []
	},
	{
		"documentation": "/**\n * This mirrors org.elasticsearch.plugins.PluginType, which is not\n * available to the Gradle plugin that actually builds plugins. See that\n * class for further information.\n */",
		"name": "org.elasticsearch.gradle.plugin.PluginType",
		"extends": "",
		"Methods": [
			{
				"signature": "public String toString()",
				"documentation": "/**\n * This mirrors org.elasticsearch.plugins.PluginType, which is not\n * available to the Gradle plugin that actually builds plugins. See that\n * class for further information.\n */"
			}
		],
		"interfaces": []
	},
	{
		"documentation": "",
		"name": "org.elasticsearch.gradle.test.GradleTestPolicySetupPlugin",
		"extends": "",
		"Methods": [
			{
				"signature": "public void apply(Project project)",
				"documentation": ""
			}
		],
		"interfaces": [
			"org.gradle.api.Plugin"
		]
	},
	{
		"documentation": "",
		"name": "org.elasticsearch.gradle.test.JavaRestTestPlugin",
		"extends": "",
		"Methods": [
			{
				"signature": "public void apply(Project project)",
				"documentation": ""
			}
		],
		"interfaces": [
			"org.gradle.api.Plugin"
		]
	},
	{
		"documentation": "",
		"name": "org.elasticsearch.gradle.test.SystemPropertyCommandLineArgumentProvider",
		"extends": "",
		"Methods": [
			{
				"signature": "public void systemProperty(String key, Provider\u003cObject\u003e value)",
				"documentation": ""
			},
			{
				"signature": "public void systemProperty(String key, Supplier\u003cString\u003e value)",
				"documentation": ""
			},
			{
				"signature": "public void systemProperty(String key, Object value)",
				"documentation": ""
			},
			{
				"signature": "public Iterable\u003cString\u003e asArguments()",
				"documentation": ""
			},
			{
				"signature": "public Iterable\u003cString\u003e getPropertyNames()",
				"documentation": ""
			}
		],
		"interfaces": [
			"org.gradle.process.CommandLineArgumentProvider"
		]
	},
	{
		"documentation": "",
		"name": "org.elasticsearch.gradle.test.YamlRestTestPlugin",
		"extends": "",
		"Methods": [
			{
				"signature": "public void apply(Project project)",
				"documentation": ""
			},
			{
				"signature": "private static void setupDefaultDependencies(        DependencyHandler dependencyHandler,        Configuration restTestSpecs,        Configuration yamlRestTestImplementation    )",
				"documentation": ""
			},
			{
				"signature": "private TaskProvider\u003cStandaloneRestIntegTestTask\u003e setupTestTask(        Project project,        SourceSet testSourceSet,        NamedDomainObjectProvider\u003cElasticsearchCluster\u003e clusterProvider    )",
				"documentation": ""
			}
		],
		"interfaces": [
			"org.gradle.api.Plugin"
		]
	},
	{
		"documentation": "",
		"name": "org.elasticsearch.gradle.testclusters.DefaultTestClustersTask",
		"extends": "org.gradle.api.DefaultTask",
		"Methods": [
			{
				"signature": "public Collection\u003cElasticsearchCluster\u003e getClusters()",
				"documentation": ""
			}
		],
		"interfaces": [
			"TestClustersAware"
		]
	},
	{
		"documentation": "",
		"name": "org.elasticsearch.gradle.testclusters.ElasticsearchCluster",
		"extends": "",
		"Methods": [
			{
				"signature": "public ElasticsearchCluster(        String path,        String clusterName,        Project project,        Provider\u003cReaperService\u003e reaper,        FileSystemOperations fileSystemOperations,        ArchiveOperations archiveOperations,        ExecOperations execOperations,        FileOperations fileOperations,        File workingDirBase,        Provider\u003cFile\u003e runtimeJava,        Function\u003cVersion, Boolean\u003e isReleasedVersion    )",
				"documentation": ""
			},
			{
				"signature": "public void setNumberOfNodes(int numberOfNodes)",
				"documentation": ""
			},
			{
				"signature": "public void setReadinessEnabled(boolean enabled)",
				"documentation": ""
			},
			{
				"signature": "public ElasticsearchNode getFirstNode()",
				"documentation": ""
			},
			{
				"signature": "public ElasticsearchNode getLastNode()",
				"documentation": ""
			},
			{
				"signature": "public int getNumberOfNodes()",
				"documentation": ""
			},
			{
				"signature": "public String getName()",
				"documentation": ""
			},
			{
				"signature": "public String getPath()",
				"documentation": ""
			},
			{
				"signature": "public void setVersion(String version)",
				"documentation": ""
			},
			{
				"signature": "public void setVersions(List\u003cString\u003e version)",
				"documentation": ""
			},
			{
				"signature": "public void setTestDistribution(TestDistribution distribution)",
				"documentation": ""
			},
			{
				"signature": "public void plugin(Provider\u003cRegularFile\u003e plugin)",
				"documentation": ""
			},
			{
				"signature": "public void plugin(TaskProvider\u003cZip\u003e plugin)",
				"documentation": ""
			},
			{
				"signature": "public void plugin(String pluginProjectPath)",
				"documentation": ""
			},
			{
				"signature": "public void module(Provider\u003cRegularFile\u003e module)",
				"documentation": ""
			},
			{
				"signature": "public void module(TaskProvider\u003cSync\u003e module)",
				"documentation": ""
			},
			{
				"signature": "public void module(String moduleProjectPath)",
				"documentation": ""
			},
			{
				"signature": "public void keystore(String key, String value)",
				"documentation": ""
			},
			{
				"signature": "public void keystore(String key, Supplier\u003cCharSequence\u003e valueSupplier)",
				"documentation": ""
			},
			{
				"signature": "public void keystore(String key, File value)",
				"documentation": ""
			},
			{
				"signature": "public void keystore(String key, File value, PropertyNormalization normalization)",
				"documentation": ""
			},
			{
				"signature": "public void keystore(String key, FileSupplier valueSupplier)",
				"documentation": ""
			},
			{
				"signature": "public void keystorePassword(String password)",
				"documentation": ""
			},
			{
				"signature": "public void cliSetup(String binTool, CharSequence... args)",
				"documentation": ""
			},
			{
				"signature": "public void setting(String key, String value)",
				"documentation": ""
			},
			{
				"signature": "public void setting(String key, String value, PropertyNormalization normalization)",
				"documentation": ""
			},
			{
				"signature": "public void setting(String key, Supplier\u003cCharSequence\u003e valueSupplier)",
				"documentation": ""
			},
			{
				"signature": "public void setting(String key, Supplier\u003cCharSequence\u003e valueSupplier, PropertyNormalization normalization)",
				"documentation": ""
			},
			{
				"signature": "public void systemProperty(String key, String value)",
				"documentation": ""
			},
			{
				"signature": "public void systemProperty(String key, Supplier\u003cCharSequence\u003e valueSupplier)",
				"documentation": ""
			},
			{
				"signature": "public void systemProperty(String key, Supplier\u003cCharSequence\u003e valueSupplier, PropertyNormalization normalization)",
				"documentation": ""
			},
			{
				"signature": "public void environment(String key, String value)",
				"documentation": ""
			},
			{
				"signature": "public void environment(String key, Supplier\u003cCharSequence\u003e valueSupplier)",
				"documentation": ""
			},
			{
				"signature": "public void environment(String key, Supplier\u003cCharSequence\u003e valueSupplier, PropertyNormalization normalization)",
				"documentation": ""
			},
			{
				"signature": "public void jvmArgs(String... values)",
				"documentation": ""
			},
			{
				"signature": "public boolean isPreserveDataDir()",
				"documentation": ""
			},
			{
				"signature": "public void setPreserveDataDir(boolean preserveDataDir)",
				"documentation": ""
			},
			{
				"signature": "public void freeze()",
				"documentation": ""
			},
			{
				"signature": "private void checkFrozen()",
				"documentation": ""
			},
			{
				"signature": "public void start()",
				"documentation": ""
			},
			{
				"signature": "private void commonNodeConfig()",
				"documentation": ""
			},
			{
				"signature": "public void restart()",
				"documentation": ""
			},
			{
				"signature": "public void goToNextVersion()",
				"documentation": ""
			},
			{
				"signature": "public void nextNodeToNextVersion()",
				"documentation": ""
			},
			{
				"signature": "public void extraConfigFile(String destination, File from)",
				"documentation": ""
			},
			{
				"signature": "public void extraConfigFile(String destination, File from, PropertyNormalization normalization)",
				"documentation": ""
			},
			{
				"signature": "public void extraJarFiles(FileCollection from)",
				"documentation": ""
			},
			{
				"signature": "public void user(Map\u003cString, String\u003e userSpec)",
				"documentation": ""
			},
			{
				"signature": "public void rolesFile(File rolesYml)",
				"documentation": ""
			},
			{
				"signature": "public void requiresFeature(String feature, Version from)",
				"documentation": ""
			},
			{
				"signature": "public void requiresFeature(String feature, Version from, Version until)",
				"documentation": ""
			},
			{
				"signature": "private void writeUnicastHostsFiles()",
				"documentation": ""
			},
			{
				"signature": "public String getHttpSocketURI()",
				"documentation": ""
			},
			{
				"signature": "public String getTransportPortURI()",
				"documentation": ""
			},
			{
				"signature": "public String getReadinessPortURI()",
				"documentation": ""
			},
			{
				"signature": "public List\u003cString\u003e getAllHttpSocketURI()",
				"documentation": ""
			},
			{
				"signature": "public List\u003cString\u003e getAllTransportPortURI()",
				"documentation": ""
			},
			{
				"signature": "public List\u003cString\u003e getAllReadinessPortURI()",
				"documentation": ""
			},
			{
				"signature": "public void waitForAllConditions()",
				"documentation": ""
			},
			{
				"signature": "public void stop(boolean tailLogs)",
				"documentation": ""
			},
			{
				"signature": "public void setNameCustomization(Function\u003cString, String\u003e nameCustomization)",
				"documentation": ""
			},
			{
				"signature": "public boolean isProcessAlive()",
				"documentation": ""
			},
			{
				"signature": "public ElasticsearchNode singleNode()",
				"documentation": ""
			},
			{
				"signature": "private void addWaitForClusterHealth()",
				"documentation": ""
			},
			{
				"signature": "public NamedDomainObjectContainer\u003cElasticsearchNode\u003e getNodes()",
				"documentation": ""
			},
			{
				"signature": "public boolean equals(Object o)",
				"documentation": ""
			},
			{
				"signature": "public int hashCode()",
				"documentation": ""
			},
			{
				"signature": "public String toString()",
				"documentation": ""
			}
		],
		"interfaces": [
			"TestClusterConfiguration",
			"org.gradle.api.Named"
		]
	},
	{
		"documentation": "",
		"name": "org.elasticsearch.gradle.testclusters.ElasticsearchNode",
		"extends": "",
		"Methods": [
			{
				"signature": "ElasticsearchNode(        String clusterName,        String path,        String name,        Project project,        Provider\u003cReaperService\u003e reaperServiceProvider,        FileSystemOperations fileSystemOperations,        ArchiveOperations archiveOperations,        ExecOperations execOperations,        FileOperations fileOperations,        File workingDirBase,        Provider\u003cFile\u003e runtimeJava,        Function\u003cVersion, Boolean\u003e isReleasedVersion    )",
				"documentation": ""
			},
			{
				"signature": "public String getName()",
				"documentation": ""
			},
			{
				"signature": "public Version getVersion()",
				"documentation": ""
			},
			{
				"signature": "public void setVersion(String version)",
				"documentation": ""
			},
			{
				"signature": "public void setVersions(List\u003cString\u003e versions)",
				"documentation": ""
			},
			{
				"signature": "private void doSetVersion(String version)",
				"documentation": ""
			},
			{
				"signature": "public TestDistribution getTestDistribution()",
				"documentation": ""
			},
			{
				"signature": "List\u003cElasticsearchDistribution\u003e getDistributions()",
				"documentation": ""
			},
			{
				"signature": "public void setTestDistribution(TestDistribution testDistribution)",
				"documentation": ""
			},
			{
				"signature": "private void setDistributionType(ElasticsearchDistribution distribution, TestDistribution testDistribution)",
				"documentation": ""
			},
			{
				"signature": "Collection\u003cConfiguration\u003e getPluginAndModuleConfigurations()",
				"documentation": ""
			},
			{
				"signature": "private Provider\u003cRegularFile\u003e maybeCreatePluginOrModuleDependency(String path, String consumingConfiguration)",
				"documentation": ""
			},
			{
				"signature": "public void plugin(Provider\u003cRegularFile\u003e plugin)",
				"documentation": ""
			},
			{
				"signature": "public void plugin(String pluginProjectPath)",
				"documentation": ""
			},
			{
				"signature": "public void plugin(TaskProvider\u003cZip\u003e plugin)",
				"documentation": ""
			},
			{
				"signature": "public void module(Provider\u003cRegularFile\u003e module)",
				"documentation": ""
			},
			{
				"signature": "public void module(TaskProvider\u003cSync\u003e module)",
				"documentation": ""
			},
			{
				"signature": "private void registerExtractedConfig(Provider\u003cRegularFile\u003e pluginProvider)",
				"documentation": ""
			},
			{
				"signature": "private void configureArtifactTransforms()",
				"documentation": ""
			},
			{
				"signature": "public void module(String moduleProjectPath)",
				"documentation": ""
			},
			{
				"signature": "public void keystore(String key, String value)",
				"documentation": ""
			},
			{
				"signature": "public void keystore(String key, Supplier\u003cCharSequence\u003e valueSupplier)",
				"documentation": ""
			},
			{
				"signature": "public void keystore(String key, File value)",
				"documentation": ""
			},
			{
				"signature": "public void keystore(String key, File value, PropertyNormalization normalization)",
				"documentation": ""
			},
			{
				"signature": "public void keystore(String key, FileSupplier valueSupplier)",
				"documentation": ""
			},
			{
				"signature": "public void keystorePassword(String password)",
				"documentation": ""
			},
			{
				"signature": "public void cliSetup(String binTool, CharSequence... args)",
				"documentation": ""
			},
			{
				"signature": "public void setting(String key, String value)",
				"documentation": ""
			},
			{
				"signature": "public void setting(String key, String value, PropertyNormalization normalization)",
				"documentation": ""
			},
			{
				"signature": "public void setting(String key, Supplier\u003cCharSequence\u003e valueSupplier)",
				"documentation": ""
			},
			{
				"signature": "public void setting(String key, Supplier\u003cCharSequence\u003e valueSupplier, PropertyNormalization normalization)",
				"documentation": ""
			},
			{
				"signature": "public void systemProperty(String key, String value)",
				"documentation": ""
			},
			{
				"signature": "public void systemProperty(String key, Supplier\u003cCharSequence\u003e valueSupplier)",
				"documentation": ""
			},
			{
				"signature": "public void systemProperty(String key, Supplier\u003cCharSequence\u003e valueSupplier, PropertyNormalization normalization)",
				"documentation": ""
			},
			{
				"signature": "public void environment(String key, String value)",
				"documentation": ""
			},
			{
				"signature": "public void environment(String key, Supplier\u003cCharSequence\u003e valueSupplier)",
				"documentation": ""
			},
			{
				"signature": "public void environment(String key, Supplier\u003cCharSequence\u003e valueSupplier, PropertyNormalization normalization)",
				"documentation": ""
			},
			{
				"signature": "public void jvmArgs(String... values)",
				"documentation": ""
			},
			{
				"signature": "public Path getConfigDir()",
				"documentation": ""
			},
			{
				"signature": "public boolean isPreserveDataDir()",
				"documentation": ""
			},
			{
				"signature": "public void setPreserveDataDir(boolean preserveDataDir)",
				"documentation": ""
			},
			{
				"signature": "public void freeze()",
				"documentation": ""
			},
			{
				"signature": "private boolean canUseSharedDistribution()",
				"documentation": ""
			},
			{
				"signature": "private void logToProcessStdout(String message)",
				"documentation": ""
			},
			{
				"signature": "public void restart()",
				"documentation": ""
			},
			{
				"signature": "void goToNextVersion()",
				"documentation": ""
			},
			{
				"signature": "private boolean isSettingTrue(String name)",
				"documentation": ""
			},
			{
				"signature": "private void copyExtraConfigFiles()",
				"documentation": ""
			},
			{
				"signature": "private void copyExtraJars()",
				"documentation": "/**\n     * Copies extra jars to the `/lib` directory.\n     * //TODO: Remove this when system modules are available\n     */"
			},
			{
				"signature": "private void configureSecurity()",
				"documentation": ""
			},
			{
				"signature": "private void installModules()",
				"documentation": ""
			},
			{
				"signature": "public void extraConfigFile(String destination, File from)",
				"documentation": ""
			},
			{
				"signature": "public void extraConfigFile(String destination, File from, PropertyNormalization normalization)",
				"documentation": ""
			},
			{
				"signature": "public void extraJarFiles(FileCollection from)",
				"documentation": ""
			},
			{
				"signature": "public void user(Map\u003cString, String\u003e userSpec)",
				"documentation": ""
			},
			{
				"signature": "private File getBuildPluginFile(String name)",
				"documentation": ""
			},
			{
				"signature": "public void rolesFile(File rolesYml)",
				"documentation": ""
			},
			{
				"signature": "public void requiresFeature(String feature, Version from)",
				"documentation": ""
			},
			{
				"signature": "public void requiresFeature(String feature, Version from, Version until)",
				"documentation": ""
			},
			{
				"signature": "private void runElasticsearchBinScriptWithInput(String input, String tool, CharSequence... args)",
				"documentation": ""
			},
			{
				"signature": "private void runKeystoreCommandWithPassword(String keystorePassword, String input, CharSequence... args)",
				"documentation": ""
			},
			{
				"signature": "private void runElasticsearchBinScript(String tool, CharSequence... args)",
				"documentation": ""
			},
			{
				"signature": "private Map\u003cString, String\u003e getESEnvironment()",
				"documentation": ""
			},
			{
				"signature": "private void startElasticsearchProcess()",
				"documentation": ""
			},
			{
				"signature": "public Path getDistroDir()",
				"documentation": ""
			},
			{
				"signature": "public String getHttpSocketURI()",
				"documentation": ""
			},
			{
				"signature": "public String getTransportPortURI()",
				"documentation": ""
			},
			{
				"signature": "public String getReadinessPortURI()",
				"documentation": ""
			},
			{
				"signature": "public List\u003cString\u003e getAllHttpSocketURI()",
				"documentation": ""
			},
			{
				"signature": "public List\u003cString\u003e getAllTransportPortURI()",
				"documentation": ""
			},
			{
				"signature": "public List\u003cString\u003e getAllReadinessPortURI()",
				"documentation": ""
			},
			{
				"signature": "public File getServerLog()",
				"documentation": ""
			},
			{
				"signature": "public File getAuditLog()",
				"documentation": ""
			},
			{
				"signature": "public void setNameCustomization(Function\u003cString, String\u003e nameCustomizer)",
				"documentation": ""
			},
			{
				"signature": "private void stopHandle(ProcessHandle processHandle, boolean forcibly)",
				"documentation": ""
			},
			{
				"signature": "private void logProcessInfo(String prefix, ProcessHandle.Info info)",
				"documentation": ""
			},
			{
				"signature": "private void logFileContents(String description, Path from, boolean tailLogs)",
				"documentation": ""
			},
			{
				"signature": "private String normalizeLogLine(String line)",
				"documentation": ""
			},
			{
				"signature": "private void waitForProcessToExit(ProcessHandle processHandle)",
				"documentation": ""
			},
			{
				"signature": "private void createWorkingDir() throws IOException",
				"documentation": ""
			},
			{
				"signature": "private void setupNodeDistribution(Path distroExtractDir) throws IOException",
				"documentation": ""
			},
			{
				"signature": "private void syncWithLinks(Path sourceRoot, Path destinationRoot)",
				"documentation": "/**\n     * Does the equivalent of `cp -lr` and `chmod -r a-w` to save space and improve speed.\n     * We remove write permissions to make sure files are note mistakenly edited ( e.x. the config file ) and changes\n     * reflected across all copies. Permissions are retained to be able to replace the links.\n     *\n     * @param sourceRoot      where to copy from\n     * @param destinationRoot destination to link to\n     */"
			},
			{
				"signature": "private void syncWithCopy(Path sourceRoot, Path destinationRoot)",
				"documentation": ""
			},
			{
				"signature": "private void sync(Path sourceRoot, Path destinationRoot, BiConsumer\u003cPath, Path\u003e syncMethod)",
				"documentation": ""
			},
			{
				"signature": "private void createConfiguration()",
				"documentation": ""
			},
			{
				"signature": "private void tweakJvmOptions(Path configFileRoot)",
				"documentation": ""
			},
			{
				"signature": "private Map\u003cString, String\u003e jvmOptionExpansions()",
				"documentation": ""
			},
			{
				"signature": "private void checkFrozen()",
				"documentation": ""
			},
			{
				"signature": "private List\u003cString\u003e getTransportPortInternal()",
				"documentation": ""
			},
			{
				"signature": "private List\u003cString\u003e getHttpPortInternal()",
				"documentation": ""
			},
			{
				"signature": "private List\u003cString\u003e getReadinessPortInternal()",
				"documentation": ""
			},
			{
				"signature": "private List\u003cString\u003e readPortsFile(Path file) throws IOException",
				"documentation": ""
			},
			{
				"signature": "private Path getExtractedDistributionDir()",
				"documentation": ""
			},
			{
				"signature": "public FileCollection getInstalledClasspath()",
				"documentation": ""
			},
			{
				"signature": "public FileCollection getInstalledFiles()",
				"documentation": ""
			},
			{
				"signature": "public List\u003cFileTree\u003e getDistributionClasspath()",
				"documentation": ""
			},
			{
				"signature": "public List\u003cFileTree\u003e getDistributionFiles()",
				"documentation": ""
			},
			{
				"signature": "private List\u003cFileTree\u003e getDistributionFiles(Action\u003cPatternFilterable\u003e patternFilter)",
				"documentation": ""
			},
			{
				"signature": "public List\u003cFile\u003e getRoleFiles()",
				"documentation": ""
			},
			{
				"signature": "public List\u003c?\u003e getKeystoreSettings()",
				"documentation": ""
			},
			{
				"signature": "public List\u003c?\u003e getKeystoreFiles()",
				"documentation": ""
			},
			{
				"signature": "public List\u003c?\u003e getCliSetup()",
				"documentation": ""
			},
			{
				"signature": "public List\u003c?\u003e getSettings()",
				"documentation": ""
			},
			{
				"signature": "public List\u003c?\u003e getSystemProperties()",
				"documentation": ""
			},
			{
				"signature": "public List\u003c?\u003e getEnvironment()",
				"documentation": ""
			},
			{
				"signature": "public List\u003c?\u003e getJvmArgs()",
				"documentation": ""
			},
			{
				"signature": "public List\u003c?\u003e getExtraConfigFiles()",
				"documentation": ""
			},
			{
				"signature": "public List\u003cFeatureFlag\u003e getFeatureFlags()",
				"documentation": ""
			},
			{
				"signature": "public boolean isProcessAlive()",
				"documentation": ""
			},
			{
				"signature": "void waitForAllConditions()",
				"documentation": ""
			},
			{
				"signature": "public boolean equals(Object o)",
				"documentation": ""
			},
			{
				"signature": "public int hashCode()",
				"documentation": ""
			},
			{
				"signature": "public String toString()",
				"documentation": ""
			},
			{
				"signature": "List\u003cMap\u003cString, String\u003e\u003e getCredentials()",
				"documentation": ""
			},
			{
				"signature": "private boolean checkPortsFilesExistWithDelay(TestClusterConfiguration node)",
				"documentation": ""
			},
			{
				"signature": "public boolean isHttpSslEnabled()",
				"documentation": ""
			},
			{
				"signature": "void configureHttpWait(WaitForHttpResource wait)",
				"documentation": ""
			},
			{
				"signature": "void setHttpPort(String httpPort)",
				"documentation": ""
			},
			{
				"signature": "void setTransportPort(String transportPort)",
				"documentation": ""
			},
			{
				"signature": "void setDataPath(Path dataPath)",
				"documentation": ""
			},
			{
				"signature": "Path getEsLogFile()",
				"documentation": ""
			}
		],
		"interfaces": [
			"TestClusterConfiguration"
		]
	},
	{
		"documentation": "",
		"name": "org.elasticsearch.gradle.testclusters.ElasticsearchNode.FileEntry",
		"extends": "",
		"Methods": [
			{
				"signature": "FileEntry(String name, File file)",
				"documentation": ""
			},
			{
				"signature": "public String getName()",
				"documentation": ""
			},
			{
				"signature": "public File getFile()",
				"documentation": ""
			}
		],
		"interfaces": [
			"org.gradle.api.Named"
		]
	},
	{
		"documentation": "",
		"name": "org.elasticsearch.gradle.testclusters.ElasticsearchNode.CliEntry",
		"extends": "",
		"Methods": [
			{
				"signature": "CliEntry(String executable, CharSequence[] args)",
				"documentation": ""
			},
			{
				"signature": "public String getExecutable()",
				"documentation": ""
			},
			{
				"signature": "public CharSequence[] getArgs()",
				"documentation": ""
			}
		],
		"interfaces": []
	},
	{
		"documentation": "",
		"name": "org.elasticsearch.gradle.testclusters.private",
		"extends": "",
		"Methods": [
			{
				"signature": "public String getFeature()",
				"documentation": ""
			},
			{
				"signature": "public Version getFrom()",
				"documentation": ""
			},
			{
				"signature": "public Version getUntil()",
				"documentation": ""
			}
		],
		"interfaces": []
	},
	{
		"documentation": "",
		"name": "org.elasticsearch.gradle.testclusters.ElasticsearchNode.LinkCreationException",
		"extends": "java.io.UncheckedIOException",
		"Methods": [
			{
				"signature": "LinkCreationException(String message, IOException cause)",
				"documentation": ""
			}
		],
		"interfaces": []
	},
	{
		"documentation": "",
		"name": "org.elasticsearch.gradle.testclusters.RunTask",
		"extends": "DefaultTestClustersTask",
		"Methods": [
			{
				"signature": "public void setDebug(boolean enabled)",
				"documentation": ""
			},
			{
				"signature": "public Boolean getDebug()",
				"documentation": ""
			},
			{
				"signature": "public void setDataDir(String dataDirStr)",
				"documentation": ""
			},
			{
				"signature": "public Boolean getPreserveData()",
				"documentation": ""
			},
			{
				"signature": "public void setPreserveData(Boolean preserveData)",
				"documentation": ""
			},
			{
				"signature": "public void setKeystorePassword(String password)",
				"documentation": ""
			},
			{
				"signature": "public String getKeystorePassword()",
				"documentation": ""
			},
			{
				"signature": "public String getDataDir()",
				"documentation": ""
			},
			{
				"signature": "public void beforeStart()",
				"documentation": ""
			},
			{
				"signature": "public void runAndWait() throws IOException",
				"documentation": ""
			}
		],
		"interfaces": []
	},
	{
		"documentation": "/**\n * Customized version of Gradle {@link Test} task which tracks a collection of {@link ElasticsearchCluster} as a task input. We must do this\n * as a custom task type because the current {@link org.gradle.api.tasks.TaskInputs} runtime API does not have a way to register\n * {@link Nested} inputs.\n */",
		"name": "org.elasticsearch.gradle.testclusters.StandaloneRestIntegTestTask",
		"extends": "org.gradle.api.tasks.testing.Test",
		"Methods": [
			{
				"signature": "public StandaloneRestIntegTestTask()",
				"documentation": "/**\n * Customized version of Gradle {@link Test} task which tracks a collection of {@link ElasticsearchCluster} as a task input. We must do this\n * as a custom task type because the current {@link org.gradle.api.tasks.TaskInputs} runtime API does not have a way to register\n * {@link Nested} inputs.\n */"
			},
			{
				"signature": "public void setDebugServer(boolean enabled)",
				"documentation": ""
			},
			{
				"signature": "public int getMaxParallelForks()",
				"documentation": ""
			},
			{
				"signature": "public Collection\u003cElasticsearchCluster\u003e getClusters()",
				"documentation": ""
			},
			{
				"signature": "public List\u003cResourceLock\u003e getSharedResources()",
				"documentation": ""
			},
			{
				"signature": "private ResourceLock getResourceLock(SharedResource resource, int nodeCount)",
				"documentation": "/**\n     * SharedResource#getResourceLock has changed its parameters with Gradle 7.5.\n     * We resolve this via reflection for now to be compatible with Gradle before and after 7.5.\n     * This makes migration easier and allows gradle benchmark tests across gradle versions easier.\n     * Likely will be removed in future version.\n     * */"
			},
			{
				"signature": "public WorkResult delete(Object... objects)",
				"documentation": ""
			},
			{
				"signature": "public void beforeStart()",
				"documentation": ""
			}
		],
		"interfaces": [
			"TestClustersAware",
			"org.elasticsearch.gradle.FileSystemOperationsAware"
		]
	},
	{
		"documentation": "",
		"name": "org.elasticsearch.gradle.testclusters.TestClustersException",
		"extends": "RuntimeException",
		"Methods": [
			{
				"signature": "TestClustersException(String message)",
				"documentation": ""
			},
			{
				"signature": "TestClustersException(String message, Throwable cause)",
				"documentation": ""
			},
			{
				"signature": "TestClustersException(Throwable cause)",
				"documentation": ""
			}
		],
		"interfaces": []
	},
	{
		"documentation": "",
		"name": "org.elasticsearch.gradle.testclusters.TestClustersPlugin",
		"extends": "",
		"Methods": [
			{
				"signature": "protected FileSystemOperations getFileSystemOperations()",
				"documentation": ""
			},
			{
				"signature": "protected ArchiveOperations getArchiveOperations()",
				"documentation": ""
			},
			{
				"signature": "protected ExecOperations getExecOperations()",
				"documentation": ""
			},
			{
				"signature": "protected FileOperations getFileOperations()",
				"documentation": ""
			},
			{
				"signature": "public TestClustersPlugin(ProviderFactory providerFactory)",
				"documentation": ""
			},
			{
				"signature": "public void setRuntimeJava(Provider\u003cFile\u003e runtimeJava)",
				"documentation": ""
			},
			{
				"signature": "public void setIsReleasedVersion(Function\u003cVersion, Boolean\u003e isReleasedVersion)",
				"documentation": ""
			},
			{
				"signature": "public void apply(Project project)",
				"documentation": ""
			},
			{
				"signature": "private NamedDomainObjectContainer\u003cElasticsearchCluster\u003e createTestClustersContainerExtension(        Project project,        Provider\u003cReaperService\u003e reaper    )",
				"documentation": ""
			},
			{
				"signature": "private void createListClustersTask(Project project, NamedDomainObjectContainer\u003cElasticsearchCluster\u003e container)",
				"documentation": ""
			}
		],
		"interfaces": [
			"org.gradle.api.Plugin"
		]
	},
	{
		"documentation": "",
		"name": "org.elasticsearch.gradle.testclusters.TestClustersPlugin.TestClustersHookPlugin",
		"extends": "",
		"Methods": [
			{
				"signature": "public void apply(Project project)",
				"documentation": ""
			},
			{
				"signature": "private static void configureClaimClustersHook(Gradle gradle, TestClustersRegistry registry)",
				"documentation": ""
			},
			{
				"signature": "private static void configureStartClustersHook(Gradle gradle, TestClustersRegistry registry)",
				"documentation": ""
			},
			{
				"signature": "public void beforeActions(Task task)",
				"documentation": ""
			},
			{
				"signature": "public void afterActions(Task task)",
				"documentation": ""
			},
			{
				"signature": "private static void configureStopClustersHook(Gradle gradle, TestClustersRegistry registry)",
				"documentation": ""
			},
			{
				"signature": "public void afterExecute(Task task, TaskState state)",
				"documentation": ""
			},
			{
				"signature": "public void beforeExecute(Task task)",
				"documentation": ""
			}
		],
		"interfaces": [
			"org.gradle.api.Plugin"
		]
	},
	{
		"documentation": "",
		"name": "org.elasticsearch.gradle.testclusters.TestClustersRegistry",
		"extends": "",
		"Methods": [
			{
				"signature": "public void claimCluster(ElasticsearchCluster cluster)",
				"documentation": ""
			},
			{
				"signature": "public void maybeStartCluster(ElasticsearchCluster cluster)",
				"documentation": ""
			},
			{
				"signature": "public void stopCluster(ElasticsearchCluster cluster, boolean taskFailed)",
				"documentation": ""
			}
		],
		"interfaces": [
			"org.gradle.api.services.BuildService"
		]
	},
	{
		"documentation": "",
		"name": "org.elasticsearch.gradle.testclusters.TestClustersThrottle",
		"extends": "",
		"Methods": [],
		"interfaces": [
			"org.gradle.api.services.BuildService"
		]
	},
	{
		"documentation": "/**\n * An enumeration of the distributions that may be used in test clusters.\n */",
		"name": "org.elasticsearch.gradle.testclusters.TestDistribution",
		"extends": "",
		"Methods": [],
		"interfaces": []
	}
]
